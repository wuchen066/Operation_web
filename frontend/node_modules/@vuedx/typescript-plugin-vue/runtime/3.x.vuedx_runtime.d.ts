import { Directive, Ref, GlobalDirectives, Slot, VNodeChild, EmitsOptions, ObjectEmitsOptions, unref, defineComponent } from '@vue/runtime-core';

declare function checkDirective<
  T,
  D extends Directive<T, unknown> | 'show' | 'once' | 'pre' | 'cloak' | 'memo',
>(
  dir: D,
  tag: T,
  arg: GetArg$2<D>,
  exp: GetExp$2<T, D>,
  modifiers: Partial<Record<GetModifiers$2<D>, boolean>>,
): void

type GetArg$2<D> = D extends Directive<any, any> ? string | undefined : undefined

type GetExp$2<T, D> = D extends 'show'
  ? boolean | undefined
  : D extends 'once' | 'pre' | 'cloak'
  ? never
  : D extends 'memo'
  ? unknown[]
  : D extends Directive<T, infer E>
  ? E
  : any

type GetModifiers$2<D> = D extends Directive<unknown, unknown> ? never : never

/* eslint-disable @typescript-eslint/prefer-function-type */
type TupleToUnion<T> = T extends Readonly<[infer F, ...infer R]>
  ? F | TupleToUnion<R>
  : T extends Readonly<Array<infer R>>
  ? R
  : never

type UnionToIntersection<U> = (
  U extends any ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

type OnlyEventNames<K extends string | number | symbol> =
  K extends `on${Capitalize<string>}` ? K : never

// prettier-ignore
type EventName<T extends string> = `on${Capitalize<T>}`

// prettier-ignore
type RemoveOnPrefix<T extends string> = T extends `on${infer K}` ? Uncapitalize<K> : T

type KnownKeys<T> = {
  [K in keyof T as string extends K
    ? never
    : number extends K
    ? never
    : K]: T[K]
}

type FlatArray<Arr, Depth extends number> = {
  done: Arr
  recur: Arr extends ReadonlyArray<infer InnerArr>
    ? FlatArray<
        InnerArr,
        [
          -1,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
        ][Depth]
      >
    : Arr
}[Depth extends -1 ? 'done' : 'recur']

declare function flat<T extends unknown[], D extends number = 1>(
  array: T,
  depth?: D,
): Array<FlatArray<T, D>>

declare function first<T>(items: T[]): T

declare function union<T extends unknown[]>(...args: T): TupleToUnion<T>

declare function record<K extends string | number | symbol, V>(key: K, value: V): Record<K, V>

type Get<T, K, F = never> = K extends keyof T ? T[K] : F

declare function getNameOption<T>(
  t?: T,
): T extends { name: infer N } ? N : undefined

declare function merge<A extends {}, B extends {}>(a: A, b: B): A & B

type Instantiate<T> = T extends new (...args: any) => infer R ? R : never

type PropsOf<IntrinsicElements, T> = T extends KnownKeys<
  keyof IntrinsicElements
>
  ? IntrinsicElements[T]
  : Instantiate<T> extends {
      $props: infer Props
    }
  ? Props
  : never

type MergeAttrs<Props, Attrs> = Props &
  Omit<Attrs, keyof KnownKeys<Props>>

declare function checkModelDirective<
  T,
  A extends GetArg$1<T>,
  O extends {},
  E extends GetExp$1<T, A, O>,
  M extends GetModifiers$1<T>
>(
  tag: T,
  arg: A,
  exp: E,
  modifiers: Partial<Record<M, boolean>>,
  options?: O,
): E

type GetArg$1<T> = T extends 'input' | 'textarea' | 'select'
  ? undefined
  : T extends KnownKeys<keyof JSX.IntrinsicElements>
  ? never
  : keyof PropsOf<T>

type GetExp$1<T, A, O> = T extends 'textarea'
  ? string
  : T extends 'input'
  ? InputValueType<O> | undefined | null
  : T extends 'select'
  ? SelectValueType<O>
  : T extends KnownKeys<keyof JSX.IntrinsicElements>
  ? never
  : Get<PropsOf<T>, A>

type GetModifiers$1<T> = T extends 'input' | 'textarea' | 'select'
  ? 'lazy' | 'number' | 'trim'
  : never // acts as a catch-all

type InputValueType<O> = O extends { type: infer T }
  ? T extends 'checkbox'
    ? O extends { checkbox: infer C }
      ? C extends [infer Y, infer N]
        ? Y | N
        : TupleToUnion<C>
      : boolean
    : T extends 'radio'
    ? O extends { radio: infer R }
      ? TupleToUnion<R>
      : string
    : T extends 'date' | 'datetime' | 'datetime-local'
    ? string | Date
    : T extends 'number' | 'range'
    ? string | number
    : T extends 'button' | 'reset' | 'submit'
    ? never
    : string
  : string

type SelectValueType<O> = O extends { option: infer T }
  ? TupleToUnion<T>
  : string

declare function checkHTMLElementType<K extends string>(
  tag: K,
  instance: unknown,
): instance is K extends keyof KnownKeys<HTMLElementTagNameMap>
  ? HTMLElementTagNameMap[K]
  : K extends keyof KnownKeys<SVGElementTagNameMap>
  ? SVGElementTagNameMap[K]
  : EventTarget

declare function checkOnDirective<
  IntrinsicElements,
  T,
  A extends GetArg<IntrinsicElements, T>,
>(
  intrinsicElements: IntrinsicElements,
  tag: T,
  arg: A & GetArg<IntrinsicElements, T>,
  exp: GetExp<IntrinsicElements, T, A>,
  modifiers: Partial<Record<GetModifiers<IntrinsicElements, T, A>, boolean>>,
): void

type MouseEventNames =
  | 'auxclick'
  | 'click'
  | 'contextmenu'
  | 'dbclick'
  | 'mousedown'
  | 'mouseenter'
  | 'mousemove'
  | 'mouseleave'
  | 'mouseout'
  | 'mouseover'
  | 'mouseup'
  | 'wheel'
type PointerEventNames =
  | 'pointerdown'
  | 'pointermove'
  | 'pointerup'
  | 'pointercancel'
  | 'pointerenter'
  | 'pointerleave'
  | 'pointerover'
  | 'pointerout'
type KeyboardEventNames = 'keydown' | 'keypress' | 'keyup'
type ModifiersForNativeEvent<EventName> =
  | 'once'
  | 'stop'
  | 'prevent'
  | 'capture'
  | 'self'
  | 'passive'
  | (EventName extends KeyboardEventNames
      ?
          | 'enter'
          | 'tab'
          | 'delete'
          | 'esc'
          | 'space'
          | 'left'
          | 'right'
          | 'up'
          | 'down'
          | 'ctrl'
          | 'alt'
          | 'shift'
          | 'meta'
          | 'exact'
      : never)
  | (EventName extends PointerEventNames
      ?
          | 'left'
          | 'right'
          | 'middle'
          | 'ctrl'
          | 'alt'
          | 'shift'
          | 'meta'
          | 'exact'
      : never)
  | (EventName extends MouseEventNames
      ?
          | 'left'
          | 'right'
          | 'middle'
          | 'ctrl'
          | 'alt'
          | 'shift'
          | 'meta'
          | 'exact'
      : never)

type GetArg<IntrinsicElements, T> = RemoveOnPrefix<
  OnlyEventNames<keyof PropsOf<IntrinsicElements, T>>
>

type GetExp<IntrinsicElements, T, A extends GetArg<IntrinsicElements, T>> = Get<
  PropsOf<IntrinsicElements, T>,
  EventName<A>
>

type GetModifiers<IntrinsicElements, T, A> =
  T extends keyof KnownKeys<IntrinsicElements>
    ? A extends GetArg<IntrinsicElements, T>
      ? ModifiersForNativeEvent<A>
      : never
    : never

declare function checkInterpolation(
  value: string | boolean | number | null | undefined,
): string

/**
 * @deprecated - You should not be using interpolation to render objects.
 */
declare function checkInterpolation(value: object | symbol | unknown[]): string

type RefValue<T> = T extends (value: infer V) => unknown ? V : T

declare function checkRef<T>(
  ref: T | ((value: T) => unknown) | null,
  element: RefValue<T>,
): Ref<T>

/* eslint-disable @typescript-eslint/no-empty-interface */


declare module '@vue/runtime-core' {
  export interface GlobalComponents {}
}

declare module '@vue/runtime-dom' {
  export interface GlobalComponents {}
}

declare module 'vue' {
  export interface GlobalComponents {}
}

declare function resolveComponent<
  GlobalComponents,
  IntrinsicElements,
  T extends {},
  A,
  B,
  C,
>(
  globalComponents: GlobalComponents,
  elements: IntrinsicElements,
  context: T,
  id: A,
  usedName?: B,
  pascalName?: C,
): true extends IsNotComponent<A>
  ? B extends keyof KnownKeys<T>
    ? T[B]
    : C extends keyof KnownKeys<T>
    ? T[C]
    : B extends keyof KnownKeys<GlobalComponents>
    ? GlobalComponents[B]
    : C extends keyof KnownKeys<GlobalComponents>
    ? GlobalComponents[C]
    : B extends keyof KnownKeys<IntrinsicElements>
    ? IntrinsicElements[B]
    : C extends keyof KnownKeys<IntrinsicElements>
    ? IntrinsicElements[C]
    : A
  : A

type IsNotComponent<T> = true extends IsStrictlyAny<T>
  ? true
  : T extends null | undefined | never
  ? true
  : false

type IsStrictlyAny<T> = (T extends never ? true : false) extends false
  ? false
  : true

/* eslint-disable @typescript-eslint/no-empty-interface */


declare module '@vue/runtime-core' {
  interface GlobalDirectives {}
}

declare function resolveDirective<T extends {}, A, B>(
  localRegisteredDirectives: T,
  directiveName: A,
  directiveNameInCamelCase?: B,
): A extends keyof KnownKeys<T>
  ? T[A]
  : B extends keyof KnownKeys<T>
  ? T[B]
  : A extends keyof KnownKeys<GlobalDirectives>
  ? GlobalDirectives[A]
  : B extends keyof KnownKeys<GlobalDirectives>
  ? GlobalDirectives[B]
  : never

type ElementType<E> = E extends string
  ? E extends keyof KnownKeys<HTMLElementTagNameMap>
    ? HTMLElementTagNameMap[E]
    : E extends keyof KnownKeys<SVGElementTagNameMap>
    ? SVGElementTagNameMap[E]
    : never
  : E

declare function getElementType<T>(tagNameOrComponent: T): ElementType<T>

declare function renderList<T, R>(
  source: T[],
  handler: (value: T, index: number) => R,
): R[]
declare function renderList<T extends Readonly<unknown[]>, R>(
  source: T,
  handler: (value: TupleToUnion<T>, index: number) => R,
): R[]
declare function renderList<T, R>(
  source: Iterable<T>,
  handler: (value: T, index: number) => R,
): R
declare function renderList<T extends object, R>(
  source: T,
  handler: <K extends keyof T>(value: T[K], key: K, index: number) => R,
): R[]
declare function renderList<R>(
  source: string,
  handler: (value: string, index: number) => R,
): R[]
declare function renderList<R>(
  source: number,
  handler: (value: number, index: number) => R,
): R[]

type Fallback<T, F> = T extends undefined ? F : T
type SlotProps<T extends Slot | undefined> = T extends (
  ...args: unknown[]
) => unknown
  ? Fallback<Parameters<T>[0], {}>
  : {}

// -- renderSlot --
declare function renderSlot<
  S extends Readonly<{
    [name: string]: Slot | undefined
  }>,
  K extends keyof S
>(source: S, name: K, props: SlotProps<S[K]>): any

type InternalSlots<T> = {
  [K in keyof T]: (props: T[K]) => VNodeChild
}

type Slots<T> = [T] extends [never]
  ? Record<string|number|symbol, never>
  : InternalSlots<UnionToIntersection<T>>

type FirstParameter<T> = T extends (
  arg: infer P,
  ...others: unknown[]
) => unknown
  ? P
  : undefined

type GetSlotProps<T, N> = FirstParameter<
  N extends keyof SlotsFrom<T> ? SlotsFrom<T>[N] : () => void
>

type SlotsFrom<T> = T extends new (...args: any[]) => any
  ? InstanceType<T> extends { $slots: infer S }
    ? S
    : {}
  : {}

declare function checkSlots<T>(
  component: T,
  slots: Partial<SlotsFrom<T>>,
): typeof slots

/* eslint-disable @typescript-eslint/prefer-function-type */


type EmitsToProps<T extends EmitsOptions> = T extends string[]
  ? Partial<{
      [K in string & EventName<T[number]>]: (...args: any[]) => any
    }>
  : T extends ObjectEmitsOptions
  ? Partial<{
      [K in string &
        EventName<Capitalize<string & keyof T>>]: K extends `on${infer C}`
        ? T[Uncapitalize<C>] extends (...args: infer A) => any
          ? (...args: A) => any
          : () => any
        : never
    }>
  : {}

// // Quick Test: Event Names
// declare namespace T1 {
//   type T = EmitsToProps<['a', 'b']>
//   type T1 = T['onA']
//   type T2 = T['onB']
// }

// // Quick Test: Handler Types
// declare namespace T2 {
//   type T = EmitsToProps<{ a(value: string): void; b(value: number): void }>
//   type T1 = T['onA']
//   type T2 = T['onB']
// }

type Handler<K, A extends unknown[], R> = {
  [P in string & K]: (...args: A) => R
}

/**
 * Support upto 10 overloads.
 */
type EmitTypeToEmits<F> = F extends {
  (event: infer E0, ...args: infer A0): infer R0
  (event: infer E1, ...args: infer A1): infer R1
  (event: infer E2, ...args: infer A2): infer R2
  (event: infer E3, ...args: infer A3): infer R3
  (event: infer E4, ...args: infer A4): infer R4
  (event: infer E5, ...args: infer A5): infer R5
  (event: infer E6, ...args: infer A6): infer R6
  (event: infer E7, ...args: infer A7): infer R7
  (event: infer E8, ...args: infer A8): infer R8
  (event: infer E9, ...args: infer A9): infer R9
}
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3> &
      Handler<E4, A4, R4> &
      Handler<E5, A5, R5> &
      Handler<E6, A6, R6> &
      Handler<E7, A7, R7> &
      Handler<E8, A8, R8> &
      Handler<E9, A9, R9>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
      (event: infer E3, ...args: infer A3): infer R3
      (event: infer E4, ...args: infer A4): infer R4
      (event: infer E5, ...args: infer A5): infer R5
      (event: infer E6, ...args: infer A6): infer R6
      (event: infer E7, ...args: infer A7): infer R7
      (event: infer E8, ...args: infer A8): infer R8
    }
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3> &
      Handler<E4, A4, R4> &
      Handler<E5, A5, R5> &
      Handler<E6, A6, R6> &
      Handler<E7, A7, R7> &
      Handler<E8, A8, R8>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
      (event: infer E3, ...args: infer A3): infer R3
      (event: infer E4, ...args: infer A4): infer R4
      (event: infer E5, ...args: infer A5): infer R5
      (event: infer E6, ...args: infer A6): infer R6
      (event: infer E7, ...args: infer A7): infer R7
    }
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3> &
      Handler<E4, A4, R4> &
      Handler<E5, A5, R5> &
      Handler<E6, A6, R6> &
      Handler<E7, A7, R7>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
      (event: infer E3, ...args: infer A3): infer R3
      (event: infer E4, ...args: infer A4): infer R4
      (event: infer E5, ...args: infer A5): infer R5
      (event: infer E6, ...args: infer A6): infer R6
    }
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3> &
      Handler<E4, A4, R4> &
      Handler<E5, A5, R5> &
      Handler<E6, A6, R6>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
      (event: infer E3, ...args: infer A3): infer R3
      (event: infer E4, ...args: infer A4): infer R4
      (event: infer E5, ...args: infer A5): infer R5
    }
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3> &
      Handler<E4, A4, R4> &
      Handler<E5, A5, R5>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
      (event: infer E3, ...args: infer A3): infer R3
      (event: infer E4, ...args: infer A4): infer R4
    }
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3> &
      Handler<E4, A4, R4>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
      (event: infer E3, ...args: infer A3): infer R3
    }
  ? Handler<E0, A0, R0> &
      Handler<E1, A1, R1> &
      Handler<E2, A2, R2> &
      Handler<E3, A3, R3>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
      (event: infer E2, ...args: infer A2): infer R2
    }
  ? Handler<E0, A0, R0> & Handler<E1, A1, R1> & Handler<E2, A2, R2>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
      (event: infer E1, ...args: infer A1): infer R1
    }
  ? Handler<E0, A0, R0> & Handler<E1, A1, R1>
  : F extends {
      (event: infer E0, ...args: infer A0): infer R0
    }
  ? Handler<E0, A0, R0>
  : {}

/* eslint-disable @typescript-eslint/no-empty-interface */


type version = '3.x'

declare namespace internal {
  export { first, flat, union, merge, record, getNameOption, unref }
  export { resolveComponent, resolveDirective, getElementType }
  export { renderList, renderSlot, Slots, GetSlotProps }
  export { defineComponent }
  export {
    checkInterpolation,
    checkRef,
    checkSlots,
    checkDirective,
    checkOnDirective,
    checkHTMLElementType,
    checkModelDirective,
  }

  export { PropsOf, SlotsFrom, MergeAttrs, EmitsToProps, EmitTypeToEmits }
}

export { internal, version };
//# sourceMappingURL=3.x.vuedx_runtime.d.ts.map
