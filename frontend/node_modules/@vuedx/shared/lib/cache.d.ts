export interface Cache<K, V> {
    has(key: K): boolean;
    get(key: K): V | undefined;
    set(key: K, value: V): void;
    delete(key: K): void;
    clear(): void;
    resolve(key: K, getter: (key: K) => V): V;
    resolveAsync(key: K, getter: (key: K) => Promise<V>): Promise<V>;
}
export declare function createCache<K, V>(size?: number): Cache<K, V>;
export declare function createWeakMapCache<K extends object, V>(): Cache<K, V>;
export declare function createMultiKeyCache<K, V, R = unknown>(getSecondaryKey: (key: K) => R, size?: number, compare?: (a: R, b: R) => boolean): Cache<K, V>;
export declare function createVersionedCache<K, V, Version extends string | number = string | number>(getVersion: (key: K) => Version, size?: number): Cache<K, V>;
export declare function versionedAsync<T extends unknown[], R = unknown>(getKey?: (args: T) => R, size?: number, versionFn?: unknown & string): MethodDecorator;
/** Cache results using as secondary version key. */
export declare function versioned<T extends unknown[], R = unknown>(getKey?: (args: T) => R, size?: number, versionFn?: unknown & string, isAsync?: boolean): MethodDecorator;
export declare function cache<T extends unknown[], I = unknown, R = unknown>(getKey?: (args: T, instance: I) => R, isAsync?: boolean, isWeak?: boolean): MethodDecorator;
export declare function cacheAsync<T extends unknown[], R = unknown>(getKey?: (args: T) => R): MethodDecorator;
export declare function cacheAll<T extends unknown[], R = unknown>(getKey?: (args: T) => R): MethodDecorator;
export declare function cacheAllAsync<T extends unknown[], R = unknown>(getKey?: (args: T) => R): MethodDecorator;
export declare function clearMethodCache(instance: object, propertyKey: string | symbol | number): void;
//# sourceMappingURL=cache.d.ts.map