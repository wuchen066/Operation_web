export declare function isArray<T>(value: any): value is T[];
export declare function first<T>(items: T[] | readonly T[]): T;
export declare function last<T>(items: T[] | readonly T[], nth?: number): T;
export declare function findPrevSibling<T>(items: T[] | readonly T[], item: T): T | undefined;
export declare function findNextSibling<T>(items: T[] | readonly T[], item: T): T | undefined;
export declare function concat<T>(a: T[] | Readonly<T[]> | undefined, b: T[] | Readonly<T[]> | undefined): T[];
declare type FlatArray<Arr, Depth extends number> = {
    done: Arr;
    recur: Arr extends ReadonlyArray<infer InnerArr> ? FlatArray<InnerArr, [
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20
    ][Depth]> : Arr;
}[Depth extends -1 ? 'done' : 'recur'];
export declare function flatten<T extends unknown, D extends number = 1>(array: T, depth?: D): Array<FlatArray<T, D>>;
declare type Chunk<T, Size extends number> = {
    done: [];
    recurr: [
        T,
        ...Chunk<T, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20
        ][Size]>
    ];
}[Size extends 0 ? 'done' : 'recurr'];
export declare function chunk<T, D extends number>(items: T[], chunkSize: D): Array<Chunk<T, D>>;
export declare const BinarySearchBias: {
    GREATEST_LOWER_BOUND: number;
    LEAST_UPPER_BOUND: number;
};
declare type BinarySearchBiasType = typeof BinarySearchBias[keyof typeof BinarySearchBias];
export declare function binarySearch<T>(needle: T, haystack: T[], compare: (a: T, b: T) => number, bias?: BinarySearchBiasType): number;
export declare function binarySearchKey<T, U>(array: readonly T[], key: U, keySelector: (value: T, index: number) => U, keyComparer: (a: U, b: U) => number, offset?: number): number;
export {};
//# sourceMappingURL=array.d.ts.map