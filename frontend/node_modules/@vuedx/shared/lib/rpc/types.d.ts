import type { ExposedObject } from './handlers';
declare const release: unique symbol;
export declare const Symbols: {
    readonly release: typeof release;
};
interface RemoteObjectAPI {
    [Symbols.release](): Promise<void>;
}
declare type Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;
declare type Unpromisify<T> = T extends Promise<infer P> ? P : T;
declare type RemoteProperty<T> = T extends Function | ExposedObject<unknown> ? Remote<T> : Promisify<T>;
declare type LocalProperty<T> = T extends Function | ExposedObject<unknown> ? Local<T> : Unpromisify<T>;
declare type RemoteObject<T> = {
    [P in keyof T]: RemoteProperty<T[P]>;
};
declare type LocalObject<T> = {
    [P in keyof T]: LocalProperty<T[P]>;
};
declare type ProxyOrClone<T> = T extends ExposedObject<unknown> ? Remote<T> : T;
declare type UnproxyOrClone<T> = T extends RemoteObject<ExposedObject<unknown>> ? Local<T> : T;
export declare type Remote<T> = RemoteObject<T> & (T extends (...args: infer TArguments) => infer TReturn ? (...args: {
    [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;
}) => Promisify<ProxyOrClone<Unpromisify<TReturn>>> : unknown) & (T extends new (...args: infer TArguments) => infer TInstance ? new (...args: {
    [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;
}) => Promisify<Remote<TInstance>> : unknown) & RemoteObjectAPI;
export declare type Local<T> = Omit<LocalObject<T>, keyof RemoteObjectAPI> & (T extends (...args: infer TArguments) => infer TReturn ? (...args: {
    [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;
}) => MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>> : unknown) & (T extends new (...args: infer TArguments) => infer TInstance ? new (...args: {
    [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;
}) => MaybePromise<Local<Unpromisify<TInstance>>> : unknown);
/**
 * Expresses that a type can be either a sync or async.
 */
declare type MaybePromise<T> = Promise<T> | T;
export {};
//# sourceMappingURL=types.d.ts.map