'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const Path = require('path');
const OS = require('os');
const util = require('util');
const sourcemapCodec = require('sourcemap-codec');
const Sentry = require('@sentry/node');
const perf_hooks = require('perf_hooks');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    const n = Object.create(null);
    if (e) {
        for (const k in e) {
            if (k !== 'default') {
                const d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        }
    }
    n["default"] = e;
    return Object.freeze(n);
}

const Path__namespace = /*#__PURE__*/_interopNamespace(Path);
const OS__namespace = /*#__PURE__*/_interopNamespace(OS);
const Sentry__namespace = /*#__PURE__*/_interopNamespace(Sentry);

/**
 * Loose non-null (non-undefined) filter.
 * This method can be used as predicate for Array methods.
 */
function isNotNull(value) {
    return value != null;
}

function invariant(value, message) {
    if (value == null || value === false) {
        throw new Error(message);
    }
}

function isArray(value) {
    return Array.isArray(value);
}
function first(items) {
    if (items.length === 0)
        throw new Error('IndexOutOfBounds');
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return items[0];
}
function last(items, nth = 1) {
    const index = items.length - nth;
    if (index < 0 || index >= items.length)
        throw new Error('IndexOutOfBounds');
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return items[index];
}
function findPrevSibling(items, item) {
    const index = items.indexOf(item);
    if (index > 0)
        return items[index - 1];
    else
        return undefined;
}
function findNextSibling(items, item) {
    const index = items.indexOf(item);
    if (index >= 0)
        return items[index + 1];
    else
        return undefined;
}
function concat(a, b) {
    const c = [];
    if (isArray(a))
        c.push(...a);
    if (isArray(b))
        c.push(...b);
    return c;
}
function flatten(array, depth = 1) {
    const items = [];
    if (Array.isArray(array)) {
        array.forEach((item) => {
            if (Array.isArray(item)) {
                if (depth > 1)
                    items.push(...flatten(item, depth - 1));
                else
                    items.push(...item);
            }
            else {
                items.push(item);
            }
        });
    }
    return items;
}
function chunk(items, chunkSize) {
    const chunks = [];
    for (let i = 0; i < items.length; i += chunkSize) {
        chunks.push(items.slice(i, i + chunkSize));
    }
    return chunks;
}
const BinarySearchBias = {
    GREATEST_LOWER_BOUND: 1,
    LEAST_UPPER_BOUND: 2,
};
function recursiveSearch(low, high, needle, haystack, compare, bias) {
    if (haystack.length === 0)
        return -1;
    const mid = Math.floor((low + high) / 2);
    const value = haystack[mid];
    const comparison = (() => {
        try {
            return compare(needle, value);
        }
        catch (e) {
            throw new Error(`ComparisonError: ${e.message}. low: ${low}, high: ${high}, mid: ${mid}`);
        }
    })();
    if (comparison === 0)
        return mid;
    else if (comparison > 0) {
        if (high - mid > 1) {
            return recursiveSearch(mid, high, needle, haystack, compare, bias);
        }
        if (bias === BinarySearchBias.LEAST_UPPER_BOUND) {
            return high < haystack.length ? high : -1;
        }
        else {
            return mid;
        }
    }
    else {
        if (mid - low > 1) {
            return recursiveSearch(low, mid, needle, haystack, compare, bias);
        }
        if (bias === BinarySearchBias.GREATEST_LOWER_BOUND) {
            return low < 0 ? -1 : low;
        }
        else {
            return mid;
        }
    }
}
function binarySearch(needle, haystack, compare, bias = BinarySearchBias.GREATEST_LOWER_BOUND) {
    let index = recursiveSearch(-1, haystack.length, needle, haystack, compare, bias);
    if (index < 0)
        return -1;
    while (index > 0 &&
        compare(haystack[index], haystack[index - 1]) === 0) {
        --index;
    }
    return index;
}
function binarySearchKey(array, key, keySelector, keyComparer, offset = 0) {
    if (array.length === 0)
        return -1;
    let low = offset;
    let high = array.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const middleValue = array[middle];
        invariant(middleValue != null);
        const midKey = keySelector(middleValue, middle);
        const comparison = keyComparer(midKey, key);
        if (comparison === 0)
            return middle;
        else if (comparison < 0)
            low = middle + 1;
        else
            high = middle - 1;
    }
    return ~low;
}

class BaseCache {
    constructor() {
        this.promises = new Map();
    }
    resolve(key, getter) {
        if (this.has(key)) {
            return this.get(key);
        }
        const value = getter(key);
        this.set(key, value);
        return value;
    }
    async resolveAsync(key, getter) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.has(key))
            return this.get(key);
        const promise = this.promises.get(key) ?? getter(key);
        this.promises.set(key, promise);
        try {
            const value = await promise;
            this.set(key, value);
            return value;
        }
        finally {
            this.promises.delete(key);
        }
    }
}
class LRU extends BaseCache {
    constructor(maxSize) {
        super();
        this.maxSize = maxSize;
        this.current = new Map();
        this.previous = new Map();
    }
    has(key) {
        return this.current.has(key) || this.previous.has(key);
    }
    get(key) {
        if (this.current.has(key))
            return this.current.get(key);
        else if (this.previous.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const value = this.previous.get(key);
            this.set(key, value);
            return value;
        }
        else
            return undefined;
    }
    set(key, value) {
        this.current.set(key, value);
        if (this.current.size > this.maxSize) {
            this.previous = this.current;
            this.current = new Map();
        }
    }
    delete(key) {
        this.current.delete(key);
        this.previous.delete(key);
    }
    clear() {
        this.current.clear();
        this.previous.clear();
    }
}
class WeakCache extends BaseCache {
    constructor() {
        super(...arguments);
        this.storage = new WeakMap();
    }
    has(key) {
        return this.storage.has(key);
    }
    get(key) {
        return this.storage.get(key);
    }
    set(key, value) {
        this.storage.set(key, value);
    }
    delete(key) {
        this.storage.delete(key);
    }
    clear() {
        this.storage = new WeakMap();
    }
}
class VersionedCache extends BaseCache {
    constructor(size, getVersion, compareVersion) {
        super();
        this.getVersion = getVersion;
        this.compareVersion = compareVersion;
        this.storage = new LRU(size);
    }
    isValid(key, value) {
        return this.compareVersion(value.version, this.getVersion(key));
    }
    has(key) {
        return this.storage.has(key) && this.isValid(key, this.storage.get(key));
    }
    get(key) {
        if (this.has(key))
            return this.storage.get(key).value;
        else
            return undefined;
    }
    set(key, value) {
        this.storage.set(key, { version: this.getVersion(key), value });
    }
    delete(key) {
        this.storage.delete(key);
    }
    clear() {
        this.storage.clear();
    }
}
const DEFAULT_CACHE_SIZE = 100;
function createCache(size = DEFAULT_CACHE_SIZE) {
    return new LRU(size);
}
function createWeakMapCache() {
    return new WeakCache();
}
function createMultiKeyCache(getSecondaryKey, size = DEFAULT_CACHE_SIZE, compare = (a, b) => a === b) {
    return new VersionedCache(size, (key) => getSecondaryKey(key), compare);
}
function createVersionedCache(getVersion, size = DEFAULT_CACHE_SIZE) {
    return createMultiKeyCache(getVersion, size);
}
function versionedAsync(getKey = (args) => args[0], size = DEFAULT_CACHE_SIZE, versionFn = 'getVersion') {
    return versioned(getKey, size, versionFn, true);
}
const store = new Map();
function addToStore(target, property, cache) {
    const current = store.get(target) ?? new Map();
    current.set(property, cache);
    if (!store.has(target))
        store.set(target, current);
}
function getOrCreate(map, create) {
    return (key) => {
        const value = map.get(key) ?? create(key);
        if (!map.has(key))
            map.set(key, value);
        return value;
    };
}
/** Cache results using as secondary version key. */
function versioned(getKey = (args) => args[0], size = DEFAULT_CACHE_SIZE, versionFn = 'getVersion', isAsync = false) {
    const method = isAsync ? 'resolveAsync' : 'resolve';
    return (target, propertyKey, descriptor) => {
        const fn = descriptor?.value;
        if (typeof fn === 'function') {
            const caches = new WeakMap();
            const using = getOrCreate(caches, (instance) => {
                const getVersion = instance[versionFn];
                if (typeof getVersion !== 'function')
                    throw new Error(`${JSON.stringify(versionFn)} is not a function`);
                return createVersionedCache((key) => getVersion.call(instance, key), size);
            });
            addToStore(target, propertyKey, caches);
            descriptor.value = function (...args) {
                return using(this)[method](getKey(args), () => fn.apply(this, args));
            };
        }
        else {
            throw new Error(`${JSON.stringify(propertyKey)} is not a function`);
        }
        return descriptor;
    };
}
function cache(getKey = (args) => args[0], isAsync = false, isWeak = false) {
    const method = isAsync ? 'resolveAsync' : 'resolve';
    return (target, propertyKey, descriptor) => {
        const fn = descriptor?.value;
        if (typeof fn === 'function') {
            const caches = new WeakMap();
            addToStore(target, propertyKey, caches);
            const using = getOrCreate(caches, () => {
                return isWeak ? createWeakMapCache() : createCache(DEFAULT_CACHE_SIZE);
            });
            descriptor.value = function (...args) {
                return using(this)[method](getKey(args, this), () => fn.apply(this, args));
            };
        }
        else {
            throw new Error(`${JSON.stringify(propertyKey)} is not a function`);
        }
        return descriptor;
    };
}
function cacheAsync(getKey = (args) => args[0]) {
    return cache(getKey, true);
}
function cacheAll(getKey = (args) => args[0]) {
    return cache(getKey, false, true);
}
function cacheAllAsync(getKey = (args) => args[0]) {
    return cache(getKey, true, true);
}
function clearMethodCache(instance, propertyKey) {
    const target = Object.getPrototypeOf(instance);
    store.get(target)?.get(propertyKey)?.get(instance)?.clear();
}

function toPosixPath(path) {
    return path.includes('\\') ? path.replace(/\\/g, '/') : path;
}
function toWindowsPath(path) {
    return path.includes('/') ? path.replace(/\//g, '\\') : path;
}
const toPlatformPath = 
/* istanbul ignore next */
OS__namespace.platform() === 'win32' ? toWindowsPath : toPosixPath;
function getRelativeFileName(importingFileName, importedFileName) {
    importingFileName = toPosixPath(importingFileName);
    importedFileName = toPosixPath(importedFileName);
    if (Path__namespace.posix.isAbsolute(importingFileName) &&
        Path__namespace.posix.isAbsolute(importedFileName)) {
        const fileName = Path__namespace.posix.relative(Path__namespace.posix.dirname(importingFileName), importedFileName);
        return fileName.startsWith('.') ? fileName : `./${fileName}`;
    }
    return importedFileName;
}

function isString(value) {
    return typeof value === 'string';
}
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit ?? (cache[str] = fn(str));
    });
};
const camelizeRE = /[^A-Za-z0-9]+([A-Za-z0-9])?/g;
const camelize = cacheStringFunction((str) => {
    return uncapitalize(str.replace(camelizeRE, (_, c) => typeof c === 'string' ? c.toUpperCase() : ''));
});
const camelCase = camelize;
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => {
    return camelize(str).replace(hyphenateRE, '-$1').toLowerCase();
});
const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const uncapitalize = cacheStringFunction((str) => {
    return str.charAt(0).toLowerCase() + str.slice(1);
});
const pascalCase = cacheStringFunction((str) => capitalize(camelize(str)));
const kebabCase = hyphenate;
function isKebabCase(str) {
    return str.includes('-') || /^[a-z0-9]+$/.test(str);
}
function isPascalCase(str) {
    return /^[A-Z][A-Za-z0-9]*$/.test(str);
}
function isCamelCase(str) {
    return /^[a-z][A-Za-z0-9]*$/.test(str);
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join('-');
}
function ucfirst(str) {
    return str.slice(0, 1).toUpperCase() + str.slice(1);
}
function lcfirst(str) {
    return str.slice(0, 1).toLowerCase() + str.slice(1);
}
function trimIndent(content) {
    const lines = content
        .trimStart()
        .replace(/\n\s*$/, '')
        .split('\n');
    const indent = lines.slice(1).reduce((min, line) => {
        const match = line.match(/^\s+/);
        const len = match?.[0] != null ? match[0].length : 0;
        return Math.min(min, len);
    }, Infinity);
    if (lines.length <= 1)
        return first(lines) + '\n';
    return (first(lines) +
        '\n' +
        lines
            .slice(1)
            .map((line) => line.slice(indent))
            .join('\n') +
        '\n');
}

function getComponentName(fileName) {
    const name = pascalCase(Path__namespace.posix
        .basename(toPosixPath(fileName))
        .replace(/\.(vue|ts|tsx|js|jsx)$/, ''));
    return prefixIfStartsWithNumber(name);
}
function prefixIfStartsWithNumber(name) {
    if (/^[0-9]/.test(name)) {
        return `_${name}`;
    }
    else
        return name;
}
function getComponentNameAliases(fileNameOrComponentName) {
    const name = Path__namespace.posix
        .basename(toPosixPath(fileNameOrComponentName))
        .replace(/\.(vue|ts|tsx|js|jsx)$/, '');
    return isKebabCase(name)
        ? [prefixIfStartsWithNumber(kebabCase(name))]
        : [
            prefixIfStartsWithNumber(kebabCase(name)),
            prefixIfStartsWithNumber(pascalCase(name)),
        ];
}

let isDebugging = true;
function setDebugging(debugging) {
    isDebugging = debugging;
}
function debug(printOnlyReturnStatement = true, transformArgs = (...args) => args, transformReturn = (ret) => ret) {
    return (target, key, descriptor) => {
        const fn = descriptor?.value;
        descriptor.value = function (...args) {
            if (isDebugging && !printOnlyReturnStatement) {
                this.logger.debug(`(call) ${target.constructor.name}.${String(key)}`, util.inspect(transformArgs(...args), false, 100, false));
            }
            const result = fn.apply(this, args);
            if (isDebugging) {
                this.logger.debug(`(return) ${target.constructor.name}.${String(key)}`, util.inspect(transformArgs(...args), false, 100, false), util.inspect(transformReturn(result), false, 100, false));
            }
            return result;
        };
        return descriptor;
    };
}

const suffixes = {
    vueTsx: '.tsx',
    vueJsx: '.jsx',
    vueSFCDescriptor: '+descriptor.jsonc',
    vueTemplateAST: '+template.jsonc',
    vueRuntime: '.vuedx_runtime.d.ts',
    vueProjectRuntime: 'project.vuedx_project_runtime.d.ts',
};
function parseFileName(fileName) {
    if (isFilesystemSchemeFile(fileName)) {
        const RE = /^\^\/(?<scheme>[^/]+)(\/ts-nul-authority)?(?<fileName>.*)$/;
        const result = RE.exec(fileName);
        invariant(result?.groups != null);
        invariant(result.groups['fileName'] != null);
        invariant(result.groups['scheme'] != null);
        return {
            type: 'scheme',
            fileName: result.groups['fileName'],
            scheme: result.groups['scheme'],
        };
    }
    else if (isVueTsxFile(fileName)) {
        return {
            type: 'vue-tsx',
            fileName: fileName.substring(0, fileName.length - suffixes.vueTsx.length),
        };
    }
    else if (isVueJsxFile(fileName)) {
        return {
            type: 'vue-jsx',
            fileName: fileName.substring(0, fileName.length - suffixes.vueJsx.length),
        };
    }
    else if (isVueSFCDescriptorFile(fileName)) {
        return {
            type: 'vue-descriptor',
            fileName: fileName.substring(0, fileName.length - suffixes.vueSFCDescriptor.length),
        };
    }
    else if (isVueTemplateASTFile(fileName)) {
        return {
            type: 'vue-template-ast',
            fileName: fileName.substring(0, fileName.length - suffixes.vueTemplateAST.length),
        };
    }
    else {
        return {
            type: 'other',
            fileName,
        };
    }
}
function toFileName(f) {
    switch (f.type) {
        case 'scheme':
            return `^/${f.scheme}${f.fileName}`;
        case 'vue-tsx':
            return `${f.fileName}${suffixes.vueTsx}`;
        case 'vue-jsx':
            return `${f.fileName}${suffixes.vueJsx}`;
        case 'vue-descriptor':
            return `${f.fileName}${suffixes.vueSFCDescriptor}`;
        case 'vue-template-ast':
            return `${f.fileName}${suffixes.vueTemplateAST}`;
        default:
            return f.fileName;
    }
}
function isFilesystemSchemeFile(fileName) {
    return fileName.startsWith('^/');
}
function isVueFile(fileName) {
    return fileName.endsWith('.vue');
}
function isVueTsxFile(fileName) {
    return fileName.endsWith('.vue' + suffixes.vueTsx);
}
function isVueJsxFile(fileName) {
    return fileName.endsWith('.vue' + suffixes.vueJsx);
}
function isVueSFCDescriptorFile(fileName) {
    return fileName.endsWith('.vue' + suffixes.vueSFCDescriptor);
}
function isVueTemplateASTFile(fileName) {
    return fileName.endsWith('.vue' + suffixes.vueTemplateAST);
}
function isVueVirtualFile(fileName) {
    return fileName.includes('.vue+vue');
}
function isVueRuntimeFile(fileName) {
    return fileName.endsWith(suffixes.vueRuntime);
}
function isProjectRuntimeFile(fileName) {
    return fileName.endsWith(suffixes.vueProjectRuntime);
}
const VUE_VIRTAL_FILE_RE = /\.vue(\+vue|\.ts|\.js)/;
function mayContainVirtualFileName(text) {
    return VUE_VIRTAL_FILE_RE.test(text);
}

const RAW_TEXT_TAGS = new Set(['style', 'iframe', 'script', 'noscript']);
const isRawTextContainer = (tagName) => RAW_TEXT_TAGS.has(tagName);
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = new Set(('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot').split(','));
const isHTMLTag = (tagName) => HTML_TAGS.has(tagName);
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = new Set(('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view').split(','));
const isSVGTag = (tagName) => SVG_TAGS.has(tagName);
const VOID_TAGS = new Set('area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'.split(','));
const isVoidTag = (tagName) => VOID_TAGS.has(tagName);
const HTML_TAG_NAME_TO_CLASS_NAME = {
    a: 'HTMLAnchorElement',
    area: 'HTMLAreaElement',
    audio: 'HTMLAudioElement',
    base: 'HTMLBaseElement',
    blockquote: 'HTMLQuoteElement',
    body: 'HTMLBodyElement',
    br: 'HTMLBRElement',
    button: 'HTMLButtonElement',
    canvas: 'HTMLCanvasElement',
    caption: 'HTMLTableCaptionElement',
    data: 'HTMLDataElement',
    datalist: 'HTMLDataListElement',
    details: 'HTMLDetailsElement',
    dialog: 'HTMLDialogElement',
    div: 'HTMLDivElement',
    dl: 'HTMLDListElement',
    embed: 'HTMLEmbedElement',
    fieldset: 'HTMLFieldSetElement',
    form: 'HTMLFormElement',
    h1: 'HTMLHeadingElement',
    head: 'HTMLHeadElement',
    hr: 'HTMLHRElement',
    html: 'HTMLHtmlElement',
    iframe: 'HTMLIFrameElement',
    img: 'HTMLImageElement',
    input: 'HTMLInputElement',
    label: 'HTMLLabelElement',
    legend: 'HTMLLegendElement',
    li: 'HTMLLIElement',
    link: 'HTMLLinkElement',
    main: 'HTMLMainElement',
    map: 'HTMLMapElement',
    menu: 'HTMLMenuElement',
    meta: 'HTMLMetaElement',
    meter: 'HTMLMeterElement',
    nav: 'HTMLNavElement',
    object: 'HTMLObjectElement',
    ol: 'HTMLOListElement',
    optgroup: 'HTMLOptGroupElement',
    option: 'HTMLOptionElement',
    output: 'HTMLOutputElement',
    p: 'HTMLParagraphElement',
    param: 'HTMLParamElement',
    picture: 'HTMLPictureElement',
    pre: 'HTMLPreElement',
    progress: 'HTMLProgressElement',
    q: 'HTMLQuoteElement',
    script: 'HTMLScriptElement',
    select: 'HTMLSelectElement',
    slot: 'HTMLSlotElement',
    source: 'HTMLSourceElement',
    span: 'HTMLSpanElement',
    style: 'HTMLStyleElement',
    table: 'HTMLTableElement',
    tbody: 'HTMLTableSectionElement',
    td: 'HTMLTableCellElement',
    template: 'HTMLTemplateElement',
    textarea: 'HTMLTextAreaElement',
    tfoot: 'HTMLTableSectionElement',
    th: 'HTMLTableCellElement',
    thead: 'HTMLTableSectionElement',
    title: 'HTMLTitleElement',
    tr: 'HTMLTableRowElement',
    track: 'HTMLTrackElement',
    ul: 'HTMLUListElement',
    video: 'HTMLVideoElement',
};
const SVG_TAG_NAME_TO_CLASS_NAME = {
    a: 'SVGAElement',
    altGlyph: 'SVGAltGlyphElement',
    altGlyphDef: 'SVGAltGlyphDefElement',
    altGlyphItem: 'SVGAltGlyphItemElement',
    animate: 'SVGAnimateElement',
    animateMotion: 'SVGAnimateMotionElement',
    animateTransform: 'SVGAnimateTransformElement',
    circle: 'SVGCircleElement',
    clipPath: 'SVGClipPathElement',
    defs: 'SVGDefsElement',
    desc: 'SVGDescElement',
    ellipse: 'SVGEllipseElement',
    feBlend: 'SVGFEBlendElement',
    feColorMatrix: 'SVGFEColorMatrixElement',
    feComponentTransfer: 'SVGFEComponentTransferElement',
    feComposite: 'SVGFECompositeElement',
    feConvolveMatrix: 'SVGFEConvolveMatrixElement',
    feDiffuseLighting: 'SVGFEDiffuseLightingElement',
    feDisplacementMap: 'SVGFEDisplacementMapElement',
    feDistantLight: 'SVGFEDistantLightElement',
    feDropShadow: 'SVGFEDropShadowElement',
    feFlood: 'SVGFEFloodElement',
    feFuncA: 'SVGFEFuncAElement',
    feFuncB: 'SVGFEFuncBElement',
    feFuncG: 'SVGFEFuncGElement',
    feFuncR: 'SVGFEFuncRElement',
    feGaussianBlur: 'SVGFEGaussianBlurElement',
    feImage: 'SVGFEImageElement',
    feMerge: 'SVGFEMergeElement',
    feMergeNode: 'SVGFEMergeNodeElement',
    feMorphology: 'SVGFEMorphologyElement',
    feOffset: 'SVGFEOffsetElement',
    fePointLight: 'SVGFEPointLightElement',
    feSpecularLighting: 'SVGFESpecularLightingElement',
    feSpotLight: 'SVGFESpotLightElement',
    feTile: 'SVGFETileElement',
    feTurbulence: 'SVGFETurbulenceElement',
    filter: 'SVGFilterElement',
    foreignObject: 'SVGForeignObjectElement',
    g: 'SVGGElement',
    hatch: 'SVGHatchElement',
    hatchpath: 'SVGHatchpathElement',
    image: 'SVGImageElement',
    line: 'SVGLineElement',
    linearGradient: 'SVGLinearGradientElement',
    marker: 'SVGMarkerElement',
    mask: 'SVGMaskElement',
    mesh: 'SVGMeshElement',
    meshgradient: 'SVGMeshGradientElement',
    meshpatch: 'SVGMeshPatchElement',
    meshrow: 'SVGMeshRowElement',
    metadata: 'SVGMetadataElement',
    mpath: 'SVGMPathElement',
    path: 'SVGPathElement',
    pattern: 'SVGPatternElement',
    polygon: 'SVGPolygonElement',
    polyline: 'SVGPolylineElement',
    radialGradient: 'SVGRadialGradientElement',
    rect: 'SVGRectElement',
    script: 'SVGScriptElement',
    set: 'SVGSetElement',
    stop: 'SVGStopElement',
    style: 'SVGStyleElement',
    svg: 'SVGSVGElement',
    switch: 'SVGSwitchElement',
    symbol: 'SVGSymbolElement',
    text: 'SVGTextElement',
    textPath: 'SVGTextPathElement',
    title: 'SVGTitleElement',
    tspan: 'SVGTSpanElement',
    unknown: 'SVGUnknownElement',
    use: 'SVGUseElement',
    view: 'SVGViewElement',
};
function getClassNameForTagName(tagName) {
    if (isSVGTag(tagName)) {
        return (SVG_TAG_NAME_TO_CLASS_NAME[tagName] ?? 'SVGElement');
    }
    if (isHTMLTag(tagName)) {
        return (HTML_TAG_NAME_TO_CLASS_NAME[tagName] ?? 'HTMLElement');
    }
    return 'Element';
}

function memoize(fn, getKey) {
    const microcache = new WeakMap();
    const fnx = ((...args) => {
        const key = getKey(args);
        if (microcache.has(key))
            return microcache.get(key);
        const value = fn(...args);
        microcache.set(key, value);
        return value;
    });
    fnx.evict = (...args) => microcache.delete(getKey(args));
    return fnx;
}
function memoizeByFirstArg(fn) {
    return memoize(fn, (args) => args[0]);
}

function isNumber(value) {
    return typeof value === 'number' && !Number.isNaN(value);
}

function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
function isPlainObject(obj) {
    return (isObject(obj) &&
        (Object.getPrototypeOf(obj) === null ||
            Object.getPrototypeOf(obj) === Object.prototype));
}

/**
 * A disposable scope to simplify resource cleanup, e.g.,
 * remove event listeners on component unmount.
 */
class DisposableScope {
    constructor() {
        this._cleanups = [];
    }
    /**
     * Call `dispose()` function on cleanup.
     */
    add(disposable) {
        const resource = typeof disposable === 'function' ? { dispose: disposable } : disposable;
        this._cleanups.push(() => resource.dispose());
        return this;
    }
    /**
     * Call `fn` and use returned value as cleanup function.
     */
    run(fn) {
        this.add(fn());
        return this;
    }
    /**
     * Unregister events on cleanup.
     */
    emitter(eventTarget) {
        const context = {
            on: (event, listener) => {
                this.run(() => {
                    eventTarget.addEventListener(event, listener);
                    return () => {
                        eventTarget.removeEventListener(event, listener);
                    };
                });
                return context;
            },
            end: () => this,
        };
        return context;
    }
    wrap(eventTarget) {
        return {
            on: (event, listener) => {
                this.run(() => {
                    eventTarget.on(event, listener);
                    return () => {
                        eventTarget.off(event, listener);
                    };
                });
            },
        };
    }
    dispose() {
        this._cleanups.forEach((fn) => fn());
        this._cleanups.length = 0;
    }
}

function effect(model, dependencies, fn, options = { immediate: true }) {
    const scope = new DisposableScope();
    const emitter = scope.emitter(model);
    const set = new Set(dependencies);
    emitter.on('@updated', (event) => {
        if (event.detail.some((property) => set.has(property))) {
            fn();
        }
    });
    if (options.immediate) {
        fn();
    }
    return scope;
}

class Event {
    constructor(name, detail) {
        this.type = name;
        this.detail = detail;
    }
}
class EventEmitter {
    constructor() {
        this._listeners = {};
    }
    addEventListener(event, listener) {
        const listeners = this._listeners[event];
        if (listeners != null) {
            listeners.add(listener);
        }
        else {
            this._listeners[event] = new Set([listener]);
        }
    }
    removeEventListener(event, listener) {
        this._listeners[event]?.delete(listener);
    }
    dispatchEvent(event, detail) {
        this._listeners[event]?.forEach((fn) => {
            try {
                void fn(new Event(event, detail));
            }
            catch { }
        });
    }
    dispose() {
        this._listeners = {};
    }
}

const methodsRE = /^(get|set|setAll|addEventListener|removeEventListener|dispatchEvent|dispose)$/;
function createModel(state) {
    const model = new ObservableState(state);
    const isProperty = (property) => typeof property === 'string' &&
        !methodsRE.test(property) &&
        !property.startsWith('_');
    return new Proxy(model, {
        get(target, property, receiver) {
            if (isProperty(property))
                return target.get(property);
            return Reflect.get(target, property, receiver);
        },
        set(target, property, value, receiver) {
            if (isProperty(property)) {
                target.set(property, value);
                return true;
            }
            return Reflect.set(target, property, value, receiver);
        },
        has(target, property) {
            return Reflect.has(isProperty(property) ? model._state : target, property);
        },
        ownKeys(_target) {
            return Reflect.ownKeys(model._state);
        },
        getOwnPropertyDescriptor(_target, property) {
            return Reflect.getOwnPropertyDescriptor(model._state, property);
        },
    });
}
function readonly(model) {
    return model;
}
class ObservableState extends EventEmitter {
    constructor(state) {
        super();
        this._state = state;
    }
    set(key, value) {
        this.setAll({ [key]: value });
    }
    setAll(state) {
        const changes = [];
        Object.entries(state).forEach((entry) => {
            const key = entry[0];
            const previousValue = this._state[key];
            const value = entry[1];
            if (previousValue === value)
                return; // Value did not change.
            this._state[key] = value;
            changes.push([key, { value, previousValue }]);
        });
        this.dispatchEvent('@updated', changes.map((change) => change[0]));
        for (const change of changes) {
            this.dispatchEvent(change[0], change[1]);
        }
    }
    get(key) {
        return this._state[key];
    }
}

/**
 * Lazily computed resource generated from models.
 */
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function computed(getter, ...dependencies) {
    return createComputedModel(dependencies, getter);
}
function createComputedModel(dependencies, getter) {
    let value;
    let isDirty = true;
    const state = createModel({
        get value() {
            if (isDirty) {
                isDirty = false;
                value = getter();
            }
            return value;
        },
    });
    dependencies.forEach((dependency) => {
        effect(dependency[0], dependency[1], () => {
            isDirty = true;
            state.dispatchEvent('@updated', ['value']);
            state.dispatchEvent('value', {
                get value() {
                    return state.value;
                },
                previousValue: value,
            });
        });
    });
    return readonly(state);
}

const serializer = {
    serialize(obj) {
        return JSON.stringify(obj, (_key, value) => {
            if (typeof value === 'bigint')
                return `${value.toString()}n`;
            return value;
        });
    },
    deserialize(text) {
        return JSON.parse(text, (_key, value) => {
            if (isString(value) && value.endsWith('n') && /^[0-9]+n$/.test(value)) {
                return BigInt(value.slice(0, -1));
            }
            return value;
        });
    },
};
function createEndpoint(channel) {
    let defaultSource;
    const sources = new Map();
    function create(id) {
        const emitter = new EventEmitter();
        if (defaultSource == null) {
            defaultSource = emitter;
        }
        sources.set(id, emitter);
        return {
            id,
            addEventListener: (event, listener) => emitter.addEventListener(event, listener),
            removeEventListener: (event, listener) => emitter.removeEventListener(event, listener),
            dispatchEvent: (_event, detail) => {
                channel.send(Buffer.from(serializer.serialize([id, detail])));
            },
            close: () => {
                emitter.dispatchEvent('closed', null);
                emitter.dispose();
                if (id != null)
                    sources.delete(id);
            },
            create: (id) => create(id ?? generateUUID()),
        };
    }
    channel.receive((data) => {
        const [id, message] = serializer.deserialize(data.toString('utf-8'));
        const source = sources.get(id) ?? defaultSource;
        source.dispatchEvent('message', message);
    });
    return create(generateUUID());
}

var MessageType;
(function (MessageType) {
    // Proxy Methods
    MessageType["get"] = "get";
    MessageType["set"] = "set";
    MessageType["apply"] = "apply";
    MessageType["construct"] = "construct";
    // Protocol Methods
    MessageType["ENDPOINT"] = "ENDPOINT";
    MessageType["RELEASE"] = "RELEASE";
    MessageType["RETURN"] = "RETURN";
})(MessageType || (MessageType = {}));

const release = Symbol('release');
const Symbols$1 = { release };

var ValueType;
(function (ValueType) {
    ValueType["RAW"] = "raw";
    ValueType["HANDLER"] = "handler";
})(ValueType || (ValueType = {}));

const EXPOSED = Symbol('RPC.exposed');
const THROWN = Symbol('RPC.thrown');
const Symbols = {
    exposed: EXPOSED,
    thrown: THROWN,
};
function isObjectOrFunction(value) {
    return isObject(value) || typeof value === 'function';
}
function isThrowable(value) {
    return isObjectOrFunction(value) && Symbols.thrown in value;
}
function createThrowable(value) {
    return { value, [Symbols.thrown]: true };
}
const throwHandler = {
    canHandle(value) {
        return isThrowable(value);
    },
    serialize({ value }) {
        return value instanceof Error
            ? {
                isError: true,
                value: {
                    name: value.name,
                    message: value.message,
                    stack: value.stack,
                },
            }
            : { isError: false, value };
    },
    deserialize(serializedValue) {
        if (serializedValue.isError) {
            throw Object.assign(new Error(serializedValue.value.message), serializedValue.value);
        }
        else {
            throw serializedValue.value;
        }
    },
};
function isExposed(obj) {
    return isObjectOrFunction(obj) && Symbols.exposed in obj;
}
let currentEndpoint = null;
function withEndpoint(endpoint, fn) {
    try {
        currentEndpoint = endpoint;
        return fn();
    }
    finally {
        currentEndpoint = null;
    }
}
function createExposed(value, endpoint) {
    const target = Object.assign(value, {
        [Symbols.exposed]: endpoint.id,
    });
    const scope = new DisposableScope();
    scope.emitter(endpoint).on('message', async (event) => {
        const message = event.detail;
        let returnValue;
        try {
            switch (message.type) {
                case MessageType.get:
                    returnValue = get(target, message.path);
                    break;
                case MessageType.set:
                    {
                        const { parent, property } = getParent(target, message.path);
                        parent[property] = fromValue(endpoint, message.value);
                        returnValue = true;
                    }
                    break;
                case MessageType.apply:
                    {
                        const { parent, property } = getParent(target, message.path);
                        returnValue = parent[property].apply(parent, message.argumentList.map((arg) => fromValue(endpoint, arg)));
                    }
                    break;
                case MessageType.construct:
                    {
                        const Constructor = get(target, message.path);
                        returnValue = createExposed(new Constructor(...message.argumentList.map((arg) => fromValue(endpoint, arg))), endpoint.create());
                    }
                    break;
            }
        }
        catch (error) {
            returnValue = createThrowable(error);
        }
        await Promise.resolve(returnValue)
            .catch((error) => createThrowable(error))
            .then((returnValue) => {
            endpoint.dispatchEvent('message', {
                id: message.id,
                type: MessageType.RETURN,
                value: toValue(endpoint, returnValue),
            });
            if (message.type === MessageType.RELEASE) {
                scope.dispose();
            }
        });
    });
    function get(target, path) {
        return path.reduce((obj, prop) => obj[prop], target);
    }
    function getParent(target, path) {
        if (path.length === 0) {
            return {
                parent: [target],
                property: '0',
            };
        }
        path = path.slice();
        const property = path.pop();
        return {
            parent: path.reduce((obj, prop) => obj[prop], target),
            property,
        };
    }
    return target;
}
const endpoints = new Map();
const proxyHandler = {
    canHandle(value) {
        return isExposed(value);
    },
    serialize(value) {
        return value[Symbols.exposed];
    },
    deserialize(key) {
        if (!endpoints.has(key)) {
            if (currentEndpoint == null) {
                throw new Error('Cannot deserialize proxy value without active endpoint');
            }
            const endpoint = currentEndpoint.create(key);
            endpoint.addEventListener('closed', () => {
                endpoints.delete(key);
            });
            endpoints.set(key, createEndpointProxy(endpoint, []));
        }
        return endpoints.get(key);
    },
};
const callbackHandler = {
    canHandle(value) {
        return typeof value === 'function' && !isExposed(value);
    },
    serialize(value) {
        if (currentEndpoint == null) {
            throw new Error('Cannot serialize function without active endpoint');
        }
        return proxyHandler.serialize(createExposed(value, currentEndpoint.create()));
    },
    deserialize(key) {
        return proxyHandler.deserialize(key);
    },
};
const Handlers = new Map([
    ['throw', throwHandler],
    ['proxy', proxyHandler],
    ['callback', callbackHandler],
]);
function toValue(endpoint, value) {
    return withEndpoint(endpoint, () => {
        for (const [name, handler] of Handlers.entries()) {
            if (handler.canHandle(value)) {
                return {
                    type: ValueType.HANDLER,
                    name,
                    value: handler.serialize(value),
                };
            }
        }
        return {
            type: ValueType.RAW,
            value,
        };
    });
}
function fromValue(endpoint, value) {
    return withEndpoint(endpoint, () => {
        switch (value.type) {
            case ValueType.RAW:
                return value.value;
            case ValueType.HANDLER: {
                const handler = Handlers.get(value.name);
                if (handler != null)
                    return handler.deserialize(value.value);
                return value.value;
            }
            default:
                throw new Error(`Unknown type: ${value.type}`);
        }
    });
}
function createEndpointProxy(endpoint, path, target = function () { }, boundArgs = []) {
    let isReleased = false;
    const proxy = new Proxy(target, {
        get(_, property) {
            throwIfProxyReleased(isReleased);
            if (property === Symbols$1.release) {
                return async () => {
                    isReleased = true;
                    try {
                        await sendRequest(endpoint, {
                            id: generateUUID(),
                            type: MessageType.RELEASE,
                            path: path.map((p) => p.toString()),
                        });
                    }
                    finally {
                        endpoint.close();
                    }
                };
            }
            else if (property === 'then') {
                if (path.length === 0)
                    return { then: () => proxy };
                const value = sendRequest(endpoint, {
                    id: generateUUID(),
                    type: MessageType.get,
                    path: path.map((p) => p.toString()),
                }).then((response) => fromValue(endpoint, response.value));
                return value.then.bind(value);
            }
            else {
                return createEndpointProxy(endpoint, [...path, property], target);
            }
        },
        set(_, property, value) {
            throwIfProxyReleased(isReleased);
            void sendRequest(endpoint, {
                id: generateUUID(),
                type: MessageType.set,
                path: [...path, property].map((p) => p.toString()),
                value: toValue(endpoint, value),
            });
            return true;
        },
        apply(_, _this, args) {
            throwIfProxyReleased(isReleased);
            const last = path[path.length - 1];
            if (last === 'bind') {
                return createEndpointProxy(endpoint, path.slice(0, -1), target, args.slice(1));
            }
            else {
                return sendRequest(endpoint, {
                    id: generateUUID(),
                    type: MessageType.apply,
                    path: path.map((p) => p.toString()),
                    argumentList: [...boundArgs, ...args].map((arg) => toValue(endpoint, arg)),
                }).then((response) => fromValue(endpoint, response.value));
            }
        },
        async construct(_, args) {
            throwIfProxyReleased(isReleased);
            const response = await sendRequest(endpoint, {
                id: generateUUID(),
                type: MessageType.construct,
                path: path.map((p) => p.toString()),
                argumentList: args.map((arg) => toValue(endpoint, arg)),
            });
            return fromValue(endpoint, response.value);
        },
    });
    return proxy;
}
async function sendRequest(endpoint, request) {
    const scope = new DisposableScope();
    try {
        return await new Promise((resolve, reject) => {
            scope
                .emitter(endpoint)
                .on('message', (event) => {
                const response = event.detail;
                if (response.id === request.id)
                    resolve(response);
            })
                .on('closed', () => {
                reject(new Error('Endpoint closed'));
            });
            endpoint.dispatchEvent('message', request);
        });
    }
    finally {
        scope.dispose();
    }
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error('Proxy has been released and is not useable');
    }
}

function create(endpoint) {
    return createEndpointProxy(endpoint, []);
}

function expose(target, endpoint) {
    createExposed(target, endpoint);
}

async function set(target, property, value) {
    const t = target;
    t[property] = value;
    while (true) {
        const local = value;
        const remote = await target[property];
        if (local === remote || JSON.stringify(local) === JSON.stringify(remote)) {
            break;
        }
    }
}

const index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createEndpoint: createEndpoint,
    create: create,
    expose: expose,
    set: set,
    Handlers: Handlers,
    Symbols: Symbols$1
});

const SetOps = {
    /**
     * a - b
     */
    difference: (a, b) => {
        const c = new Set(a);
        for (const item of b) {
            c.delete(item);
        }
        return c;
    },
    union: (a, b) => {
        const c = new Set(a);
        for (const item of b) {
            c.add(item);
        }
        return c;
    },
    intersetion: (a, b) => {
        const c = new Set();
        for (const item of a) {
            if (b.has(item))
                c.add(item);
        }
        return c;
    },
};

class LineColumnMapper {
    constructor(source) {
        this.offsets = [];
        const lines = source.split('\n');
        let offset = 0;
        for (const line of lines) {
            this.offsets.push(offset);
            offset += line.length + 1;
        }
    }
    positionAt(position) {
        const line = binarySearch(position, this.offsets, (a, b) => a - b, BinarySearchBias.GREATEST_LOWER_BOUND);
        const offset = this.offsets[line];
        invariant(offset != null, 'Invalid position.');
        return { line, column: position - offset };
    }
    offsetAt(line, column) {
        const offsets = this.offsets[line];
        invariant(offsets != null, 'Invalid position.');
        return offsets + column;
    }
}
class SourceTransformer {
    constructor(fileName, source) {
        this.code = '';
        this.line = 0;
        this.column = 0;
        this.source = source;
        this.sourceMap = {
            file: fileName,
            mappings: [],
            names: [],
            sources: [fileName],
            sourcesContent: [source],
        };
    }
    nextLine() {
        if (!this.code.endsWith('\n')) {
            this.append(`\n`);
        }
    }
    append(code, sourceMap) {
        const lines = code.split('\n');
        const lastLine = last(lines);
        this.code += code;
        let mappings = [];
        if (sourceMap != null) {
            const nameOffset = this.sourceMap.names.length;
            if (sourceMap.names != null)
                this.sourceMap.names.push(...sourceMap.names);
            mappings = getMappings(sourceMap).map((mapping) => mapping.map((segment) => {
                if (segment.length === 5) {
                    return [
                        segment[0],
                        0,
                        segment[2],
                        segment[3],
                        segment[4] + nameOffset,
                    ];
                }
                else if (segment.length === 4) {
                    return [segment[0], 0, segment[2], segment[3]];
                }
                return segment;
            }));
        }
        invariant(mappings.length <= lines.length, `Invalid source map: ${mappings.length} > ${lines.length}:\n${code},\n${JSON.stringify(mappings, null, 2)}`);
        const current = (this.sourceMap.mappings[this.line] =
            this.sourceMap.mappings[this.line] ?? []);
        if (mappings.length > 0) {
            current.push(...first(mappings).map((mapping) => {
                mapping[0] += this.column;
                return mapping;
            }));
        }
        if (lines.length === 1) {
            this.column += lastLine.length;
        }
        else {
            this.line += lines.length - 1;
            this.column = lastLine.length;
            this.sourceMap.mappings.push(...mappings.slice(1));
        }
        for (let i = this.sourceMap.mappings.length; i <= this.line; i++) {
            this.sourceMap.mappings.push([]);
        }
    }
    get sourceLineColumnMapper() {
        return (this._sourceLineColumnMapper ??
            (this._sourceLineColumnMapper = new LineColumnMapper(this.source)));
    }
    clone(start, end) {
        if (start >= end)
            return;
        const code = this.source.slice(start, end);
        if (code.length === 0)
            return;
        const mapper = this.sourceLineColumnMapper;
        const { line, column } = mapper.positionAt(start);
        const lines = code.split('\n');
        const sourceMap = {
            mappings: [[[0, 0, line, column]]],
        };
        for (let i = 1; i < lines.length; i++) {
            if (lines[i]?.length === 0)
                sourceMap.mappings.push([]);
            else
                sourceMap.mappings.push([[0, 0, line + i, 0]]);
        }
        this.append(code, sourceMap);
    }
    end() {
        return {
            code: this.code,
            map: this.sourceMap,
        };
    }
}
function getMappings(sourceMap) {
    return typeof sourceMap.mappings === 'string'
        ? sourcemapCodec.decode(sourceMap.mappings)
        : sourceMap.mappings;
}
function rebaseSourceMap(sourceMap, startPosition) {
    const mappings = getMappings(sourceMap);
    if (startPosition == null) {
        return {
            file: '',
            sources: [],
            sourcesContent: [],
            ...sourceMap,
            names: sourceMap.names ?? [],
            mappings,
        };
    }
    const line = startPosition.line - 1;
    const column = startPosition.column - 1;
    return {
        file: '',
        sources: [],
        sourcesContent: [],
        ...sourceMap,
        names: sourceMap.names ?? [],
        mappings: mappings.map((mapping) => mapping.map((segment) => {
            if (segment.length === 1)
                return segment;
            let originalLine = segment[2];
            let originalColumn = segment[3];
            if (originalLine === 0) {
                originalColumn += column;
            }
            originalLine += line;
            if (segment.length === 4) {
                return [segment[0], segment[1], originalLine, originalColumn];
            }
            return [
                segment[0],
                segment[1],
                originalLine,
                originalColumn,
                segment[4],
            ];
        })),
    };
}

class Telemetry {
    constructor(key, options, defaults) {
        this.user = {
            id: this.getUserId(),
        };
        this.isTelemetryEnabled = Telemetry.isTelemetryEnabled ??
            (process.env['VUEDX_TELEMETRY']?.toLowerCase() === 'on' ||
                process.env['VUEDX_TELEMETRY']?.toLowerCase() === 'true' ||
                false);
        Sentry__namespace.init({
            dsn: key,
            defaultIntegrations: false,
            release: options.release,
            environment: options.environment,
            sampleRate: options.tracesSampleRate,
        });
        this.defaults = {
            sessionId: Number(Math.random() * 1000000).toString(16),
            nodeVersion: process.version,
            os: OS.platform(),
            ...defaults,
        };
    }
    getUserId() {
        return '';
    }
    measure(name, duration) {
        console.debug(`[measure] ${name}: ${Math.trunc(duration)}ms`);
    }
    trace(name, description) {
        if (!this.isTelemetryEnabled)
            return () => { };
        const activeTransaction = Sentry__namespace.getCurrentHub()
            .getScope()
            ?.getTransaction();
        if (activeTransaction == null) {
            const transaction = Sentry__namespace.startTransaction({
                name,
                description,
            });
            Sentry__namespace.configureScope((s) => {
                const scope = s;
                scope.setSpan(transaction);
            });
            return () => {
                Sentry__namespace.captureMessage(`[trace] ${name}`, (s) => {
                    const scope = s;
                    scope.setSpan(transaction);
                    scope.setUser(this.user);
                    scope.setTags({ ...this.defaults });
                    scope.setLevel(Sentry__namespace.Severity.Info);
                    return scope;
                });
                transaction.finish();
                Sentry__namespace.configureScope((s) => {
                    const scope = s;
                    scope.setSpan(undefined);
                });
            };
        }
        else {
            const child = activeTransaction.startChild({
                op: name,
                description,
            });
            return () => {
                child.finish();
            };
        }
    }
    collect(key, value) {
        if (!this.isTelemetryEnabled)
            return;
        const tags = {};
        const allowed = new Set(['string', 'number', 'boolean']);
        Object.entries(value).forEach(([key, value]) => {
            if (allowed.has(typeof value)) {
                tags[`data_${key}`] = value;
            }
        });
        Sentry__namespace.captureEvent({
            message: `${key}`,
            level: Sentry__namespace.Severity.Info,
            user: this.user,
            tags: {
                ...this.defaults,
                ...tags,
            },
            extra: value,
        });
    }
    error(payload) {
        if (!this.isTelemetryEnabled)
            return;
        if (!(payload instanceof Error)) {
            payload = new Error(util.inspect(payload, true, 3, false));
        }
        void Sentry__namespace.captureException(payload, {
            level: Sentry__namespace.Severity.Fatal,
            user: this.user,
            tags: {
                ...this.defaults,
            },
        });
    }
    static get instance() {
        if (this._instance == null) {
            if (process.env['JEST_WORKER_ID'] != null) {
                this._instance = new Telemetry('', {
                    release: '',
                    environment: '',
                    tracesSampleRate: 0,
                });
            }
            else {
                throw new Error('Use "Telemetry.setup()" to instantiate telemetry client.');
            }
        }
        return this._instance;
    }
    static setup(key, packageName, packageVersion, tracesSampleRate, defaults) {
        this._instance = new Telemetry(key, {
            release: packageVersion,
            environment: 'production',
            tracesSampleRate,
        }, {
            ...defaults,
            packageName,
        });
    }
    static extend(defaults) {
        Object.assign(this.instance.defaults, defaults);
    }
    static setTelemetryEnabled(enabled) {
        this.isTelemetryEnabled = enabled;
        if (this._instance != null) {
            this._instance.isTelemetryEnabled = enabled;
        }
    }
}
Telemetry.isTelemetryEnabled = null;
async function tracePromise(event, promise) {
    const done = trace(event);
    try {
        return await promise;
    }
    catch (error) {
        collectError(error);
        throw error;
    }
    finally {
        done();
    }
}
function trace(event, description) {
    return Telemetry.instance.trace(event, description);
}
function collectError(error) {
    return Telemetry.instance.error(error);
}
function collect(key, value) {
    return Telemetry.instance.collect(key, value);
}

function startMeasure(name) {
    const start = perf_hooks.performance.now();
    perf_hooks.performance.mark(`${name}|start`);
    return () => {
        const duration = perf_hooks.performance.now() - start;
        perf_hooks.performance.mark(`${name}|end`);
        perf_hooks.performance.measure(name, `${name}|start`, `${name}|end`);
        Telemetry.instance.measure(name, duration);
    };
}
function measure(name) {
    return createMethodDecorator(({ target, propertyKey, next }) => {
        const id = name ?? `${target.constructor.name}#${propertyKey.toString()}`;
        return function (...args) {
            const start = perf_hooks.performance.now();
            try {
                return next.apply(this, args);
            }
            finally {
                const end = perf_hooks.performance.now();
                Telemetry.instance.measure(id, end - start);
            }
        };
    });
}
function createMethodDecorator(createMethod) {
    return (target, propertyKey, descriptor) => {
        const fn = descriptor?.value;
        if (typeof fn === 'function') {
            descriptor.value = createMethod({
                target,
                propertyKey,
                descriptor,
                next: fn,
            });
        }
        return descriptor;
    };
}

exports.BinarySearchBias = BinarySearchBias;
exports.DisposableScope = DisposableScope;
exports.Event = Event;
exports.EventEmitter = EventEmitter;
exports.HTML_TAG_NAME_TO_CLASS_NAME = HTML_TAG_NAME_TO_CLASS_NAME;
exports.RPC = index;
exports.SVG_TAG_NAME_TO_CLASS_NAME = SVG_TAG_NAME_TO_CLASS_NAME;
exports.SetOps = SetOps;
exports.SourceTransformer = SourceTransformer;
exports.Telemetry = Telemetry;
exports.binarySearch = binarySearch;
exports.binarySearchKey = binarySearchKey;
exports.cache = cache;
exports.cacheAll = cacheAll;
exports.cacheAllAsync = cacheAllAsync;
exports.cacheAsync = cacheAsync;
exports.camelCase = camelCase;
exports.camelize = camelize;
exports.capitalize = capitalize;
exports.chunk = chunk;
exports.clearMethodCache = clearMethodCache;
exports.collect = collect;
exports.collectError = collectError;
exports.computed = computed;
exports.concat = concat;
exports.createCache = createCache;
exports.createModel = createModel;
exports.createMultiKeyCache = createMultiKeyCache;
exports.createVersionedCache = createVersionedCache;
exports.createWeakMapCache = createWeakMapCache;
exports.debug = debug;
exports.effect = effect;
exports.findNextSibling = findNextSibling;
exports.findPrevSibling = findPrevSibling;
exports.first = first;
exports.flatten = flatten;
exports.generateUUID = generateUUID;
exports.getClassNameForTagName = getClassNameForTagName;
exports.getComponentName = getComponentName;
exports.getComponentNameAliases = getComponentNameAliases;
exports.getMappings = getMappings;
exports.getRelativeFileName = getRelativeFileName;
exports.hyphenate = hyphenate;
exports.invariant = invariant;
exports.isArray = isArray;
exports.isCamelCase = isCamelCase;
exports.isFilesystemSchemeFile = isFilesystemSchemeFile;
exports.isHTMLTag = isHTMLTag;
exports.isKebabCase = isKebabCase;
exports.isNotNull = isNotNull;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPascalCase = isPascalCase;
exports.isPlainObject = isPlainObject;
exports.isProjectRuntimeFile = isProjectRuntimeFile;
exports.isRawTextContainer = isRawTextContainer;
exports.isSVGTag = isSVGTag;
exports.isString = isString;
exports.isVoidTag = isVoidTag;
exports.isVueFile = isVueFile;
exports.isVueJsxFile = isVueJsxFile;
exports.isVueRuntimeFile = isVueRuntimeFile;
exports.isVueSFCDescriptorFile = isVueSFCDescriptorFile;
exports.isVueTemplateASTFile = isVueTemplateASTFile;
exports.isVueTsxFile = isVueTsxFile;
exports.isVueVirtualFile = isVueVirtualFile;
exports.kebabCase = kebabCase;
exports.last = last;
exports.lcfirst = lcfirst;
exports.mayContainVirtualFileName = mayContainVirtualFileName;
exports.measure = measure;
exports.memoize = memoize;
exports.memoizeByFirstArg = memoizeByFirstArg;
exports.parseFileName = parseFileName;
exports.pascalCase = pascalCase;
exports.readonly = readonly;
exports.rebaseSourceMap = rebaseSourceMap;
exports.setDebugging = setDebugging;
exports.startMeasure = startMeasure;
exports.toFileName = toFileName;
exports.toPlatformPath = toPlatformPath;
exports.toPosixPath = toPosixPath;
exports.toWindowsPath = toWindowsPath;
exports.trace = trace;
exports.tracePromise = tracePromise;
exports.trimIndent = trimIndent;
exports.ucfirst = ucfirst;
exports.uncapitalize = uncapitalize;
exports.versioned = versioned;
exports.versionedAsync = versionedAsync;
//# sourceMappingURL=index.cjs.map
