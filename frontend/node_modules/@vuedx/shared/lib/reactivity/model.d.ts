import { EventEmitter } from './emitter';
export declare type KeyOf<T> = T extends object ? string & keyof T : never;
export declare type ModelEvents<T extends object> = {
    [K in KeyOf<T> | '@updated']: K extends '@updated' ? Array<KeyOf<T>> : K extends KeyOf<T> ? {
        value: T[K];
        previousValue: T[K];
    } : never;
};
interface Readable<T extends object> {
    get<K extends KeyOf<T>>(key: K): T[K];
}
interface Writable<T extends object> extends Readable<T> {
    set<K extends KeyOf<T>>(key: K, value: T[K]): void;
    setAll(state: Partial<T>): void;
}
declare type Immutable<T> = T extends Array<infer I> ? ReadonlyArray<Immutable<I>> : T extends Set<infer I> ? ReadonlySet<Immutable<I>> : T extends Map<infer K, infer V> ? ReadonlyMap<K, Immutable<V>> : T extends Date | Function | RegExp ? T : T extends object ? {
    readonly [K in keyof T]: Immutable<T[K]>;
} : T;
export declare type Model<T extends object> = T & Writable<T> & EventEmitter<ModelEvents<T>>;
export declare type ReadonlyModel<T extends object> = Immutable<T> & Readable<T> & EventEmitter<ModelEvents<T>>;
export declare function createModel<T extends object>(state: T): Model<T>;
export declare function readonly<T extends object>(model: Model<T>): ReadonlyModel<T>;
export {};
//# sourceMappingURL=model.d.ts.map