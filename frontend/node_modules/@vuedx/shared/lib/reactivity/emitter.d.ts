import type { Disposable } from './disposable';
export declare type EventListener<T> = (event: Event<T>) => void | Promise<void>;
export declare class Event<T> {
    readonly type: string;
    readonly detail: T;
    constructor(name: string, detail: T);
}
export declare type EventsOf<T extends EventEmitter<unknown>> = T extends EventEmitter<infer E> ? never extends E ? T['__type_helper_'] : E : never;
export interface EventSource<T> {
    addEventListener<E extends string & keyof T>(event: E, listener: EventListener<T[E]>): void;
    removeEventListener<E extends string & keyof T>(event: E, listener: EventListener<T[E]>): void;
    __type_helper_?: T;
}
export interface EventProducer<T> {
    dispatchEvent<E extends string & keyof T>(event: E, detail: T[E]): void;
}
export declare class EventEmitter<T> implements Disposable, EventSource<T>, EventProducer<T> {
    private _listeners;
    __type_helper_?: T;
    addEventListener<E extends string & keyof T>(event: E, listener: EventListener<T[E]>): void;
    removeEventListener<E extends string & keyof T>(event: E, listener: EventListener<T[E]>): void;
    dispatchEvent<E extends string & keyof T>(event: E, detail: T[E]): void;
    dispose(): void;
}
//# sourceMappingURL=emitter.d.ts.map