import type { Disposable } from './disposable';
import type { EventEmitter, EventListener, EventSource } from './emitter';
import type { Model, ModelEvents } from './model';
interface FromEvents<T> {
    end(): DisposableScope;
    on<E extends string & keyof T>(event: E, listener: EventListener<T[E]>): FromEvents<T>;
}
interface EventEmitterLike {
    on(event: string, callback: (...args: unknown[]) => unknown): unknown;
    off(event: string, callback: unknown): unknown;
}
declare type EmitterScope<T> = T extends Model<infer S> ? FromEvents<ModelEvents<S>> : T extends EventEmitter<infer E> ? never extends E ? FromEvents<Required<T>['__type_helper_']> : FromEvents<E> : T extends EventSource<infer E> ? never extends E ? FromEvents<Required<T>['__type_helper_']> : FromEvents<E> : never;
/**
 * A disposable scope to simplify resource cleanup, e.g.,
 * remove event listeners on component unmount.
 */
export declare class DisposableScope implements Disposable {
    private readonly _cleanups;
    /**
     * Call `dispose()` function on cleanup.
     */
    add(disposable: Disposable | Disposable['dispose']): DisposableScope;
    /**
     * Call `fn` and use returned value as cleanup function.
     */
    run(fn: () => Disposable | Disposable['dispose']): DisposableScope;
    /**
     * Unregister events on cleanup.
     */
    emitter<E extends EventEmitter<any> | EventSource<any>>(eventTarget: E): EmitterScope<E>;
    wrap<E extends EventEmitterLike>(eventTarget: E): Pick<E, 'on'>;
    dispose(): void;
}
export {};
//# sourceMappingURL=cleanup.d.ts.map