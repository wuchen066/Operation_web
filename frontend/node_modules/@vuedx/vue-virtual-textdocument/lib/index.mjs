import { TextDocument } from 'vscode-languageserver-textdocument';
export { TextDocument } from 'vscode-languageserver-textdocument';
import { compileWithDecodedSourceMap } from '@vuedx/compiler-tsx';
import { createCache, startMeasure, isNotNull, binarySearch, BinarySearchBias, invariant } from '@vuedx/shared';
import { encode } from 'sourcemap-codec';

class VueSFCDocument {
    constructor(original, options) {
        this._snapshot = null;
        this._original = original;
        this.options = {
            isTypeScript: true,
            internalIdentifierPrefix: '__VueDX_',
            runtimeModuleName: 'vue',
            typeCheckModuleName: 'vuedx~runtime',
            ...options,
            cache: createCache(15), // More than 15 blocks in SFC is not common.
        };
        this.originalFileName = this.options.fileName;
        this.generatedFileName = `${this.options.fileName}${this.options.isTypeScript ? '.tsx' : '.jsx'}`;
    }
    /** @deprecated used by tsserver */
    get text() {
        return this.original.getText();
    }
    /** @deprecated used by tsserver */
    getLineAndCharacterOfPosition(position) {
        return this.original.positionAt(position);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    getSourceFile(fileName = this.fileName) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const ctx = this;
        return {
            fileName,
            get text() {
                return ctx.text;
            },
            get lineMap() {
                return ctx.lineMap;
            },
            set lineMap(value) {
                ctx.lineMap = value;
            },
            getLineAndCharacterOfPosition: (position) => ctx.getLineAndCharacterOfPosition(position),
        };
    }
    get fileName() {
        return this.originalFileName;
    }
    get descriptor() {
        return this._compile().descriptor;
    }
    get errors() {
        return this._compile().errors;
    }
    get templateAST() {
        return this._compile().template;
    }
    get original() {
        return this._original;
    }
    get generated() {
        return this._compile().document;
    }
    get blocks() {
        return this._compile().blocks;
    }
    get snapshot() {
        return this._compile();
    }
    get map() {
        const map = this._compile().map;
        return JSON.stringify({
            ...map,
            version: 3,
            mappings: encode(map.mappings),
        });
    }
    getText(range) {
        return this.generated.getText(range);
    }
    positionAt(offset) {
        return this.generated.positionAt(offset);
    }
    offsetAt(position) {
        return this.generated.offsetAt(position);
    }
    get version() {
        return this.original.version; // use original version as generated code might be out of date
    }
    get lineCount() {
        return this.generated.lineCount;
    }
    get uri() {
        return `file://${this.originalFileName}`;
    }
    get languageId() {
        return this.options.isTypeScript ? 'typescript' : 'javascript';
    }
    getBlockAt(offset) {
        const block = this.blocks.find((block) => block.loc.start.offset <= offset && offset <= block.loc.end.offset);
        return block ?? null;
    }
    _compile() {
        if (this._snapshot?.document.version !== this.original.version) {
            const previous = this._snapshot;
            try {
                const endCompileMeasure = startMeasure('VueSFCDocument.compile');
                const result = compileWithDecodedSourceMap(this.original.getText(), this.options);
                const mappings = memoize(() => result.map.mappings.flatMap((mappings, line) => mappings.map((mapping) => {
                    const m = [
                        line,
                        mapping[0],
                        mapping[2] ?? -1,
                        mapping[3] ?? -1,
                        result.map.names[mapping[4] ?? -1],
                    ];
                    return m;
                })));
                const descriptor = result.descriptor;
                const mappingsByOriginalOrder = memoize(() => mappings().slice().sort(compareOriginal));
                const mappingsByGeneratedOrder = memoize(() => mappings().slice().sort(compareGenerated));
                const blocks = memoize(() => {
                    return [
                        descriptor.scriptSetup,
                        descriptor.script,
                        descriptor.template,
                        ...descriptor.styles,
                        ...descriptor.customBlocks,
                    ]
                        .filter(isNotNull)
                        .sort((a, b) => a.loc.start.offset - b.loc.start.offset);
                });
                this._snapshot = {
                    ...result,
                    get mappingsByOriginalOrder() {
                        return mappingsByOriginalOrder();
                    },
                    get mappingsByGeneratedOrder() {
                        return mappingsByGeneratedOrder();
                    },
                    get blocks() {
                        return blocks();
                    },
                    document: TextDocument.create(`file://${this.generatedFileName}`, this.options.isTypeScript ? 'typescript' : 'javascript', this.original.version, result.code),
                };
                endCompileMeasure();
            }
            catch (e) {
                console.error('Failed to compile', e);
                if (previous != null) {
                    this._snapshot = {
                        ...previous,
                        errors: [...previous.errors, e],
                        document: TextDocument.update(previous.document, [], this.original.version),
                    };
                }
                else {
                    this._snapshot = {
                        descriptor: {
                            script: null,
                            scriptSetup: null,
                            template: null,
                            styles: [],
                            customBlocks: [],
                        },
                        errors: [e],
                        blocks: [],
                        code: '',
                        map: {
                            file: '',
                            mappings: [],
                            names: [],
                            sources: [],
                            sourcesContent: [],
                        },
                        document: TextDocument.create(`file://${this.generatedFileName}`, this.options.isTypeScript ? 'typescript' : 'javascript', this.original.version, ''),
                        mappingsByGeneratedOrder: [],
                        mappingsByOriginalOrder: [],
                    };
                }
            }
        }
        return this._snapshot;
    }
    findMapping(positionType, position, searchBias = BinarySearchBias.GREATEST_LOWER_BOUND) {
        const snapshot = this._snapshot ?? this._compile();
        const needle = [];
        if (positionType === 'original') {
            needle[2 /* MappingKey.OriginalLine */] = position.line;
            needle[3 /* MappingKey.OriginalColumn */] = position.character;
        }
        else {
            needle[0 /* MappingKey.GeneratedLine */] = position.line;
            needle[1 /* MappingKey.GeneratedColumn */] = position.character;
        }
        const index = binarySearch(needle, positionType === 'original'
            ? snapshot.mappingsByOriginalOrder
            : snapshot.mappingsByGeneratedOrder, positionType === 'original' ? compareOriginal : compareGenerated, searchBias);
        if (index < 0)
            return null;
        return ((positionType === 'original'
            ? snapshot.mappingsByOriginalOrder[index]
            : snapshot.mappingsByGeneratedOrder[index]) ?? null);
    }
    originalPositionFor(position) {
        const offset = this.generated.offsetAt(position);
        const originalOffset = this.originalOffsetAt(offset);
        if (originalOffset == null)
            return null;
        return this.original.positionAt(originalOffset);
    }
    originalOffsetAt(offset) {
        const span = this.findOriginalTextSpan({ start: offset, length: 1 });
        if (span == null)
            return null;
        return span.start;
    }
    findOriginalTextSpan(spanInGeneratedText) {
        const position = this.generated.positionAt(spanInGeneratedText.start);
        const low = this.findMapping('generated', position, BinarySearchBias.GREATEST_LOWER_BOUND);
        if (low == null || low[2 /* MappingKey.OriginalLine */] < 0)
            return null;
        const result = this._processMappingUsingMeta('generated', spanInGeneratedText, low);
        if (result != null)
            return result;
        const generatedStart = this.generated.offsetAt({
            line: low[0 /* MappingKey.GeneratedLine */],
            character: low[1 /* MappingKey.GeneratedColumn */],
        });
        const originalStart = this.original.offsetAt({
            line: low[2 /* MappingKey.OriginalLine */],
            character: low[3 /* MappingKey.OriginalColumn */],
        });
        // prefix match
        const originalString = this.original.getText().slice(originalStart);
        const generatedString = this.generated.getText().slice(generatedStart);
        const prefixLength = findCommonPrefixLength(originalString, generatedString);
        if (generatedStart + prefixLength < spanInGeneratedText.start)
            return null; // no mapping
        // TODO: original position should be contained in a block
        return {
            start: originalStart + Math.abs(generatedStart - spanInGeneratedText.start),
            length: Math.min(prefixLength, spanInGeneratedText.length),
        };
    }
    findGeneratedTextSpan(spanInOriginalText) {
        const block = this.getBlockAt(spanInOriginalText.start);
        if (block == null)
            return null;
        const isZeroWidth = spanInOriginalText.length === 0;
        const start = this.generatedOffsetAt(spanInOriginalText.start, isZeroWidth);
        if (start == null)
            return null;
        if (isZeroWidth)
            return { start, length: 0 };
        const end = this.generatedOffsetAt(spanInOriginalText.start + spanInOriginalText.length, true) ?? start;
        return { start: Math.min(start, end), length: Math.abs(end - start) };
    }
    _processMappingUsingMeta(kind, span, mapping) {
        const name = mapping[4 /* MappingKey.Name */];
        if (name == null)
            return null;
        const result = /^<<(P|S|T)>>(\d+)(?:\|(\d+))?$/.exec(name);
        if (result != null) {
            switch (result[1]) {
                case 'P':
                    {
                        invariant(result[2]);
                        const generatedLength = parseInt(result[2], 10);
                        invariant(Number.isInteger(generatedLength));
                        const original = this.original.offsetAt({
                            line: mapping[2 /* MappingKey.OriginalLine */],
                            character: mapping[3 /* MappingKey.OriginalColumn */],
                        });
                        const generated = this.generated.offsetAt({
                            line: mapping[0 /* MappingKey.GeneratedLine */],
                            character: mapping[1 /* MappingKey.GeneratedColumn */],
                        });
                        if (kind === 'generated') {
                            // if span is in generated range
                            if (contains({ start: generated, length: generatedLength }, span)) {
                                const skipLength = Math.abs(span.start - generated);
                                const length = Math.min(generatedLength - skipLength, span.length);
                                return {
                                    start: original + skipLength,
                                    length,
                                    mapping: 'P',
                                };
                            }
                        }
                        else {
                            if (contains({ start: original, length: generatedLength }, span)) {
                                const skipLength = Math.abs(span.start - original);
                                const length = Math.min(generatedLength - skipLength, span.length);
                                return {
                                    start: generated + skipLength,
                                    length,
                                    mapping: 'P',
                                };
                            }
                        }
                    }
                    break;
                case 'S':
                    {
                        invariant(result[2] != null && result[3] != null);
                        const originalLength = parseInt(result[2], 10);
                        const generatedLength = parseInt(result[3], 10);
                        invariant(Number.isInteger(originalLength));
                        invariant(Number.isInteger(generatedLength));
                        invariant(originalLength >= generatedLength);
                        const diffLength = Math.abs(generatedLength - originalLength);
                        const original = this.original.offsetAt({
                            line: mapping[2 /* MappingKey.OriginalLine */],
                            character: mapping[3 /* MappingKey.OriginalColumn */],
                        });
                        const generated = this.generated.offsetAt({
                            line: mapping[0 /* MappingKey.GeneratedLine */],
                            character: mapping[1 /* MappingKey.GeneratedColumn */],
                        });
                        if (kind === 'generated') {
                            if (contains({ start: generated, length: generatedLength }, span)) {
                                const skipLength = Math.abs(span.start - generated);
                                if (skipLength <= diffLength) {
                                    return {
                                        start: original,
                                        length: originalLength,
                                        mapping: 'S',
                                    };
                                }
                                const length = Math.min(originalLength - (skipLength - diffLength), span.length);
                                return {
                                    start: original + skipLength,
                                    length,
                                    mapping: 'S',
                                };
                            }
                            else {
                                if (contains({ start: original, length: originalLength }, span)) {
                                    const skipLength = Math.abs(span.start - original);
                                    const length = Math.min(originalLength - skipLength, span.length);
                                    return {
                                        start: generated + diffLength + skipLength,
                                        length,
                                        mapping: 'S',
                                    };
                                }
                            }
                        }
                    }
                    break;
                case 'T':
                    {
                        invariant(result[2] != null && result[3] != null);
                        const originalLength = parseInt(result[2], 10);
                        const generatedLength = parseInt(result[3], 10);
                        invariant(Number.isInteger(originalLength));
                        invariant(Number.isInteger(generatedLength));
                        const original = this.original.offsetAt({
                            line: mapping[2 /* MappingKey.OriginalLine */],
                            character: mapping[3 /* MappingKey.OriginalColumn */],
                        });
                        const generated = this.generated.offsetAt({
                            line: mapping[0 /* MappingKey.GeneratedLine */],
                            character: mapping[1 /* MappingKey.GeneratedColumn */],
                        });
                        if (kind === 'generated') {
                            if (contains({ start: generated, length: generatedLength }, span)) {
                                return {
                                    start: original,
                                    length: originalLength,
                                    mapping: 'T',
                                };
                            }
                        }
                        else {
                            if (contains({ start: original, length: originalLength }, span)) {
                                return {
                                    start: generated,
                                    length: generatedLength,
                                    mapping: 'T',
                                };
                            }
                        }
                    }
                    break;
            }
        }
        return null;
    }
    generatedPositionFor(position) {
        const offset = this.original.offsetAt(position);
        const generatedOffset = this.generatedOffsetAt(offset);
        if (generatedOffset == null)
            return null;
        return this.generated.positionAt(generatedOffset);
    }
    generatedOffsetAt(offset, isZeroWidth = false) {
        const position = this.original.positionAt(offset);
        const low = this.findMapping('original', position, BinarySearchBias.GREATEST_LOWER_BOUND);
        if (low == null)
            return null;
        const result = this._processMappingUsingMeta('original', { start: offset, length: 0 }, low);
        if (result != null) {
            return isZeroWidth && result.mapping === 'T'
                ? result.start + result.length
                : result.start;
        }
        const originalStart = this.original.offsetAt({
            line: low[2 /* MappingKey.OriginalLine */],
            character: low[3 /* MappingKey.OriginalColumn */],
        });
        const start = this.generated.offsetAt({
            line: low[0 /* MappingKey.GeneratedLine */],
            character: low[1 /* MappingKey.GeneratedColumn */],
        }) +
            // source mappings are prefix based, so we assume the original
            // and generated text have the same prefix.
            Math.abs(originalStart - offset);
        return start;
    }
    static create(fileName, content, options, version = 0) {
        return new VueSFCDocument(TextDocument.create(`file://${fileName}`, 'vue', version, content), { ...options, fileName });
    }
    update(changes, version) {
        this._original = TextDocument.update(this._original, changes, version);
        this.lineMap = undefined;
    }
}
function compareOriginal(a, b) {
    const comparison = a[2 /* MappingKey.OriginalLine */] - b[2 /* MappingKey.OriginalLine */];
    return comparison !== 0
        ? comparison
        : a[3 /* MappingKey.OriginalColumn */] - b[3 /* MappingKey.OriginalColumn */];
}
function compareGenerated(a, b) {
    const comparison = a[0 /* MappingKey.GeneratedLine */] - b[0 /* MappingKey.GeneratedLine */];
    return comparison !== 0
        ? comparison
        : a[1 /* MappingKey.GeneratedColumn */] - b[1 /* MappingKey.GeneratedColumn */];
}
function memoize(fn) {
    let value;
    return () => {
        if (value === undefined)
            value = fn();
        return value;
    };
}
function contains(haystack, needle) {
    return (haystack.start <= needle.start &&
        haystack.start + haystack.length >= needle.start + needle.length);
}
// Binary search.
// Performance analysis: http://neil.fraser.name/news/2007/10/09/
function findCommonPrefixLength(a, b) {
    if (a.length === 0 || b.length === 0 || a.charCodeAt(0) !== b.charCodeAt(0))
        return 0;
    let low = 0;
    let high = Math.min(a.length, b.length);
    let mid = high;
    let start = 0;
    while (low < mid) {
        if (a.slice(start, mid) === b.slice(start, mid)) {
            low = mid;
            start = low;
        }
        else {
            high = mid;
        }
        mid = Math.floor((high - low) / 2 + low);
    }
    if (isSurrogatePair(a.charCodeAt(mid - 1)))
        mid--;
    return mid;
}
function isSurrogatePair(ch) {
    return ch >= 0xd800 && ch <= 0xdbff;
}

export { VueSFCDocument };
//# sourceMappingURL=index.mjs.map
