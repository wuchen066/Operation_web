'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const compilerCore = require('@vue/compiler-core/dist/compiler-core.cjs.js');
const shared = require('@vuedx/shared');
const templateAstTypes = require('@vuedx/template-ast-types');
const compilerSfc = require('@vuedx/compiler-sfc');
const transforms = require('@vuedx/transforms');
const sourcemapCodec = require('sourcemap-codec');
const parser = require('@babel/parser');
const types = require('@babel/types');

function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(Object.assign({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function createLoc(loc, offset, length) {
    if (loc == null)
        return;
    length = length ?? loc.source.length - offset;
    const source = loc.source.slice(offset, offset + length);
    const start = advancePositionWithClone(loc.start, loc.source.slice(0, offset));
    const end = advancePositionWithClone(start, source);
    return { source, start, end };
}
function sliceLoc(loc, start, end) {
    if (loc == null)
        return;
    if (end == null) {
        end = loc.source.length;
    }
    else if (end < 0) {
        end = loc.source.length + end;
    }
    if (start < 0) {
        start = loc.source.length + start;
    }
    return createLoc(loc, start, Math.max(0, end - start));
}

function getRuntimeFn(prefix, name) {
    return `${prefix}.internal.${name}`;
}

const annotations = {
    /**
     * Mark range to ignore diagnostics.
     */
    diagnosticsIgnore: {
        start: '/*<vuedx:diagnosticsIgnore>*/',
        end: '/*</vuedx:diagnosticsIgnore>*/',
    },
    /**
     * Used to define range for hoists or defining global variables.
     */
    templateGlobals: {
        start: '/*<vuedx:templateGlobals>*/',
        end: '/*</vuedx:templateGlobals>*/',
    },
    /**
     * Used to define range for return from setup() function, generated from <script setup>
     */
    setupGlobals: {
        start: '/*<vuedx:setupGlobals>*/',
        end: '/*</vuedx:setupGlobals>*/',
    },
    /**
     * Missing expression in v-if or v-else-if.
     */
    missingExpression: '/*<vuedx:missingExpression>*/',
    /**
     * Used in every JSX element to provide position for attribute completion.
     */
    tsxCompletions: '/*<vuedx:tsx-completions-target/>*/',
    /**
     * Used once in render function to get completions from context.
     */
    tsCompletions: '/*<vuedx:ts-completions-target/>*/',
};
let ctx;
function generate(root, options) {
    ctx = createGenerateContext(options);
    genRootNode(root);
    genSlotTypes(root);
    genAttrTypes(root);
    return ctx.getOutput();
}
function genNode(node) {
    switch (node.type) {
        case templateAstTypes.NodeTypes.ROOT:
            return genRootNode(node);
        case templateAstTypes.NodeTypes.ELEMENT: {
            const el = node;
            switch (el.tagType) {
                case templateAstTypes.ElementTypes.ELEMENT:
                    return genElementNode(node);
                case templateAstTypes.ElementTypes.COMPONENT:
                    return genComponentNode(node);
                case templateAstTypes.ElementTypes.SLOT:
                    return genSlotOutletNode(node);
                case templateAstTypes.ElementTypes.TEMPLATE:
                    return genTemplateNode(node);
                default:
                    throw new Error(`Unexpected element type: ${node.type}`);
            }
        }
        case templateAstTypes.NodeTypes.SIMPLE_EXPRESSION:
        case templateAstTypes.NodeTypes.COMPOUND_EXPRESSION:
            return genExpressionNode(node);
        case templateAstTypes.NodeTypes.TEXT:
            return genTextNode(node);
        case templateAstTypes.NodeTypes.INTERPOLATION:
            return genInterpolationNode(node);
        case templateAstTypes.NodeTypes.COMMENT:
            return genCommentNode(node);
        case templateAstTypes.NodeTypes.FOR:
            return genForNode(node);
        case templateAstTypes.NodeTypes.IF:
            return genIfNode(node);
        default:
            throw new Error(`Unsupported node type: ${node.type}`);
    }
}
function indent(fn) {
    ctx.indent();
    fn();
    ctx.deindent();
}
function writeLine(code) {
    ctx.write(code).newLine();
}
function genRootNode(node) {
    genKnownIdentifierGetters(node.scope.globals);
    writeLine(`function ${ctx.internalIdentifierPrefix}render() {`);
    indent(() => {
        node.scope.getBinding('$slots'); // forces to declare $slots
        genGlobalDeclarations(node);
        genNodeHoists({ hoists: ctx.scope.getRootScope() });
        writeLine('return (');
        indent(() => {
            writeLine('<>');
            indent(() => genChildren(node));
            writeLine('</>');
        });
        writeLine(')');
    });
    writeLine('}');
    writeLine(`${ctx.internalIdentifierPrefix}render();`);
}
function genKnownIdentifierGetters(ids) {
    ids = Array.from(new Set([...ids, ...ctx.used.components, ...ctx.used.directives]));
    if (!ids.some((id) => ctx.identifiers.has(id)))
        return;
    wrap(annotations.templateGlobals.start, annotations.templateGlobals.end, () => {
        ctx.newLine();
        ids.forEach((id) => {
            const knownId = ctx.identifiers.get(id);
            if (knownId == null)
                return;
            if (!['ref', 'maybeRef', 'externalMaybeRef', 'externalRef'].includes(knownId.kind))
                return;
            writeLine(`const ${ctx.internalIdentifierPrefix}_get_identifier_${id} = () => ${getRuntimeFn(ctx.typeIdentifier, 'unref')}(${id});`);
        });
    });
    ctx.newLine();
}
function genDirectiveChecks(el) {
    const directives = el.props.filter(templateAstTypes.isDirectiveNode).filter((directive) => {
        return !['on', 'bind', 'text', 'html', 'model'].includes(directive.name);
    });
    if (directives.length === 0)
        return;
    wrap('{(() => {', '})()}', () => indent(() => {
        ctx.newLine();
        directives.forEach((directive) => {
            ctx.write(`${getRuntimeFn(ctx.typeIdentifier, 'checkDirective')}(`);
            ctx.write(directive.resolvedName ?? asConst(JSON.stringify(directive.name)), createLoc(directive.loc, 0, 2 + directive.name.length), true);
            ctx.write(', ');
            if (templateAstTypes.isComponentNode(el)) {
                ctx.write(el.resolvedName ?? asConst(JSON.stringify(el.tag)), el.tagLoc);
            }
            else {
                ctx.write(asConst(JSON.stringify(el.tag)), el.tagLoc);
            }
            ctx.write(', ');
            if (directive.arg != null)
                genExpressionNode(directive.arg);
            else
                ctx.write('undefined');
            ctx.write(', ');
            if (directive.exp != null)
                genExpressionNode(directive.exp);
            else
                ctx.write('undefined');
            ctx.write(', ');
            wrap('{ ', ' }', () => {
                directive.modifiers.forEach((modifier, index) => {
                    if (modifier.trim() === '')
                        return;
                    ctx.write(`${JSON.stringify(modifier)}`, directive.modifierLocs[index], true);
                    ctx.write(': true, ');
                });
            });
            ctx.write(');');
            ctx.newLine();
        });
    }));
    ctx.newLine(); // rendered before element or component, so add a new line
}
function genGlobalDeclarations(node) {
    if (node.scope.globals.length === 0)
        return;
    writeLine(annotations.templateGlobals.start);
    node.scope.globals.forEach((id) => {
        const knownId = ctx.identifiers.get(id);
        if (knownId != null) {
            if (['ref', 'maybeRef', 'externalMaybeRef', 'externalRef'].includes(knownId.kind)) {
                writeLine(`let ${id} = ${ctx.internalIdentifierPrefix}_get_identifier_${id}();`);
            }
        }
        else {
            writeLine(`let ${id} = ${ctx.contextIdentifier}.${id}`);
        }
    });
    writeLine(annotations.templateGlobals.end);
}
function genNodeHoists(node) {
    if (node.hoists.length === 0)
        return;
    writeLine(annotations.templateGlobals.start);
    node.hoists.forEach((hoist) => {
        genExpressionNode(hoist);
        ctx.newLine();
    });
    writeLine(annotations.templateGlobals.end);
}
function genElementNode(node) {
    genDirectiveChecks(node);
    ctx.write('<', node.startTagLoc);
    if (node.tag !== '') {
        ctx.write(node.tag, node.tagLoc, true).newLine();
        indent(() => {
            genProps(node);
            ctx.write(`${annotations.tsxCompletions}`);
        });
        ctx.newLine();
    }
    else {
        return; // tag is empty, when only "<" is present
    }
    if (node.isSelfClosing) {
        ctx.write('/>', node.endTagLoc);
        return; // done
    }
    ctx.write('>').newLine();
    indent(() => genChildren(node));
    ctx.write('</', node.endTagLoc);
    ctx.write(node.tag);
    ctx.write('>');
}
function genComponentNode(node) {
    // if (node.tag.includes('-')) return genElementNode(node) // assume custom element
    if (node.resolvedName == null) {
        ctx.write('{(() => {').newLine();
        indent(() => {
            const name = `${ctx.internalIdentifierPrefix}component`;
            genTypeGuards();
            ctx.newLine();
            ctx.write(`const ${name} = ${getRuntimeFn(ctx.typeIdentifier, 'resolveComponent')}(${ctx.isTypeScript
                ? `{} as unknown as ${ctx.internalIdentifierPrefix}GlobalComponents`
                : `/** @type {${ctx.internalIdentifierPrefix}GlobalComponents} */ (/** @type {unknown} */ ({}))`}, ${ctx.isTypeScript
                ? `{} as unknown as JSX.IntrinsicElements`
                : `/** @type {JSX.IntrinsicElements} */ (/** @type {unknown} */ ({}))`}, ${ctx.contextIdentifier}, `);
            if (templateAstTypes.isAttributeNode(node.is)) {
                const name = node.is.value?.content ?? '';
                ctx.write(JSON.stringify(name), node.is.value?.loc, true);
                ctx.write(', ');
                ctx.write(JSON.stringify(name), node.is.value?.loc, true);
                ctx.write(', ');
                ctx.write(JSON.stringify(shared.pascalCase(name)), node.is.value?.loc, true);
            }
            else if (node.is != null && templateAstTypes.isExpressionNode(node.is.exp)) {
                genExpressionNode(node.is.exp);
                ctx.write(', ');
                genExpressionNode(node.is.exp);
                ctx.write(', ');
                genExpressionNode(node.is.exp);
            }
            else {
                ctx.write('undefined, undefined, undefined');
            }
            ctx.write(');').newLine();
            writeLine(`if (${name} == null) throw new Error`);
            ctx.write('return (').newLine();
            indent(() => {
                node.resolvedName = name;
                genComponentNode(node);
                node.resolvedName = undefined;
            });
            ctx.newLine().write(');').newLine();
        });
        ctx.write('})()}');
        return; // - done
    }
    genDirectiveChecks(node);
    ctx.write('<', node.loc);
    ctx.write(node.resolvedName ?? node.tag, node.tagLoc, true).newLine();
    indent(() => {
        genProps(node);
        ctx.write(`${annotations.tsxCompletions}`);
    });
    ctx.newLine();
    if (node.isSelfClosing) {
        ctx.write('$slots={{}}');
        ctx.write('/>', node.endTagLoc).newLine();
        return; // done
    }
    ctx.write('$slots=');
    indent(() => {
        wrap('{', '}', () => {
            ctx.write(`{`);
            ctx.newLine();
            indent(() => {
                node.slots.forEach((slotNode) => {
                    if (slotNode.name == null) {
                        ctx.write(`default`);
                    }
                    else if (isStaticExpression(slotNode.name)) {
                        ctx.write(JSON.stringify(slotNode.name.content), slotNode.name.loc);
                    }
                    else {
                        ctx.write('[');
                        genExpressionNode(slotNode.name);
                        ctx.write(']');
                    }
                    ctx.write(': (');
                    if (slotNode.args != null) {
                        genExpressionNode(slotNode.args);
                    }
                    ctx.write(') => {').newLine();
                    indent(() => {
                        genTypeGuards();
                        genNodeHoists(slotNode);
                        writeLine('return (');
                        indent(() => {
                            writeLine('<>');
                            indent(() => genChildren(slotNode));
                            writeLine('</>');
                        });
                        writeLine(')');
                    });
                    ctx.write('},').newLine();
                });
            });
            ctx.write('}');
        });
    });
    writeLine('>');
    ctx.newLine();
    ctx.write('</', node.endTagLoc);
    ctx.write(node.resolvedName ?? node.tag);
    ctx.write('>');
}
function genTypeGuards() {
    const value = ctx.setSourceMapMode(false);
    ctx.typeGuards.forEach((guard) => {
        if (guard == null)
            return;
        ctx.write(`if(!(`);
        genExpressionNode(guard);
        ctx.write(')) throw new Error;').newLine();
    });
    ctx.setSourceMapMode(value);
}
function genSlotOutletNode(node) {
    const name = compilerCore.findProp(node, 'name', false, true);
    const accessor = ['$slots'];
    if (templateAstTypes.isAttributeNode(name) && name.value != null) {
        if (templateAstTypes.isSimpleIdentifier(name.value.content)) {
            accessor.push('.', compilerCore.createSimpleExpression(name.value.content, false, name.value.loc));
        }
        else {
            accessor.push('[', name.value, ']');
        }
    }
    else if (templateAstTypes.isDirectiveNode(name) && name.arg != null) {
        if (templateAstTypes.isSimpleExpressionNode(name.arg) &&
            templateAstTypes.isSimpleIdentifier(name.arg.content)) {
            accessor.push('.', compilerCore.createSimpleExpression(name.arg.content, false, name.arg.loc));
        }
        else {
            accessor.push('[', name.arg, ']');
        }
    }
    else {
        accessor.push(`.default`);
    }
    const genSlotAccessor = () => {
        genExpressionNode(compilerCore.createCompoundExpression(accessor));
    };
    wrap('{', '}', () => {
        ctx.newLine();
        indent(() => {
            genSlotAccessor();
            ctx.write(' != null ? ');
            genSlotAccessor();
            ctx.write('({');
            const props = node.props.filter((node) => node !== name);
            if (props.length > 0) {
                indent(() => {
                    ctx.newLine();
                    props.forEach((prop) => {
                        genObjectProperty(prop);
                    });
                });
            }
            ctx.write('})');
        });
        ctx.write(' : ');
        if (node.children.length > 0) {
            ctx.typeGuards.push(compilerCore.createCompoundExpression([...accessor, ' == null']));
            indent(() => {
                wrap('(', ')', () => {
                    ctx.newLine();
                    indent(() => {
                        wrap('<>', '</>', () => {
                            ctx.newLine();
                            indent(() => genChildren(node));
                        });
                    });
                    ctx.newLine();
                });
                ctx.newLine();
            });
            ctx.typeGuards.pop();
        }
        else {
            ctx.write('null');
        }
        ctx.newLine();
    });
}
function genChildren(node) {
    node.children.forEach((node) => {
        if (templateAstTypes.isTextNode(node)) {
            ctx.write('{');
            genTextNode(node);
            ctx.write('}');
            ctx.newLine();
        }
        else {
            genNode(node);
            ctx.newLine();
        }
    });
}
function genProps(el) {
    if (el.props.length === 0)
        return;
    const rendered = new Set();
    const directives = el.props.filter(templateAstTypes.isDirectiveNode);
    el.props.forEach((prop) => {
        if (templateAstTypes.isAttributeNode(prop)) {
            genAttribute(prop, el);
            ctx.newLine();
        }
        else if (rendered.has(prop)) ;
        else if (prop.name === 'bind') {
            genVBindDirective(prop, el);
            ctx.newLine();
        }
        else if (prop.name === 'on') {
            if (prop.arg == null) {
                if (prop.exp == null) {
                    ctx.write('on', prop.loc, true);
                }
                else {
                    ctx.write('{...(');
                    genExpressionNode(prop.exp);
                    ctx.write(')}');
                }
            }
            else {
                shared.invariant(templateAstTypes.isSimpleExpressionNode(prop.arg));
                const id = prop.arg.content;
                const all = directives.filter((directive) => directive.name === 'on' &&
                    templateAstTypes.isSimpleExpressionNode(directive.arg) &&
                    directive.arg.content === id);
                const genHandler = () => {
                    if (templateAstTypes.isPlainElementNode(el)) {
                        ctx.typeGuards.push(compilerCore.createCompoundExpression([
                            `$event.currentTarget instanceof `,
                            shared.getClassNameForTagName(el.tag),
                        ]));
                    }
                    ctx.write(`${getRuntimeFn(ctx.typeIdentifier, 'first')}([`).newLine();
                    indent(() => {
                        all.forEach((directive) => {
                            rendered.add(directive);
                            if (directive.exp != null) {
                                genExpressionNodeAsFunction(directive.exp);
                            }
                            else {
                                ctx.write(annotations.missingExpression, directive.loc);
                            }
                            ctx.write(', ');
                            ctx.newLine();
                        });
                    });
                    ctx.write('])');
                    if (templateAstTypes.isPlainElementNode(el)) {
                        ctx.typeGuards.pop();
                    }
                };
                if (isStaticExpression(prop.arg)) {
                    ctx.write(`on${shared.capitalize(prop.arg.content)}`, prop.arg.loc, true);
                    ctx.write('=');
                    wrap('{', '}', genHandler);
                }
                else {
                    ctx.write('{...({');
                    ctx.write('[');
                    genExpressionNode(prop.arg); // TODO: Capitalize
                    ctx.write(']: ');
                    genHandler();
                    ctx.write('})}');
                }
            }
            ctx.newLine();
        }
        else if (prop.name === 'text' || prop.name === 'html') {
            ctx.write('innerHTML', createLoc(prop.loc, 2, 4), true).write('=');
            wrap('{', '}', () => {
                if (prop.exp != null) {
                    genExpressionNode(prop.exp);
                }
                else {
                    ctx.write(annotations.missingExpression);
                }
            });
            ctx.newLine();
        }
        else if (prop.name === 'model') {
            const genExp = () => {
                if (prop.exp != null) {
                    genExpressionNode(prop.exp);
                }
                else {
                    ctx.write(annotations.missingExpression, sliceLoc(prop.loc, -1));
                }
            };
            if (prop.arg == null) {
                // TODO: get attribute name at runtime
                let isCheckbox = false;
                if (['input', 'select', 'textarea'].includes(el.tag)) {
                    const type = compilerCore.findProp(el, 'type');
                    if (templateAstTypes.isAttributeNode(type) &&
                        (type.value?.content === 'checkbox' ||
                            type.value?.content === 'radio')) {
                        isCheckbox = true;
                        ctx.write('checked', prop.nameLoc, true);
                    }
                    else {
                        ctx.write('value', prop.nameLoc, true);
                    }
                }
                else {
                    ctx.write('modelValue', prop.nameLoc, true);
                }
                ctx.write('={');
                genExp();
                if (isCheckbox) {
                    const value = compilerCore.findProp(el, 'value');
                    if (templateAstTypes.isAttributeNode(value)) {
                        ctx.write(' === ');
                        if (value.value != null) {
                            genTextNode(value.value);
                        }
                        else {
                            ctx.write('undefined', value.loc);
                        }
                    }
                    else if (templateAstTypes.isDirectiveNode(value)) {
                        ctx.write(' === ');
                        if (value.exp != null) {
                            genExpressionNode(value.exp);
                        }
                        else {
                            ctx.write('undefined', value.loc);
                        }
                    }
                }
                ctx.write('}');
            }
            else if (isStaticExpression(prop.arg)) {
                ctx.write(prop.arg.content, prop.arg.loc);
                ctx.write('={');
                genExp();
                ctx.write('}');
            }
            else {
                ctx.write('{...({');
                genExpressionNode(prop.arg);
                ctx.write(': ');
                genExp();
                ctx.write('})}');
            }
            ctx.newLine();
        }
    });
}
function genAttribute(attribute, element) {
    if (attribute.name === 'class' || attribute.name === 'style')
        return; // TODO: handle class and style eventually
    const name = templateAstTypes.isPlainElementNode(element) ||
        attribute.name.startsWith('data-') ||
        attribute.name.startsWith('aria-')
        ? attribute.name
        : shared.camelize(attribute.name);
    ctx.write(name, attribute.nameLoc, true);
    if (attribute.value != null) {
        ctx.write('=');
        genTextNode(attribute.value);
    }
}
function genVBindDirective(prop, element) {
    if (isStaticExpression(prop.arg)) {
        const name = templateAstTypes.isPlainElementNode(element) ||
            prop.arg.content.startsWith('data-') ||
            prop.arg.content.startsWith('aria-')
            ? prop.arg.content
            : shared.camelize(prop.arg.content);
        ctx.write(name, prop.arg.loc, true);
        if (prop.exp != null) {
            ctx.write('=');
            ctx.write('{');
            genExpressionNode(prop.exp);
            ctx.write('}');
        }
    }
    else if (prop.arg != null) {
        ctx.write('{...({[');
        genExpressionNode(prop.arg);
        ctx.write(']');
        if (prop.exp != null) {
            ctx.write(': ');
            genExpressionNode(prop.exp);
        }
        else {
            ctx.write(': true');
        }
        ctx.write('})}');
    }
    else if (prop.exp == null) {
        ctx.write(' ', prop.loc);
    }
    else {
        ctx.write('{...(');
        if (prop.exp != null) {
            genExpressionNode(prop.exp);
        }
        else {
            ctx.write(' ', createLoc(prop.loc, prop.loc.source.length));
        }
        ctx.write(')}');
    }
}
function genTextNode(node) {
    ctx.write(JSON.stringify(node.content), node.loc, true);
}
function genInterpolationNode(node) {
    ctx.write(' {', node.loc);
    genExpressionNode(node.content);
    ctx.write('} ', sliceLoc(node.loc, -2));
}
function genExpressionNode(node) {
    if (templateAstTypes.isSimpleExpressionNode(node)) {
        if (isStaticExpression(node)) {
            ctx.write(JSON.stringify(node.content), node.loc, true);
        }
        else {
            genSimpleExpressionNode(node);
        }
    }
    else {
        genCompoundExpressionNode(node);
    }
}
function genExpressionNodeAsFunction(node) {
    shared.invariant(templateAstTypes.isSimpleExpressionNode(node), 'v-on directive expression must be simple.');
    if (
    // is identifier?
    templateAstTypes.isSimpleIdentifier(node.content) ||
        // is arrow function expression?
        /^(\([^)]*\)|[A-Za-z$_][A-Za-z0-9$_]*)\s*=>/i.test(node.content.trim()) ||
        // is function expression?
        /^function[\s(]/.test(node.content.trim())) {
        genSimpleExpressionNode(node);
    }
    else {
        node.content.includes('$event')
            ? ctx.write('($event) => {').newLine()
            : ctx.write('() => {').newLine();
        genTypeGuards();
        genSimpleExpressionNode(node);
        ctx.newLine().write('}');
    }
}
function genSimpleExpressionNode(node) {
    ctx.write(node.content, node.loc, true);
}
function genCompoundExpressionNode(node) {
    node.children.forEach((node) => {
        if (typeof node === 'string') {
            ctx.write(node);
        }
        else if (typeof node === 'symbol') {
            throw new Error('Unsupported symbol node');
        }
        else {
            genNode(node);
        }
    });
}
function createGenerateContext(options) {
    let indent = 0;
    let output = '';
    let line = 0;
    let column = 0;
    const names = [];
    const mappings = [[]];
    let shouldIndent = false;
    let shouldWriteMapping = true;
    const nl = '\n';
    function push(chunk, loc, addMappingType = false) {
        output += chunk;
        const lines = chunk.split(nl);
        if (loc != null && shouldWriteMapping) {
            let index = null;
            if (addMappingType) {
                const name = loc.source.startsWith(chunk)
                    ? `<<P>>${chunk.length}`
                    : loc.source.endsWith(chunk)
                        ? `<<S>>${loc.source.length}|${chunk.length}`
                        : `<<T>>${loc.source.length}|${chunk.length}`;
                index = names.indexOf(name);
                if (index === -1) {
                    index = names.push(name) - 1;
                }
            }
            mappings[line]?.push(index != null
                ? [column, 0, loc.start.line - 1, loc.start.column - 1, index]
                : [column, 0, loc.start.line - 1, loc.start.column - 1]);
        }
        else {
            mappings[line]?.push([column]);
        }
        if (lines.length > 1) {
            line += lines.length - 1;
            column = shared.last(lines).length;
        }
        else {
            column += chunk.length;
        }
        for (let i = mappings.length; i <= line; i++) {
            mappings.push([]);
        }
    }
    const context = {
        ...options,
        typeGuards: [],
        setSourceMapMode(enabled) {
            const current = shouldWriteMapping;
            shouldWriteMapping = enabled;
            return current;
        },
        write(code, loc, addMappingType) {
            if (shouldIndent) {
                shouldIndent = false;
                push(' '.repeat(indent));
            }
            push(code, loc, addMappingType);
            return context;
        },
        newLine() {
            push(nl);
            shouldIndent = true;
            return context;
        },
        indent() {
            indent = Math.max(0, indent) + 2;
            return context;
        },
        deindent() {
            indent = Math.max(0, indent - 2);
            return context;
        },
        getOutput() {
            return {
                code: output,
                map: {
                    file: options.fileName,
                    sources: [],
                    sourcesContent: [],
                    names,
                    mappings,
                },
            };
        },
    };
    return context;
}
function isStaticExpression(node) {
    return templateAstTypes.isSimpleExpressionNode(node) && node.isStatic;
}
function genSlotTypes(root) {
    const slots = [];
    const value = ctx.setSourceMapMode(false);
    templateAstTypes.traverse(root, (node, ancestors) => {
        if (templateAstTypes.isSlotNode(node)) {
            slots.push([node, ancestors.slice()]);
        }
    });
    writeLine(annotations.diagnosticsIgnore.start);
    ctx.write(`function ${ctx.internalIdentifierPrefix}_slots() {`).newLine();
    indent(() => {
        genGlobalDeclarations(root);
        ctx
            .write(`return ${getRuntimeFn(ctx.typeIdentifier, 'union')}(...${getRuntimeFn(ctx.typeIdentifier, 'flat')}([`)
            .newLine();
        indent(() => {
            for (const [slot, ancestors] of slots) {
                recurse(ancestors.slice().map((path) => path.node), {
                    enter(node, index, nodes) {
                        if (isForNode(node)) {
                            ctx.write(getRuntimeFn(ctx.typeIdentifier, 'flat'));
                            ctx.write('(');
                            ctx.newLine().indent();
                            ctx.write(getRuntimeFn(ctx.typeIdentifier, 'renderList'));
                            ctx.write('(');
                            genForNodeArgs(node);
                            ctx.write(' => (');
                            ctx.newLine().indent();
                        }
                        else if (templateAstTypes.isComponentNode(node)) {
                            ctx.write(getRuntimeFn(ctx.typeIdentifier, 'flat'));
                            const next = nodes[index + 1];
                            const currentSlot = next != null
                                ? node.slots.find((slot) => slot.template === next)
                                : null;
                            ctx.write('(((');
                            if (currentSlot?.args != null) {
                                genExpressionNode(currentSlot.args);
                            }
                            else {
                                ctx.write('_');
                            }
                            if (ctx.isTypeScript) {
                                ctx.write(`: ${ctx.typeIdentifier}.internal.GetSlotProps<`);
                                if (node.resolvedName != null) {
                                    ctx.write('typeof ');
                                    ctx.write(node.resolvedName);
                                }
                                else if (node.is != null) {
                                    if (templateAstTypes.isDirectiveNode(node.is) && node.is.exp != null) {
                                        ctx.write('typeof ');
                                        genExpressionNode(node.is.exp);
                                    }
                                    else {
                                        ctx.write('{}');
                                    }
                                }
                                else {
                                    ctx.write('{}');
                                }
                                ctx.write(', ');
                                if (currentSlot?.name != null) {
                                    if (!isStaticExpression(currentSlot.name)) {
                                        ctx.write('typeof ');
                                    }
                                    genExpressionNode(currentSlot.name);
                                }
                                else {
                                    ctx.write('"default"');
                                }
                                ctx.write('>');
                            }
                            ctx.write(') => {');
                            ctx.newLine().indent();
                            ctx.write('return [');
                            ctx.newLine().indent();
                        }
                    },
                    exit(node) {
                        if (templateAstTypes.isComponentNode(node)) {
                            ctx.deindent().newLine();
                            ctx.write(']');
                            ctx.deindent().newLine();
                            ctx.write(`})(${typeCastAs('null', 'any')}))`);
                        }
                        else if (isForNode(node)) {
                            ctx.deindent().newLine();
                            ctx.write('))');
                            ctx.deindent().newLine();
                            ctx.write(')');
                        }
                    },
                    fn() {
                        const name = compilerCore.findProp(slot, 'name', false, true);
                        ctx
                            .write(getRuntimeFn(ctx.typeIdentifier, 'record'))
                            .write('(')
                            .newLine();
                        indent(() => {
                            if (templateAstTypes.isAttributeNode(name)) {
                                if (name.value != null) {
                                    ctx.write(JSON.stringify(name.value.content));
                                }
                                else {
                                    ctx.write('undefined');
                                }
                            }
                            else if (templateAstTypes.isDirectiveNode(name)) {
                                if (name.exp != null) {
                                    genExpressionNode(name.exp);
                                }
                                else {
                                    ctx.write('undefined');
                                }
                            }
                            else {
                                ctx.write('"default" as const');
                            }
                            ctx.write(', ');
                            ctx.write('{');
                            indent(() => {
                                const props = slot.props.filter((prop) => prop !== name);
                                if (props.length === 0)
                                    return;
                                ctx.newLine();
                                slot.props.forEach((prop) => {
                                    if (prop === name)
                                        return;
                                    genObjectProperty(prop);
                                });
                            });
                            ctx.write('},').newLine();
                        });
                        ctx.write(')');
                    },
                });
                ctx.write(',').newLine();
            }
        });
        ctx.write(']))').newLine();
    });
    ctx.write('}').newLine();
    writeLine(annotations.diagnosticsIgnore.end);
    ctx.setSourceMapMode(value);
}
function genObjectProperty(prop, newLine = true) {
    if (templateAstTypes.isAttributeNode(prop)) {
        breakMapping(prop.loc);
        ctx.write(prop.name, prop.nameLoc, true).write(': ');
        if (prop.value != null) {
            genTextNode(prop.value);
        }
        else {
            ctx.write('true');
        }
        ctx.write(',');
        if (newLine)
            ctx.newLine();
    }
    else if (prop.name !== 'bind') ;
    else if (prop.arg != null) {
        breakMapping(prop.loc);
        if (isStaticExpression(prop.arg)) {
            if (/^[a-zA-Z_$0-9]+$/.test(prop.arg.content)) {
                ctx.write(prop.arg.content, prop.arg.loc, true);
            }
            else {
                ctx.write(JSON.stringify(prop.arg.content), prop.arg.loc, true);
            }
        }
        else {
            ctx.write('[', prop.loc);
            genExpressionNode(prop.arg);
            ctx.write(']');
        }
        ctx.write(': ');
        if (prop.exp != null) {
            genExpressionNode(prop.exp);
        }
        else {
            ctx.write('true');
        }
        ctx.write(',');
        if (newLine)
            ctx.newLine();
    }
    else if (prop.exp != null) {
        ctx.write('...(', prop.loc);
        genExpressionNode(prop.exp);
        ctx.write(')');
        ctx.write(',');
        if (newLine)
            ctx.newLine();
    }
}
function recurse(items, options) {
    if (options.enter != null) {
        for (let i = 0; i < items.length; i++) {
            options.enter(items[i], i, items);
        }
    }
    options.fn();
    if (options.exit != null) {
        for (let i = items.length - 1; i >= 0; i--) {
            options.exit(items[i], i, items);
        }
    }
}
// function isIfNode(node: Node): node is IfNode {
//   return node.type === NodeTypes.IF
// }
function isForNode(node) {
    return node.type === templateAstTypes.NodeTypes.FOR;
}
function genForNodeArgs(node) {
    const context = ctx;
    const forExps = node.parseResult;
    // Source
    if (templateAstTypes.isSimpleExpressionNode(forExps.source)) {
        const quote = !templateAstTypes.isSimpleIdentifier(forExps.source.content);
        if (quote)
            context.write('(');
        context.write(forExps.source.content, forExps.source.loc, true);
        if (quote)
            context.write(')');
    }
    else {
        context.write('undefined');
    }
    context.write(', ');
    // Handler Args
    context.write('(');
    const args = ['_', '__'];
    if (templateAstTypes.isSimpleExpressionNode(forExps.value)) {
        context.write(forExps.value.content, forExps.value.loc, true);
    }
    else if (forExps.key != null || forExps.index != null) {
        context.write(args.pop() ?? '_');
    }
    if (templateAstTypes.isSimpleExpressionNode(forExps.key)) {
        context.write(', ');
        context.write(forExps.key.content, forExps.key.loc, true);
    }
    else if (forExps.index != null) {
        context.write(', ');
        context.write(args.pop() ?? '_');
    }
    if (templateAstTypes.isSimpleExpressionNode(forExps.index)) {
        context.write(', ');
        context.write(forExps.index.content, forExps.index.loc, true);
    }
    context.write(')');
}
function genCommentNode(node) {
    ctx.write('{/*').write(node.content, node.loc).write('*/}');
}
function genForNode(forNode) {
    wrap('{', '}', () => {
        ctx.newLine();
        indent(() => {
            genFn(getRuntimeFn(ctx.typeIdentifier, 'renderList'), () => {
                genForNodeArgs(forNode);
                ctx.write(' => {').newLine();
                indent(() => {
                    genNodeHoists(forNode);
                    wrap('return (', ')', () => {
                        if (forNode.children.length === 1) {
                            ctx.newLine();
                            indent(() => genChildren(forNode));
                        }
                        else {
                            wrap('<>', '</>', () => {
                                ctx.newLine();
                                indent(() => genChildren(forNode));
                            });
                        }
                    });
                });
                ctx.newLine().write('}');
            });
        });
        ctx.newLine();
    });
}
function genFn(name, fn) {
    wrap(`${name}(`, ')', fn);
}
function wrap(open, close, fn) {
    ctx.write(open);
    fn();
    ctx.write(close);
}
function genIfNode(node) {
    wrap('{', '}', () => {
        let i = 0;
        let hasElse = false;
        const n = node.branches.length - 1;
        recurse(node.branches, {
            enter(branch) {
                ctx.typeGuards.push(branch.condition);
                if (i > 0)
                    indent(() => ctx.write(': '));
                if (branch.condition != null) {
                    genExpressionNode(branch.condition);
                    ctx.newLine();
                    indent(() => ctx.write('? '));
                }
                else if (i < n) {
                    ctx.write(annotations.missingExpression, node.loc).newLine();
                    ctx.newLine();
                    indent(() => ctx.write('? '));
                }
                else {
                    hasElse = true;
                }
                ++i;
                indent(() => {
                    indent(() => {
                        wrap('<>', '</>', () => {
                            ctx.newLine();
                            indent(() => genChildren(branch));
                        });
                    });
                });
                ctx.newLine();
            },
            exit() {
                ctx.typeGuards.pop();
            },
            fn() {
                if (!hasElse) {
                    ctx.write('  : null').newLine();
                }
            },
        });
    });
}
function genTemplateNode(node) {
    wrap('<>', '</>', () => {
        ctx.newLine();
        indent(() => genChildren(node));
    });
}
function breakMapping(loc) {
    // Break mapping
    ctx.deindent();
    ctx.write('  ', loc);
    ctx.indent();
}
function asConst(value) {
    return typeCastAs(value, 'const');
}
function typeCastAs(value, type) {
    return ctx.isTypeScript
        ? `${value} as ${type}`
        : `/** @type {${type}} */ (${value})`;
}
function genAttrTypes(root) {
    const value = ctx.setSourceMapMode(false);
    // TODO: Support components.
    const nodes = [];
    if (root.loc.source.includes('@vue-attrs-target')) {
        templateAstTypes.traverse(root, {
            enter(node, ancestors) {
                if (templateAstTypes.isCommentNode(node)) {
                    if (node.content.includes('@vue-attrs-target')) {
                        const { node: parent, key, index } = shared.last(ancestors);
                        if (index != null) {
                            const el = parent[key]?.[index + 1];
                            if (templateAstTypes.isPlainElementNode(el)) {
                                nodes.push(el);
                            }
                        }
                    }
                }
            },
        });
    }
    else {
        templateAstTypes.traverseEvery(root, (node, ancestors) => {
            if (templateAstTypes.isPlainElementNode(node)) {
                const { node: parent } = shared.last(ancestors);
                if (templateAstTypes.isRootNode(parent)) {
                    if (parent.children.filter(templateAstTypes.isPlainElementNode).length === 1) {
                        nodes.push(node);
                    }
                }
                else {
                    nodes.push(node);
                }
            }
            else if (templateAstTypes.isTemplateNode(node) || templateAstTypes.isRootNode(node)) {
                return true;
            }
            else if (node.type === templateAstTypes.NodeTypes.IF ||
                node.type === templateAstTypes.NodeTypes.IF_BRANCH ||
                node.type === templateAstTypes.NodeTypes.FOR) {
                return true;
            }
            return false;
        });
    }
    ctx.write(`const ${ctx.internalIdentifierPrefix}_attrs = (() => {`).newLine();
    indent(() => {
        const value = typeCastAs('{}', 'unknown');
        ctx.write('return ');
        ctx.write(getRuntimeFn(ctx.typeIdentifier, 'first'));
        ctx.write('(');
        ctx.write(getRuntimeFn(ctx.typeIdentifier, 'flat'));
        ctx.write('([');
        if (nodes.length > 0) {
            indent(() => {
                ctx.newLine();
                for (const node of nodes) {
                    const type = JSON.stringify(node.tag);
                    ctx.write(typeCastAs(value, `${ctx.typeIdentifier}.internal.PropsOf<JSX.IntrinsicElements, ${type}>`));
                    ctx.write(',');
                    ctx.newLine();
                }
            });
        }
        else {
            ctx.write('{}');
        }
        ctx.write(']))');
        ctx.newLine();
    });
    ctx.write('})();').newLine();
    ctx.setSourceMapMode(value);
}

function transformCustomBlock(_block, options) {
    return {
        code: '',
        map: {
            file: options.fileName,
            sources: [],
            names: [],
            mappings: [],
            sourcesContent: [],
        },
    };
}

function transformScript(script, options) {
    const content = script?.content ?? '';
    const result = transforms.transformScript(content, {
        internalIdentifierPrefix: options.internalIdentifierPrefix,
        runtimeModuleName: options.runtimeModuleName,
        typeIdentifier: options.typeIdentifier,
        lang: (script?.lang ?? 'ts'),
        fileName: options.fileName,
        lib: options.typescript,
        cache: options.cache,
    });
    shared.invariant(result.map != null);
    return {
        code: result.code,
        map: result.map,
        identifiers: result.identifiers,
        exportIdentifier: result.componentIdentifier,
        name: result.name,
        inheritAttrs: result.inheritAttrs,
    };
}

function transformScriptSetup(script, options) {
    const content = script?.content ?? '';
    const generic = script?.attrs?.['generic'];
    const result = transforms.transformScriptSetup(content, {
        internalIdentifierPrefix: options.internalIdentifierPrefix,
        runtimeModuleName: options.runtimeModuleName,
        typeIdentifier: options.typeIdentifier,
        lang: (script?.lang ?? 'ts'),
        fileName: options.fileName,
        lib: options.typescript,
        cache: options.cache,
        attrsIdentifier: `${options.internalIdentifierPrefix}_attrs`,
        slotsIdentifier: `${options.internalIdentifierPrefix}_slots`,
        generic: typeof generic === 'string' ? generic : undefined,
    });
    shared.invariant(result.map != null);
    return {
        code: result.code,
        map: result.map,
        identifiers: result.identifiers,
        exportIdentifier: result.privateComponentIdentifier,
        componentIdentifier: result.publicComponentIdentifier,
        scopeIdentifier: result.scopeIdentifier,
        exports: result.exports,
    };
}

function transformStyle(_style, options) {
    return {
        code: '',
        map: {
            file: options.fileName,
            sources: [],
            names: [],
            mappings: [],
            sourcesContent: [],
        },
    };
}

const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
function createTransformFor(customContext) {
    return compilerCore.createStructuralDirectiveTransform(/^for$/, (node, dir, context) => {
        return compilerCore.processFor(node, dir, context, (forNode) => {
            customContext.scope.createNewHoistScope();
            return () => {
                forNode.hoists = customContext.scope.popHoistScope();
            };
        });
    });
}

class Scope {
    constructor(parent = null) {
        this.parent = parent;
        this.bindings = {};
    }
    get identifiers() {
        return Array.from(Object.keys(this.bindings));
    }
    get globals() {
        return this.identifiers.filter((identifier) => this.getBinding(identifier) === null);
    }
    getBinding(identifier) {
        if (identifier in this.bindings)
            return this.bindings[identifier] ?? null;
        if (this.parent != null) {
            return (this.bindings[identifier] = this.parent.getBinding(identifier));
        }
        else {
            this.bindings[identifier] = null;
        }
        return null;
    }
    setBinding(identifier, node) {
        this.bindings[identifier] = node;
    }
}
function withScope(ast) {
    ast.scope = new Scope(null);
    templateAstTypes.traverse(ast, (node, ancestors) => {
        const parent = (ancestors[ancestors.length - 1]?.node ?? ast);
        const scope = (node.scope = node.scope ?? new Scope(parent.scope));
        if (templateAstTypes.isSimpleExpressionNode(node) && !node.isStatic) {
            if (parent != null ||
                !(templateAstTypes.isDirectiveNode(parent) &&
                    ['slot', 'for'].includes(parent.name) &&
                    parent.exp === node)) {
                const isOnDirective = templateAstTypes.isDirectiveNode(parent) && parent.name === 'on';
                getIdentifiers(node.content).forEach((identifier) => {
                    if (isOnDirective && identifier === '$event')
                        return;
                    scope.getBinding(identifier);
                });
            }
        }
        else if (templateAstTypes.isElementNode(node)) {
            node.props.forEach((prop) => {
                if (templateAstTypes.isDirectiveNode(prop)) {
                    const directiveScope = (prop.scope = prop.scope ?? new Scope(scope));
                    if (prop.name === 'slot') {
                        if (templateAstTypes.isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const content = prop.exp.content.trim();
                            getIdentifiers(`(${content}) => {}`, false).forEach((identifier) => {
                                scope.setBinding(identifier, node);
                                localScope.getBinding(identifier);
                            });
                        }
                    }
                    else if (prop.name === 'for') {
                        if (templateAstTypes.isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const match = forAliasRE.exec(prop.exp.content);
                            if (match != null) {
                                const [, LHS, RHS] = match;
                                shared.invariant(LHS != null && RHS != null);
                                getIdentifiers(RHS).forEach((identifier) => {
                                    localScope.getBinding(identifier);
                                });
                                getIdentifiers(`${LHS ?? '()'} => {}`, false).forEach((identifier) => {
                                    scope.setBinding(identifier, node);
                                    localScope.getBinding(identifier);
                                });
                            }
                        }
                    }
                }
            });
        }
    });
    return ast;
}
function getIdentifiers(source, ignoreFunctionParameters = true) {
    source = source
        .trim()
        // Common errors when user is typing.
        .replace(/(\.|\[\]?)\s*$/, '');
    const identifiers = new Set();
    const add = (id) => {
        if (isValidIdentifier(id))
            identifiers.add(id);
    };
    if (compilerCore.isSimpleIdentifier(source.trim())) {
        add(source);
    }
    else {
        try {
            const ast = parseUsingBabel(source, true);
            let definedInScope = new Set();
            const scopes = [];
            const pushScope = (scope) => {
                if (!ignoreFunctionParameters)
                    return;
                scopes.push(scope);
                definedInScope = new Set([...definedInScope, ...scope]);
            };
            const popScope = () => {
                if (!ignoreFunctionParameters)
                    return;
                scopes.pop();
                definedInScope = new Set(scopes.flatMap((scope) => Array.from(scope)));
            };
            types.traverse(ast, {
                enter: (node, ancestors) => {
                    if (types.isFunctionDeclaration(node) || types.isArrowFunctionExpression(node)) {
                        const scope = new Set();
                        node.params.forEach((param) => {
                            types.traverse(param, (node) => {
                                if (types.isIdentifier(node))
                                    scope.add(node.name);
                            });
                        });
                        pushScope(scope);
                    }
                    if (types.isIdentifier(node) && !definedInScope.has(node.name)) {
                        if (shouldTrack(node, ancestors.slice())) {
                            add(node.name);
                        }
                    }
                },
                exit: (node) => {
                    if (types.isFunctionDeclaration(node) || types.isArrowFunctionExpression(node)) {
                        popScope();
                    }
                },
            });
        }
        catch {
            const RE = /\b[a-z$_][a-z0-9$_]+\b/gi;
            let match;
            while ((match = RE.exec(source)) != null) {
                add(match[0] ?? '');
            }
        }
    }
    return identifiers;
}
function isValidIdentifier(id) {
    return (id.trim().length > 0 &&
        !/^(of|in|for|while|function|class|const|let|var|true|false)$/.test(id));
}
function parseUsingBabel(source, withTS = false) {
    try {
        return parser.parse(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
    catch {
        return parser.parseExpression(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
}
// TODO: This misses destructured arguments
function shouldTrack(identifier, ancestors) {
    const ancestor = ancestors.pop();
    if (ancestor == null)
        return true;
    const parent = ancestor.node;
    if (
    // not id of a FunctionDeclaration
    !(types.isFunction(parent) && parent.id === identifier) &&
        // not a key of Property
        !isStaticPropertyKey(identifier, parent) &&
        // not a property of a MemberExpression
        !((types.isMemberExpression(parent) || types.isOptionalMemberExpression(parent)) &&
            parent.property === identifier &&
            !parent.computed) &&
        // skip allowed globals
        !isKnownIdentifier(identifier.name) &&
        // special case for webpack compilation
        identifier.name !== `require` &&
        // is a special keyword but parsed as identifier
        identifier.name !== `arguments`) {
        return true;
    }
    return false;
}
const KNOWN_IDENTIFIERS = new Set(('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt').split(','));
function isKnownIdentifier(value) {
    return KNOWN_IDENTIFIERS.has(value) || /^(true|false|null|this)$/.test(value);
}
function isStaticProperty(node) {
    return types.isObjectMember(node) && !node.computed;
}
function isStaticPropertyKey(node, parent) {
    return isStaticProperty(parent) && parent.key === node;
}

class ScopeManager {
    constructor() {
        this.hoists = [];
        this.identifiers = {};
        this.rootScope = [];
        this.currentScope = this.rootScope;
    }
    getRootScope() {
        return this.rootScope;
    }
    addIdentifier(value) {
        this.identifiers[value] = 1 + (this.identifiers[value] ?? 0);
    }
    hasIdentifier(value) {
        return (this.identifiers[value] ?? 0) > 0;
    }
    removeIdentifier(value) {
        this.identifiers[value] = Math.max(0, this.identifiers[value] ?? 0 - 1);
    }
    scopeHoist(expression) {
        if (typeof expression === 'string') {
            this.currentScope.push(compilerCore.createCompoundExpression([expression]));
        }
        else {
            this.currentScope.push(expression);
        }
    }
    hoist(expression) {
        if (typeof expression === 'string') {
            this.rootScope.push(compilerCore.createCompoundExpression([expression]));
        }
        else {
            this.rootScope.push(expression);
        }
    }
    createNewHoistScope() {
        this.hoists.push(this.currentScope);
        this.currentScope = [];
        return this.currentScope;
    }
    popHoistScope() {
        const scope = this.currentScope;
        this.currentScope = this.hoists.pop() ?? [];
        return scope;
    }
}

function createComponentChildrenTransform(_customContext) {
    return (node) => {
        if (!templateAstTypes.isComponentNode(node))
            return;
        const dir = compilerCore.findDir(node, 'slot', true);
        let hasSlotsAsChildren = false;
        if (dir == null &&
            node.children.some((node) => templateAstTypes.isTemplateNode(node) && compilerCore.findDir(node, 'slot', true) != null)) {
            hasSlotsAsChildren = true;
        }
        return () => {
            if (dir != null) {
                node.props = node.props.filter((prop) => prop !== dir);
                node.slots = [
                    {
                        name: dir.arg,
                        args: dir.exp,
                        hoists: node.hoists ?? [],
                        children: node.children,
                    },
                ];
            }
            else if (hasSlotsAsChildren) {
                node.slots = [];
                const slots = node.slots;
                node.unassignedSlots = node.children.filter((node) => {
                    if (templateAstTypes.isTemplateNode(node)) {
                        const dir = compilerCore.findDir(node, 'slot', true);
                        if (dir != null) {
                            const _if = compilerCore.findDir(node, 'if', true);
                            slots.push({
                                name: dir.arg,
                                args: dir.exp,
                                hoists: node.hoists ?? [],
                                children: _if == null ? node.children : [createIfNode(node, _if)],
                                template: node,
                            });
                            return false;
                        }
                    }
                    return true;
                });
            }
            else {
                node.slots = [
                    {
                        hoists: node.hoists ?? [],
                        children: node.children,
                    },
                ];
            }
        };
    };
}
function createIfNode(node, dir) {
    return {
        type: templateAstTypes.NodeTypes.IF,
        branches: [createIfBranchNode(node, dir)],
        loc: node.loc,
        scope: node.scope,
    };
}
function createIfBranchNode(node, dir) {
    return {
        type: templateAstTypes.NodeTypes.IF_BRANCH,
        children: node.children,
        condition: dir.exp,
        loc: node.loc,
        scope: node.scope,
    };
}

function createTransformIf(_customContext) {
    return compilerCore.createStructuralDirectiveTransform(/^(if|else-if|else)$/, (node, dir, context) => {
        const condition = dir.exp;
        dir.exp = (condition != null
            ? { ...condition }
            : templateAstTypes.createSimpleExpression('undefined', false)); // Prevent condition normalization
        return compilerCore.processIf(node, dir, context, (_ifNode, branch) => () => {
            branch.condition = condition;
        });
    });
}

const directives = new Set('text,html,show,if,else,else-if,for,on,bind,model,slot,pre,cloak,once,is,memo'.split(','));

const s = (text) => JSON.stringify(text) + ' as const';
function createResolveComponentTransform(ctx) {
    const h = getRuntimeFn.bind(null, ctx.typeIdentifier);
    const resolveComponentArgs = `${ctx.isTypeScript
        ? `{} as unknown as ${ctx.internalIdentifierPrefix}GlobalComponents`
        : `/** @type {${ctx.internalIdentifierPrefix}GlobalComponents} */ (/** @type {unknown} */ ({}))`}, ${ctx.isTypeScript
        ? `{} as unknown as JSX.IntrinsicElements`
        : `/** @type JSX.IntrinsicElements} */ (/** @type {unknown} */ ({}))`}, ${ctx.contextIdentifier}, `;
    return (node) => {
        if (!templateAstTypes.isElementNode(node))
            return;
        if (templateAstTypes.isElementNode(node)) {
            node.props.forEach((node) => {
                if (templateAstTypes.isDirectiveNode(node) && !directives.has(node.name)) {
                    ctx.used.directives.add(node.name);
                    const id = `v${shared.pascalCase(node.name)}`;
                    node.resolvedName = id;
                    if (!ctx.scope.hasIdentifier(id)) {
                        const knownId = ctx.identifiers.get(id);
                        if (knownId == null) {
                            ctx.scope.addIdentifier(id);
                            ctx.scope.hoist(compilerCore.createCompoundExpression([
                                'const ',
                                id,
                                ` = ${h('resolveDirective')}(${ctx.contextIdentifier}, `,
                                s(node.name),
                                ', ',
                                s(shared.camelCase(node.name)),
                                ');',
                            ]));
                        }
                        else if (mayBeRef(knownId)) {
                            ctx.scope.addIdentifier(id);
                            ctx.scope.hoist(compilerCore.createCompoundExpression([
                                `const ${id} = ${ctx.internalIdentifierPrefix}_get_identifier_${id}();`,
                            ]));
                        }
                    }
                }
            });
        }
        let isProp = compilerCore.findDir(node, 'is');
        if (isProp != null) {
            node.tagType = 1;
            node.tag = 'component';
        }
        if (!templateAstTypes.isComponentNode(node))
            return;
        if (node.tag !== 'component') {
            if (/[A-Z.-]/.test(node.tag)) {
                ctx.used.components.add(node.tag);
                const name = node.tag.split('.')[0] ?? node.tag;
                const id = `${shared.pascalCase(name)}`;
                node.resolvedName = node.tag.includes('.')
                    ? id + node.tag.slice(name.length)
                    : id;
                if (!ctx.scope.hasIdentifier(id)) {
                    const knownId = ctx.identifiers.get(id);
                    if (knownId == null || !templateAstTypes.isSimpleIdentifier(id)) {
                        ctx.used.components.add(id);
                        ctx.scope.addIdentifier(id);
                        ctx.scope.hoist(compilerCore.createCompoundExpression([
                            'const ',
                            id,
                            ` = ${h('resolveComponent')}(${resolveComponentArgs}`,
                            templateAstTypes.isSimpleIdentifier(id)
                                ? `${ctx.internalIdentifierPrefix}_get_identifier_${id}()`
                                : 'null',
                            ', ',
                            s(name),
                            ', ',
                            s(shared.pascalCase(name)),
                            ');',
                        ]));
                    }
                    else if (mayBeRef(knownId)) {
                        ctx.used.components.add(id);
                        ctx.scope.addIdentifier(id);
                        ctx.scope.hoist(compilerCore.createCompoundExpression([
                            `const ${id} = ${ctx.internalIdentifierPrefix}_get_identifier_${id}();`,
                        ]));
                    }
                }
            }
            return undefined;
        }
        else {
            isProp = isProp ?? compilerCore.findProp(node, 'is');
            if (isProp != null)
                node.is = isProp;
            node.props = node.props.filter((prop) => prop !== isProp);
        }
        return undefined;
    };
}
function mayBeRef(id) {
    return (id.kind === 'ref' ||
        id.kind === 'maybeRef' ||
        id.kind === 'externalRef' ||
        id.kind === 'externalMaybeRef');
}

function createSlotHoistScopeTransform(context) {
    return (node) => {
        if (!templateAstTypes.isElementNode(node))
            return;
        const dir = compilerCore.findDir(node, 'slot', true);
        if (dir == null)
            return;
        node.hoists = context.scope.createNewHoistScope();
        return () => {
            node.hoists = context.scope.popHoistScope();
        };
    };
}

const namedCharacterReferences = {
    GT: '>',
    gt: '>',
    LT: '<',
    lt: '<',
    'ac;': '∾',
    'af;': '⁡',
    AMP: '&',
    amp: '&',
    'ap;': '≈',
    'DD;': 'ⅅ',
    'dd;': 'ⅆ',
    deg: '°',
    'ee;': 'ⅇ',
    'eg;': '⪚',
    'el;': '⪙',
    ETH: 'Ð',
    eth: 'ð',
    'gE;': '≧',
    'ge;': '≥',
    'Gg;': '⋙',
    'gg;': '≫',
    'gl;': '≷',
    'GT;': '>',
    'Gt;': '≫',
    'gt;': '>',
    'ic;': '⁣',
    'ii;': 'ⅈ',
    'Im;': 'ℑ',
    'in;': '∈',
    'it;': '⁢',
    'lE;': '≦',
    'le;': '≤',
    'lg;': '≶',
    'Ll;': '⋘',
    'll;': '≪',
    'LT;': '<',
    'Lt;': '≪',
    'lt;': '<',
    'mp;': '∓',
    'Mu;': 'Μ',
    'mu;': 'μ',
    'ne;': '≠',
    'ni;': '∋',
    not: '¬',
    'Nu;': 'Ν',
    'nu;': 'ν',
    'Or;': '⩔',
    'or;': '∨',
    'oS;': 'Ⓢ',
    'Pi;': 'Π',
    'pi;': 'π',
    'pm;': '±',
    'Pr;': '⪻',
    'pr;': '≺',
    'Re;': 'ℜ',
    REG: '®',
    reg: '®',
    'rx;': '℞',
    'Sc;': '⪼',
    'sc;': '≻',
    shy: '­',
    uml: '¨',
    'wp;': '℘',
    'wr;': '≀',
    'Xi;': 'Ξ',
    'xi;': 'ξ',
    yen: '¥',
    'acd;': '∿',
    'acE;': '∾̳',
    'Acy;': 'А',
    'acy;': 'а',
    'Afr;': '𝔄',
    'afr;': '𝔞',
    'AMP;': '&',
    'amp;': '&',
    'And;': '⩓',
    'and;': '∧',
    'ang;': '∠',
    'apE;': '⩰',
    'ape;': '≊',
    'ast;': '*',
    Auml: 'Ä',
    auml: 'ä',
    'Bcy;': 'Б',
    'bcy;': 'б',
    'Bfr;': '𝔅',
    'bfr;': '𝔟',
    'bne;': '=⃥',
    'bot;': '⊥',
    'Cap;': '⋒',
    'cap;': '∩',
    cent: '¢',
    'Cfr;': 'ℭ',
    'cfr;': '𝔠',
    'Chi;': 'Χ',
    'chi;': 'χ',
    'cir;': '○',
    COPY: '©',
    copy: '©',
    'Cup;': '⋓',
    'cup;': '∪',
    'Dcy;': 'Д',
    'dcy;': 'д',
    'deg;': '°',
    'Del;': '∇',
    'Dfr;': '𝔇',
    'dfr;': '𝔡',
    'die;': '¨',
    'div;': '÷',
    'Dot;': '¨',
    'dot;': '˙',
    'Ecy;': 'Э',
    'ecy;': 'э',
    'Efr;': '𝔈',
    'efr;': '𝔢',
    'egs;': '⪖',
    'ell;': 'ℓ',
    'els;': '⪕',
    'ENG;': 'Ŋ',
    'eng;': 'ŋ',
    'Eta;': 'Η',
    'eta;': 'η',
    'ETH;': 'Ð',
    'eth;': 'ð',
    Euml: 'Ë',
    euml: 'ë',
    'Fcy;': 'Ф',
    'fcy;': 'ф',
    'Ffr;': '𝔉',
    'ffr;': '𝔣',
    'gap;': '⪆',
    'Gcy;': 'Г',
    'gcy;': 'г',
    'gEl;': '⪌',
    'gel;': '⋛',
    'geq;': '≥',
    'ges;': '⩾',
    'Gfr;': '𝔊',
    'gfr;': '𝔤',
    'ggg;': '⋙',
    'gla;': '⪥',
    'glE;': '⪒',
    'glj;': '⪤',
    'gnE;': '≩',
    'gne;': '⪈',
    'Hat;': '^',
    'Hfr;': 'ℌ',
    'hfr;': '𝔥',
    'Icy;': 'И',
    'icy;': 'и',
    'iff;': '⇔',
    'Ifr;': 'ℑ',
    'ifr;': '𝔦',
    'Int;': '∬',
    'int;': '∫',
    Iuml: 'Ï',
    iuml: 'ï',
    'Jcy;': 'Й',
    'jcy;': 'й',
    'Jfr;': '𝔍',
    'jfr;': '𝔧',
    'Kcy;': 'К',
    'kcy;': 'к',
    'Kfr;': '𝔎',
    'kfr;': '𝔨',
    'lap;': '⪅',
    'lat;': '⪫',
    'Lcy;': 'Л',
    'lcy;': 'л',
    'lEg;': '⪋',
    'leg;': '⋚',
    'leq;': '≤',
    'les;': '⩽',
    'Lfr;': '𝔏',
    'lfr;': '𝔩',
    'lgE;': '⪑',
    'lnE;': '≨',
    'lne;': '⪇',
    'loz;': '◊',
    'lrm;': '‎',
    'Lsh;': '↰',
    'lsh;': '↰',
    macr: '¯',
    'Map;': '⤅',
    'map;': '↦',
    'Mcy;': 'М',
    'mcy;': 'м',
    'Mfr;': '𝔐',
    'mfr;': '𝔪',
    'mho;': '℧',
    'mid;': '∣',
    'nap;': '≉',
    nbsp: ' ',
    'Ncy;': 'Н',
    'ncy;': 'н',
    'Nfr;': '𝔑',
    'nfr;': '𝔫',
    'ngE;': '≧̸',
    'nge;': '≱',
    'nGg;': '⋙̸',
    'nGt;': '≫⃒',
    'ngt;': '≯',
    'nis;': '⋼',
    'niv;': '∋',
    'nlE;': '≦̸',
    'nle;': '≰',
    'nLl;': '⋘̸',
    'nLt;': '≪⃒',
    'nlt;': '≮',
    'Not;': '⫬',
    'not;': '¬',
    'npr;': '⊀',
    'nsc;': '⊁',
    'num;': '#',
    'Ocy;': 'О',
    'ocy;': 'о',
    'Ofr;': '𝔒',
    'ofr;': '𝔬',
    'ogt;': '⧁',
    'ohm;': 'Ω',
    'olt;': '⧀',
    'ord;': '⩝',
    ordf: 'ª',
    ordm: 'º',
    'orv;': '⩛',
    Ouml: 'Ö',
    ouml: 'ö',
    'par;': '∥',
    para: '¶',
    'Pcy;': 'П',
    'pcy;': 'п',
    'Pfr;': '𝔓',
    'pfr;': '𝔭',
    'Phi;': 'Φ',
    'phi;': 'φ',
    'piv;': 'ϖ',
    'prE;': '⪳',
    'pre;': '⪯',
    'Psi;': 'Ψ',
    'psi;': 'ψ',
    'Qfr;': '𝔔',
    'qfr;': '𝔮',
    QUOT: '"',
    quot: '"',
    'Rcy;': 'Р',
    'rcy;': 'р',
    'REG;': '®',
    'reg;': '®',
    'Rfr;': 'ℜ',
    'rfr;': '𝔯',
    'Rho;': 'Ρ',
    'rho;': 'ρ',
    'rlm;': '‏',
    'Rsh;': '↱',
    'rsh;': '↱',
    'scE;': '⪴',
    'sce;': '⪰',
    'Scy;': 'С',
    'scy;': 'с',
    sect: '§',
    'Sfr;': '𝔖',
    'sfr;': '𝔰',
    'shy;': '­',
    'sim;': '∼',
    'smt;': '⪪',
    'sol;': '/',
    'squ;': '□',
    'Sub;': '⋐',
    'sub;': '⊂',
    'Sum;': '∑',
    'sum;': '∑',
    'Sup;': '⋑',
    'sup;': '⊃',
    sup1: '¹',
    sup2: '²',
    sup3: '³',
    'Tab;': '\t',
    'Tau;': 'Τ',
    'tau;': 'τ',
    'Tcy;': 'Т',
    'tcy;': 'т',
    'Tfr;': '𝔗',
    'tfr;': '𝔱',
    'top;': '⊤',
    'Ucy;': 'У',
    'ucy;': 'у',
    'Ufr;': '𝔘',
    'ufr;': '𝔲',
    'uml;': '¨',
    Uuml: 'Ü',
    uuml: 'ü',
    'Vcy;': 'В',
    'vcy;': 'в',
    'Vee;': '⋁',
    'vee;': '∨',
    'Vfr;': '𝔙',
    'vfr;': '𝔳',
    'Wfr;': '𝔚',
    'wfr;': '𝔴',
    'Xfr;': '𝔛',
    'xfr;': '𝔵',
    'Ycy;': 'Ы',
    'ycy;': 'ы',
    'yen;': '¥',
    'Yfr;': '𝔜',
    'yfr;': '𝔶',
    yuml: 'ÿ',
    'Zcy;': 'З',
    'zcy;': 'з',
    'Zfr;': 'ℨ',
    'zfr;': '𝔷',
    'zwj;': '‍',
    Acirc: 'Â',
    acirc: 'â',
    acute: '´',
    AElig: 'Æ',
    aelig: 'æ',
    'andd;': '⩜',
    'andv;': '⩚',
    'ange;': '⦤',
    'Aopf;': '𝔸',
    'aopf;': '𝕒',
    'apid;': '≋',
    'apos;': "'",
    Aring: 'Å',
    aring: 'å',
    'Ascr;': '𝒜',
    'ascr;': '𝒶',
    'Auml;': 'Ä',
    'auml;': 'ä',
    'Barv;': '⫧',
    'bbrk;': '⎵',
    'Beta;': 'Β',
    'beta;': 'β',
    'beth;': 'ℶ',
    'bNot;': '⫭',
    'bnot;': '⌐',
    'Bopf;': '𝔹',
    'bopf;': '𝕓',
    'boxH;': '═',
    'boxh;': '─',
    'boxV;': '║',
    'boxv;': '│',
    'Bscr;': 'ℬ',
    'bscr;': '𝒷',
    'bsim;': '∽',
    'bsol;': '\\',
    'bull;': '•',
    'bump;': '≎',
    'caps;': '∩︀',
    'Cdot;': 'Ċ',
    'cdot;': 'ċ',
    cedil: '¸',
    'cent;': '¢',
    'CHcy;': 'Ч',
    'chcy;': 'ч',
    'circ;': 'ˆ',
    'cirE;': '⧃',
    'cire;': '≗',
    'comp;': '∁',
    'cong;': '≅',
    'Copf;': 'ℂ',
    'copf;': '𝕔',
    'COPY;': '©',
    'copy;': '©',
    'Cscr;': '𝒞',
    'cscr;': '𝒸',
    'csub;': '⫏',
    'csup;': '⫐',
    'cups;': '∪︀',
    'Darr;': '↡',
    'dArr;': '⇓',
    'darr;': '↓',
    'dash;': '‐',
    'dHar;': '⥥',
    'diam;': '⋄',
    'DJcy;': 'Ђ',
    'djcy;': 'ђ',
    'Dopf;': '𝔻',
    'dopf;': '𝕕',
    'Dscr;': '𝒟',
    'dscr;': '𝒹',
    'DScy;': 'Ѕ',
    'dscy;': 'ѕ',
    'dsol;': '⧶',
    'dtri;': '▿',
    'DZcy;': 'Џ',
    'dzcy;': 'џ',
    'ecir;': '≖',
    Ecirc: 'Ê',
    ecirc: 'ê',
    'Edot;': 'Ė',
    'eDot;': '≑',
    'edot;': 'ė',
    'emsp;': ' ',
    'ensp;': ' ',
    'Eopf;': '𝔼',
    'eopf;': '𝕖',
    'epar;': '⋕',
    'epsi;': 'ε',
    'Escr;': 'ℰ',
    'escr;': 'ℯ',
    'Esim;': '⩳',
    'esim;': '≂',
    'Euml;': 'Ë',
    'euml;': 'ë',
    'euro;': '€',
    'excl;': '!',
    'flat;': '♭',
    'fnof;': 'ƒ',
    'Fopf;': '𝔽',
    'fopf;': '𝕗',
    'fork;': '⋔',
    'Fscr;': 'ℱ',
    'fscr;': '𝒻',
    'Gdot;': 'Ġ',
    'gdot;': 'ġ',
    'geqq;': '≧',
    'gesl;': '⋛︀',
    'GJcy;': 'Ѓ',
    'gjcy;': 'ѓ',
    'gnap;': '⪊',
    'gneq;': '⪈',
    'Gopf;': '𝔾',
    'gopf;': '𝕘',
    'Gscr;': '𝒢',
    'gscr;': 'ℊ',
    'gsim;': '≳',
    'gtcc;': '⪧',
    'gvnE;': '≩︀',
    'half;': '½',
    'hArr;': '⇔',
    'harr;': '↔',
    'hbar;': 'ℏ',
    'Hopf;': 'ℍ',
    'hopf;': '𝕙',
    'Hscr;': 'ℋ',
    'hscr;': '𝒽',
    Icirc: 'Î',
    icirc: 'î',
    'Idot;': 'İ',
    'IEcy;': 'Е',
    'iecy;': 'е',
    iexcl: '¡',
    'imof;': '⊷',
    'IOcy;': 'Ё',
    'iocy;': 'ё',
    'Iopf;': '𝕀',
    'iopf;': '𝕚',
    'Iota;': 'Ι',
    'iota;': 'ι',
    'Iscr;': 'ℐ',
    'iscr;': '𝒾',
    'isin;': '∈',
    'Iuml;': 'Ï',
    'iuml;': 'ï',
    'Jopf;': '𝕁',
    'jopf;': '𝕛',
    'Jscr;': '𝒥',
    'jscr;': '𝒿',
    'KHcy;': 'Х',
    'khcy;': 'х',
    'KJcy;': 'Ќ',
    'kjcy;': 'ќ',
    'Kopf;': '𝕂',
    'kopf;': '𝕜',
    'Kscr;': '𝒦',
    'kscr;': '𝓀',
    'Lang;': '⟪',
    'lang;': '⟨',
    laquo: '«',
    'Larr;': '↞',
    'lArr;': '⇐',
    'larr;': '←',
    'late;': '⪭',
    'lcub;': '{',
    'ldca;': '⤶',
    'ldsh;': '↲',
    'leqq;': '≦',
    'lesg;': '⋚︀',
    'lHar;': '⥢',
    'LJcy;': 'Љ',
    'ljcy;': 'љ',
    'lnap;': '⪉',
    'lneq;': '⪇',
    'Lopf;': '𝕃',
    'lopf;': '𝕝',
    'lozf;': '⧫',
    'lpar;': '(',
    'Lscr;': 'ℒ',
    'lscr;': '𝓁',
    'lsim;': '≲',
    'lsqb;': '[',
    'ltcc;': '⪦',
    'ltri;': '◃',
    'lvnE;': '≨︀',
    'macr;': '¯',
    'male;': '♂',
    'malt;': '✠',
    micro: 'µ',
    'mlcp;': '⫛',
    'mldr;': '…',
    'Mopf;': '𝕄',
    'mopf;': '𝕞',
    'Mscr;': 'ℳ',
    'mscr;': '𝓂',
    'nang;': '∠⃒',
    'napE;': '⩰̸',
    'nbsp;': ' ',
    'ncap;': '⩃',
    'ncup;': '⩂',
    'ngeq;': '≱',
    'nges;': '⩾̸',
    'ngtr;': '≯',
    'nGtv;': '≫̸',
    'nisd;': '⋺',
    'NJcy;': 'Њ',
    'njcy;': 'њ',
    'nldr;': '‥',
    'nleq;': '≰',
    'nles;': '⩽̸',
    'nLtv;': '≪̸',
    'nmid;': '∤',
    'Nopf;': 'ℕ',
    'nopf;': '𝕟',
    'npar;': '∦',
    'npre;': '⪯̸',
    'nsce;': '⪰̸',
    'Nscr;': '𝒩',
    'nscr;': '𝓃',
    'nsim;': '≁',
    'nsub;': '⊄',
    'nsup;': '⊅',
    'ntgl;': '≹',
    'ntlg;': '≸',
    'nvap;': '≍⃒',
    'nvge;': '≥⃒',
    'nvgt;': '>⃒',
    'nvle;': '≤⃒',
    'nvlt;': '<⃒',
    'oast;': '⊛',
    'ocir;': '⊚',
    Ocirc: 'Ô',
    ocirc: 'ô',
    'odiv;': '⨸',
    'odot;': '⊙',
    'ogon;': '˛',
    'oint;': '∮',
    'omid;': '⦶',
    'Oopf;': '𝕆',
    'oopf;': '𝕠',
    'opar;': '⦷',
    'ordf;': 'ª',
    'ordm;': 'º',
    'oror;': '⩖',
    'Oscr;': '𝒪',
    'oscr;': 'ℴ',
    'osol;': '⊘',
    'Ouml;': 'Ö',
    'ouml;': 'ö',
    'para;': '¶',
    'part;': '∂',
    'perp;': '⊥',
    'phiv;': 'ϕ',
    'plus;': '+',
    'Popf;': 'ℙ',
    'popf;': '𝕡',
    pound: '£',
    'prap;': '⪷',
    'prec;': '≺',
    'prnE;': '⪵',
    'prod;': '∏',
    'prop;': '∝',
    'Pscr;': '𝒫',
    'pscr;': '𝓅',
    'qint;': '⨌',
    'Qopf;': 'ℚ',
    'qopf;': '𝕢',
    'Qscr;': '𝒬',
    'qscr;': '𝓆',
    'QUOT;': '"',
    'quot;': '"',
    'race;': '∽̱',
    'Rang;': '⟫',
    'rang;': '⟩',
    raquo: '»',
    'Rarr;': '↠',
    'rArr;': '⇒',
    'rarr;': '→',
    'rcub;': '}',
    'rdca;': '⤷',
    'rdsh;': '↳',
    'real;': 'ℜ',
    'rect;': '▭',
    'rHar;': '⥤',
    'rhov;': 'ϱ',
    'ring;': '˚',
    'Ropf;': 'ℝ',
    'ropf;': '𝕣',
    'rpar;': ')',
    'Rscr;': 'ℛ',
    'rscr;': '𝓇',
    'rsqb;': ']',
    'rtri;': '▹',
    'scap;': '⪸',
    'scnE;': '⪶',
    'sdot;': '⋅',
    'sect;': '§',
    'semi;': ';',
    'sext;': '✶',
    'SHcy;': 'Ш',
    'shcy;': 'ш',
    'sime;': '≃',
    'simg;': '⪞',
    'siml;': '⪝',
    'smid;': '∣',
    'smte;': '⪬',
    'solb;': '⧄',
    'Sopf;': '𝕊',
    'sopf;': '𝕤',
    'spar;': '∥',
    'Sqrt;': '√',
    'squf;': '▪',
    'Sscr;': '𝒮',
    'sscr;': '𝓈',
    'Star;': '⋆',
    'star;': '☆',
    'subE;': '⫅',
    'sube;': '⊆',
    'succ;': '≻',
    'sung;': '♪',
    'sup1;': '¹',
    'sup2;': '²',
    'sup3;': '³',
    'supE;': '⫆',
    'supe;': '⊇',
    szlig: 'ß',
    'tbrk;': '⎴',
    'tdot;': '⃛',
    THORN: 'Þ',
    thorn: 'þ',
    times: '×',
    'tint;': '∭',
    'toea;': '⤨',
    'Topf;': '𝕋',
    'topf;': '𝕥',
    'tosa;': '⤩',
    'trie;': '≜',
    'Tscr;': '𝒯',
    'tscr;': '𝓉',
    'TScy;': 'Ц',
    'tscy;': 'ц',
    'Uarr;': '↟',
    'uArr;': '⇑',
    'uarr;': '↑',
    Ucirc: 'Û',
    ucirc: 'û',
    'uHar;': '⥣',
    'Uopf;': '𝕌',
    'uopf;': '𝕦',
    'Upsi;': 'ϒ',
    'upsi;': 'υ',
    'Uscr;': '𝒰',
    'uscr;': '𝓊',
    'utri;': '▵',
    'Uuml;': 'Ü',
    'uuml;': 'ü',
    'vArr;': '⇕',
    'varr;': '↕',
    'Vbar;': '⫫',
    'vBar;': '⫨',
    'Vert;': '‖',
    'vert;': '|',
    'Vopf;': '𝕍',
    'vopf;': '𝕧',
    'Vscr;': '𝒱',
    'vscr;': '𝓋',
    'Wopf;': '𝕎',
    'wopf;': '𝕨',
    'Wscr;': '𝒲',
    'wscr;': '𝓌',
    'xcap;': '⋂',
    'xcup;': '⋃',
    'xmap;': '⟼',
    'xnis;': '⋻',
    'Xopf;': '𝕏',
    'xopf;': '𝕩',
    'Xscr;': '𝒳',
    'xscr;': '𝓍',
    'xvee;': '⋁',
    'YAcy;': 'Я',
    'yacy;': 'я',
    'YIcy;': 'Ї',
    'yicy;': 'ї',
    'Yopf;': '𝕐',
    'yopf;': '𝕪',
    'Yscr;': '𝒴',
    'yscr;': '𝓎',
    'YUcy;': 'Ю',
    'yucy;': 'ю',
    'Yuml;': 'Ÿ',
    'yuml;': 'ÿ',
    'Zdot;': 'Ż',
    'zdot;': 'ż',
    'Zeta;': 'Ζ',
    'zeta;': 'ζ',
    'ZHcy;': 'Ж',
    'zhcy;': 'ж',
    'Zopf;': 'ℤ',
    'zopf;': '𝕫',
    'Zscr;': '𝒵',
    'zscr;': '𝓏',
    'zwnj;': '‌',
    Aacute: 'Á',
    aacute: 'á',
    'Acirc;': 'Â',
    'acirc;': 'â',
    'acute;': '´',
    'AElig;': 'Æ',
    'aelig;': 'æ',
    Agrave: 'À',
    agrave: 'à',
    'aleph;': 'ℵ',
    'Alpha;': 'Α',
    'alpha;': 'α',
    'Amacr;': 'Ā',
    'amacr;': 'ā',
    'amalg;': '⨿',
    'angle;': '∠',
    'angrt;': '∟',
    'angst;': 'Å',
    'Aogon;': 'Ą',
    'aogon;': 'ą',
    'Aring;': 'Å',
    'aring;': 'å',
    'asymp;': '≈',
    Atilde: 'Ã',
    atilde: 'ã',
    'awint;': '⨑',
    'bcong;': '≌',
    'bdquo;': '„',
    'bepsi;': '϶',
    'blank;': '␣',
    'blk12;': '▒',
    'blk14;': '░',
    'blk34;': '▓',
    'block;': '█',
    'boxDL;': '╗',
    'boxDl;': '╖',
    'boxdL;': '╕',
    'boxdl;': '┐',
    'boxDR;': '╔',
    'boxDr;': '╓',
    'boxdR;': '╒',
    'boxdr;': '┌',
    'boxHD;': '╦',
    'boxHd;': '╤',
    'boxhD;': '╥',
    'boxhd;': '┬',
    'boxHU;': '╩',
    'boxHu;': '╧',
    'boxhU;': '╨',
    'boxhu;': '┴',
    'boxUL;': '╝',
    'boxUl;': '╜',
    'boxuL;': '╛',
    'boxul;': '┘',
    'boxUR;': '╚',
    'boxUr;': '╙',
    'boxuR;': '╘',
    'boxur;': '└',
    'boxVH;': '╬',
    'boxVh;': '╫',
    'boxvH;': '╪',
    'boxvh;': '┼',
    'boxVL;': '╣',
    'boxVl;': '╢',
    'boxvL;': '╡',
    'boxvl;': '┤',
    'boxVR;': '╠',
    'boxVr;': '╟',
    'boxvR;': '╞',
    'boxvr;': '├',
    'Breve;': '˘',
    'breve;': '˘',
    brvbar: '¦',
    'bsemi;': '⁏',
    'bsime;': '⋍',
    'bsolb;': '⧅',
    'bumpE;': '⪮',
    'bumpe;': '≏',
    'caret;': '⁁',
    'caron;': 'ˇ',
    'ccaps;': '⩍',
    Ccedil: 'Ç',
    ccedil: 'ç',
    'Ccirc;': 'Ĉ',
    'ccirc;': 'ĉ',
    'ccups;': '⩌',
    'cedil;': '¸',
    'check;': '✓',
    'clubs;': '♣',
    'Colon;': '∷',
    'colon;': ':',
    'comma;': ',',
    'crarr;': '↵',
    'Cross;': '⨯',
    'cross;': '✗',
    'csube;': '⫑',
    'csupe;': '⫒',
    'ctdot;': '⋯',
    'cuepr;': '⋞',
    'cuesc;': '⋟',
    'cupor;': '⩅',
    curren: '¤',
    'cuvee;': '⋎',
    'cuwed;': '⋏',
    'cwint;': '∱',
    'Dashv;': '⫤',
    'dashv;': '⊣',
    'dblac;': '˝',
    'ddarr;': '⇊',
    'Delta;': 'Δ',
    'delta;': 'δ',
    'dharl;': '⇃',
    'dharr;': '⇂',
    'diams;': '♦',
    'disin;': '⋲',
    divide: '÷',
    'doteq;': '≐',
    'dtdot;': '⋱',
    'dtrif;': '▾',
    'duarr;': '⇵',
    'duhar;': '⥯',
    Eacute: 'É',
    eacute: 'é',
    'Ecirc;': 'Ê',
    'ecirc;': 'ê',
    'eDDot;': '⩷',
    'efDot;': '≒',
    Egrave: 'È',
    egrave: 'è',
    'Emacr;': 'Ē',
    'emacr;': 'ē',
    'empty;': '∅',
    'Eogon;': 'Ę',
    'eogon;': 'ę',
    'eplus;': '⩱',
    'epsiv;': 'ϵ',
    'eqsim;': '≂',
    'Equal;': '⩵',
    'equiv;': '≡',
    'erarr;': '⥱',
    'erDot;': '≓',
    'esdot;': '≐',
    'exist;': '∃',
    'fflig;': 'ﬀ',
    'filig;': 'ﬁ',
    'fjlig;': 'fj',
    'fllig;': 'ﬂ',
    'fltns;': '▱',
    'forkv;': '⫙',
    frac12: '½',
    frac14: '¼',
    frac34: '¾',
    'frasl;': '⁄',
    'frown;': '⌢',
    'Gamma;': 'Γ',
    'gamma;': 'γ',
    'Gcirc;': 'Ĝ',
    'gcirc;': 'ĝ',
    'gescc;': '⪩',
    'gimel;': 'ℷ',
    'gneqq;': '≩',
    'gnsim;': '⋧',
    'grave;': '`',
    'gsime;': '⪎',
    'gsiml;': '⪐',
    'gtcir;': '⩺',
    'gtdot;': '⋗',
    'Hacek;': 'ˇ',
    'harrw;': '↭',
    'Hcirc;': 'Ĥ',
    'hcirc;': 'ĥ',
    'hoarr;': '⇿',
    Iacute: 'Í',
    iacute: 'í',
    'Icirc;': 'Î',
    'icirc;': 'î',
    'iexcl;': '¡',
    Igrave: 'Ì',
    igrave: 'ì',
    'iiint;': '∭',
    'iiota;': '℩',
    'IJlig;': 'Ĳ',
    'ijlig;': 'ĳ',
    'Imacr;': 'Ī',
    'imacr;': 'ī',
    'image;': 'ℑ',
    'imath;': 'ı',
    'imped;': 'Ƶ',
    'infin;': '∞',
    'Iogon;': 'Į',
    'iogon;': 'į',
    'iprod;': '⨼',
    iquest: '¿',
    'isinE;': '⋹',
    'isins;': '⋴',
    'isinv;': '∈',
    'Iukcy;': 'І',
    'iukcy;': 'і',
    'Jcirc;': 'Ĵ',
    'jcirc;': 'ĵ',
    'jmath;': 'ȷ',
    'Jukcy;': 'Є',
    'jukcy;': 'є',
    'Kappa;': 'Κ',
    'kappa;': 'κ',
    'lAarr;': '⇚',
    'langd;': '⦑',
    'laquo;': '«',
    'larrb;': '⇤',
    'lates;': '⪭︀',
    'lBarr;': '⤎',
    'lbarr;': '⤌',
    'lbbrk;': '❲',
    'lbrke;': '⦋',
    'lceil;': '⌈',
    'ldquo;': '“',
    'lescc;': '⪨',
    'lhard;': '↽',
    'lharu;': '↼',
    'lhblk;': '▄',
    'llarr;': '⇇',
    'lltri;': '◺',
    'lneqq;': '≨',
    'lnsim;': '⋦',
    'loang;': '⟬',
    'loarr;': '⇽',
    'lobrk;': '⟦',
    'lopar;': '⦅',
    'lrarr;': '⇆',
    'lrhar;': '⇋',
    'lrtri;': '⊿',
    'lsime;': '⪍',
    'lsimg;': '⪏',
    'lsquo;': '‘',
    'ltcir;': '⩹',
    'ltdot;': '⋖',
    'ltrie;': '⊴',
    'ltrif;': '◂',
    'mdash;': '—',
    'mDDot;': '∺',
    'micro;': 'µ',
    middot: '·',
    'minus;': '−',
    'mumap;': '⊸',
    'nabla;': '∇',
    'napid;': '≋̸',
    'napos;': 'ŉ',
    'natur;': '♮',
    'nbump;': '≎̸',
    'ncong;': '≇',
    'ndash;': '–',
    'neArr;': '⇗',
    'nearr;': '↗',
    'nedot;': '≐̸',
    'nesim;': '≂̸',
    'ngeqq;': '≧̸',
    'ngsim;': '≵',
    'nhArr;': '⇎',
    'nharr;': '↮',
    'nhpar;': '⫲',
    'nlArr;': '⇍',
    'nlarr;': '↚',
    'nleqq;': '≦̸',
    'nless;': '≮',
    'nlsim;': '≴',
    'nltri;': '⋪',
    'notin;': '∉',
    'notni;': '∌',
    'npart;': '∂̸',
    'nprec;': '⊀',
    'nrArr;': '⇏',
    'nrarr;': '↛',
    'nrtri;': '⋫',
    'nsime;': '≄',
    'nsmid;': '∤',
    'nspar;': '∦',
    'nsubE;': '⫅̸',
    'nsube;': '⊈',
    'nsucc;': '⊁',
    'nsupE;': '⫆̸',
    'nsupe;': '⊉',
    Ntilde: 'Ñ',
    ntilde: 'ñ',
    'numsp;': ' ',
    'nvsim;': '∼⃒',
    'nwArr;': '⇖',
    'nwarr;': '↖',
    Oacute: 'Ó',
    oacute: 'ó',
    'Ocirc;': 'Ô',
    'ocirc;': 'ô',
    'odash;': '⊝',
    'OElig;': 'Œ',
    'oelig;': 'œ',
    'ofcir;': '⦿',
    Ograve: 'Ò',
    ograve: 'ò',
    'ohbar;': '⦵',
    'olarr;': '↺',
    'olcir;': '⦾',
    'oline;': '‾',
    'Omacr;': 'Ō',
    'omacr;': 'ō',
    'Omega;': 'Ω',
    'omega;': 'ω',
    'operp;': '⦹',
    'oplus;': '⊕',
    'orarr;': '↻',
    'order;': 'ℴ',
    Oslash: 'Ø',
    oslash: 'ø',
    Otilde: 'Õ',
    otilde: 'õ',
    'ovbar;': '⌽',
    'parsl;': '⫽',
    'phone;': '☎',
    'plusb;': '⊞',
    'pluse;': '⩲',
    plusmn: '±',
    'pound;': '£',
    'prcue;': '≼',
    'Prime;': '″',
    'prime;': '′',
    'prnap;': '⪹',
    'prsim;': '≾',
    'quest;': '?',
    'rAarr;': '⇛',
    'radic;': '√',
    'rangd;': '⦒',
    'range;': '⦥',
    'raquo;': '»',
    'rarrb;': '⇥',
    'rarrc;': '⤳',
    'rarrw;': '↝',
    'ratio;': '∶',
    'RBarr;': '⤐',
    'rBarr;': '⤏',
    'rbarr;': '⤍',
    'rbbrk;': '❳',
    'rbrke;': '⦌',
    'rceil;': '⌉',
    'rdquo;': '”',
    'reals;': 'ℝ',
    'rhard;': '⇁',
    'rharu;': '⇀',
    'rlarr;': '⇄',
    'rlhar;': '⇌',
    'rnmid;': '⫮',
    'roang;': '⟭',
    'roarr;': '⇾',
    'robrk;': '⟧',
    'ropar;': '⦆',
    'rrarr;': '⇉',
    'rsquo;': '’',
    'rtrie;': '⊵',
    'rtrif;': '▸',
    'sbquo;': '‚',
    'sccue;': '≽',
    'Scirc;': 'Ŝ',
    'scirc;': 'ŝ',
    'scnap;': '⪺',
    'scsim;': '≿',
    'sdotb;': '⊡',
    'sdote;': '⩦',
    'seArr;': '⇘',
    'searr;': '↘',
    'setmn;': '∖',
    'sharp;': '♯',
    'Sigma;': 'Σ',
    'sigma;': 'σ',
    'simeq;': '≃',
    'simgE;': '⪠',
    'simlE;': '⪟',
    'simne;': '≆',
    'slarr;': '←',
    'smile;': '⌣',
    'smtes;': '⪬︀',
    'sqcap;': '⊓',
    'sqcup;': '⊔',
    'sqsub;': '⊏',
    'sqsup;': '⊐',
    'srarr;': '→',
    'starf;': '★',
    'strns;': '¯',
    'subnE;': '⫋',
    'subne;': '⊊',
    'supnE;': '⫌',
    'supne;': '⊋',
    'swArr;': '⇙',
    'swarr;': '↙',
    'szlig;': 'ß',
    'Theta;': 'Θ',
    'theta;': 'θ',
    'thkap;': '≈',
    'THORN;': 'Þ',
    'thorn;': 'þ',
    'Tilde;': '∼',
    'tilde;': '˜',
    'times;': '×',
    'TRADE;': '™',
    'trade;': '™',
    'trisb;': '⧍',
    'TSHcy;': 'Ћ',
    'tshcy;': 'ћ',
    'twixt;': '≬',
    Uacute: 'Ú',
    uacute: 'ú',
    'Ubrcy;': 'Ў',
    'ubrcy;': 'ў',
    'Ucirc;': 'Û',
    'ucirc;': 'û',
    'udarr;': '⇅',
    'udhar;': '⥮',
    Ugrave: 'Ù',
    ugrave: 'ù',
    'uharl;': '↿',
    'uharr;': '↾',
    'uhblk;': '▀',
    'ultri;': '◸',
    'Umacr;': 'Ū',
    'umacr;': 'ū',
    'Union;': '⋃',
    'Uogon;': 'Ų',
    'uogon;': 'ų',
    'uplus;': '⊎',
    'upsih;': 'ϒ',
    'UpTee;': '⊥',
    'Uring;': 'Ů',
    'uring;': 'ů',
    'urtri;': '◹',
    'utdot;': '⋰',
    'utrif;': '▴',
    'uuarr;': '⇈',
    'varpi;': 'ϖ',
    'vBarv;': '⫩',
    'VDash;': '⊫',
    'Vdash;': '⊩',
    'vDash;': '⊨',
    'vdash;': '⊢',
    'veeeq;': '≚',
    'vltri;': '⊲',
    'vnsub;': '⊂⃒',
    'vnsup;': '⊃⃒',
    'vprop;': '∝',
    'vrtri;': '⊳',
    'Wcirc;': 'Ŵ',
    'wcirc;': 'ŵ',
    'Wedge;': '⋀',
    'wedge;': '∧',
    'xcirc;': '◯',
    'xdtri;': '▽',
    'xhArr;': '⟺',
    'xharr;': '⟷',
    'xlArr;': '⟸',
    'xlarr;': '⟵',
    'xodot;': '⨀',
    'xrArr;': '⟹',
    'xrarr;': '⟶',
    'xutri;': '△',
    Yacute: 'Ý',
    yacute: 'ý',
    'Ycirc;': 'Ŷ',
    'ycirc;': 'ŷ',
    'Aacute;': 'Á',
    'aacute;': 'á',
    'Abreve;': 'Ă',
    'abreve;': 'ă',
    'Agrave;': 'À',
    'agrave;': 'à',
    'andand;': '⩕',
    'angmsd;': '∡',
    'angsph;': '∢',
    'apacir;': '⩯',
    'approx;': '≈',
    'Assign;': '≔',
    'Atilde;': 'Ã',
    'atilde;': 'ã',
    'barvee;': '⊽',
    'Barwed;': '⌆',
    'barwed;': '⌅',
    'becaus;': '∵',
    'bernou;': 'ℬ',
    'bigcap;': '⋂',
    'bigcup;': '⋃',
    'bigvee;': '⋁',
    'bkarow;': '⤍',
    'bottom;': '⊥',
    'bowtie;': '⋈',
    'boxbox;': '⧉',
    'bprime;': '‵',
    'brvbar;': '¦',
    'bullet;': '•',
    'Bumpeq;': '≎',
    'bumpeq;': '≏',
    'Cacute;': 'Ć',
    'cacute;': 'ć',
    'capand;': '⩄',
    'capcap;': '⩋',
    'capcup;': '⩇',
    'capdot;': '⩀',
    'Ccaron;': 'Č',
    'ccaron;': 'č',
    'Ccedil;': 'Ç',
    'ccedil;': 'ç',
    'circeq;': '≗',
    'cirmid;': '⫯',
    'Colone;': '⩴',
    'colone;': '≔',
    'commat;': '@',
    'compfn;': '∘',
    'Conint;': '∯',
    'conint;': '∮',
    'coprod;': '∐',
    'copysr;': '℗',
    'cularr;': '↶',
    'CupCap;': '≍',
    'cupcap;': '⩆',
    'cupcup;': '⩊',
    'cupdot;': '⊍',
    'curarr;': '↷',
    'curren;': '¤',
    'cylcty;': '⌭',
    'Dagger;': '‡',
    'dagger;': '†',
    'daleth;': 'ℸ',
    'Dcaron;': 'Ď',
    'dcaron;': 'ď',
    'dfisht;': '⥿',
    'divide;': '÷',
    'divonx;': '⋇',
    'dlcorn;': '⌞',
    'dlcrop;': '⌍',
    'dollar;': '$',
    'DotDot;': '⃜',
    'drcorn;': '⌟',
    'drcrop;': '⌌',
    'Dstrok;': 'Đ',
    'dstrok;': 'đ',
    'Eacute;': 'É',
    'eacute;': 'é',
    'easter;': '⩮',
    'Ecaron;': 'Ě',
    'ecaron;': 'ě',
    'ecolon;': '≕',
    'Egrave;': 'È',
    'egrave;': 'è',
    'egsdot;': '⪘',
    'elsdot;': '⪗',
    'emptyv;': '∅',
    'emsp13;': ' ',
    'emsp14;': ' ',
    'eparsl;': '⧣',
    'eqcirc;': '≖',
    'equals;': '=',
    'equest;': '≟',
    'Exists;': '∃',
    'female;': '♀',
    'ffilig;': 'ﬃ',
    'ffllig;': 'ﬄ',
    'ForAll;': '∀',
    'forall;': '∀',
    'frac12;': '½',
    'frac13;': '⅓',
    'frac14;': '¼',
    'frac15;': '⅕',
    'frac16;': '⅙',
    'frac18;': '⅛',
    'frac23;': '⅔',
    'frac25;': '⅖',
    'frac34;': '¾',
    'frac35;': '⅗',
    'frac38;': '⅜',
    'frac45;': '⅘',
    'frac56;': '⅚',
    'frac58;': '⅝',
    'frac78;': '⅞',
    'gacute;': 'ǵ',
    'Gammad;': 'Ϝ',
    'gammad;': 'ϝ',
    'Gbreve;': 'Ğ',
    'gbreve;': 'ğ',
    'Gcedil;': 'Ģ',
    'gesdot;': '⪀',
    'gesles;': '⪔',
    'gtlPar;': '⦕',
    'gtrarr;': '⥸',
    'gtrdot;': '⋗',
    'gtrsim;': '≳',
    'hairsp;': ' ',
    'hamilt;': 'ℋ',
    'HARDcy;': 'Ъ',
    'hardcy;': 'ъ',
    'hearts;': '♥',
    'hellip;': '…',
    'hercon;': '⊹',
    'homtht;': '∻',
    'horbar;': '―',
    'hslash;': 'ℏ',
    'Hstrok;': 'Ħ',
    'hstrok;': 'ħ',
    'hybull;': '⁃',
    'hyphen;': '‐',
    'Iacute;': 'Í',
    'iacute;': 'í',
    'Igrave;': 'Ì',
    'igrave;': 'ì',
    'iiiint;': '⨌',
    'iinfin;': '⧜',
    'incare;': '℅',
    'inodot;': 'ı',
    'intcal;': '⊺',
    'iquest;': '¿',
    'isinsv;': '⋳',
    'Itilde;': 'Ĩ',
    'itilde;': 'ĩ',
    'Jsercy;': 'Ј',
    'jsercy;': 'ј',
    'kappav;': 'ϰ',
    'Kcedil;': 'Ķ',
    'kcedil;': 'ķ',
    'kgreen;': 'ĸ',
    'Lacute;': 'Ĺ',
    'lacute;': 'ĺ',
    'lagran;': 'ℒ',
    'Lambda;': 'Λ',
    'lambda;': 'λ',
    'langle;': '⟨',
    'larrfs;': '⤝',
    'larrhk;': '↩',
    'larrlp;': '↫',
    'larrpl;': '⤹',
    'larrtl;': '↢',
    'lAtail;': '⤛',
    'latail;': '⤙',
    'lbrace;': '{',
    'lbrack;': '[',
    'Lcaron;': 'Ľ',
    'lcaron;': 'ľ',
    'Lcedil;': 'Ļ',
    'lcedil;': 'ļ',
    'ldquor;': '„',
    'lesdot;': '⩿',
    'lesges;': '⪓',
    'lfisht;': '⥼',
    'lfloor;': '⌊',
    'lharul;': '⥪',
    'llhard;': '⥫',
    'Lmidot;': 'Ŀ',
    'lmidot;': 'ŀ',
    'lmoust;': '⎰',
    'loplus;': '⨭',
    'lowast;': '∗',
    'lowbar;': '_',
    'lparlt;': '⦓',
    'lrhard;': '⥭',
    'lsaquo;': '‹',
    'lsquor;': '‚',
    'Lstrok;': 'Ł',
    'lstrok;': 'ł',
    'lthree;': '⋋',
    'ltimes;': '⋉',
    'ltlarr;': '⥶',
    'ltrPar;': '⦖',
    'mapsto;': '↦',
    'marker;': '▮',
    'mcomma;': '⨩',
    'midast;': '*',
    'midcir;': '⫰',
    'middot;': '·',
    'minusb;': '⊟',
    'minusd;': '∸',
    'mnplus;': '∓',
    'models;': '⊧',
    'mstpos;': '∾',
    'Nacute;': 'Ń',
    'nacute;': 'ń',
    'nbumpe;': '≏̸',
    'Ncaron;': 'Ň',
    'ncaron;': 'ň',
    'Ncedil;': 'Ņ',
    'ncedil;': 'ņ',
    'nearhk;': '⤤',
    'nequiv;': '≢',
    'nesear;': '⤨',
    'nexist;': '∄',
    'nltrie;': '⋬',
    'notinE;': '⋹̸',
    'nparsl;': '⫽⃥',
    'nprcue;': '⋠',
    'nrarrc;': '⤳̸',
    'nrarrw;': '↝̸',
    'nrtrie;': '⋭',
    'nsccue;': '⋡',
    'nsimeq;': '≄',
    'Ntilde;': 'Ñ',
    'ntilde;': 'ñ',
    'numero;': '№',
    'nVDash;': '⊯',
    'nVdash;': '⊮',
    'nvDash;': '⊭',
    'nvdash;': '⊬',
    'nvHarr;': '⤄',
    'nvlArr;': '⤂',
    'nvrArr;': '⤃',
    'nwarhk;': '⤣',
    'nwnear;': '⤧',
    'Oacute;': 'Ó',
    'oacute;': 'ó',
    'Odblac;': 'Ő',
    'odblac;': 'ő',
    'odsold;': '⦼',
    'Ograve;': 'Ò',
    'ograve;': 'ò',
    'ominus;': '⊖',
    'origof;': '⊶',
    'Oslash;': 'Ø',
    'oslash;': 'ø',
    'Otilde;': 'Õ',
    'otilde;': 'õ',
    'Otimes;': '⨷',
    'otimes;': '⊗',
    'parsim;': '⫳',
    'percnt;': '%',
    'period;': '.',
    'permil;': '‰',
    'phmmat;': 'ℳ',
    'planck;': 'ℏ',
    'plankv;': 'ℏ',
    'plusdo;': '∔',
    'plusdu;': '⨥',
    'plusmn;': '±',
    'preceq;': '⪯',
    'primes;': 'ℙ',
    'prnsim;': '⋨',
    'propto;': '∝',
    'prurel;': '⊰',
    'puncsp;': ' ',
    'qprime;': '⁗',
    'Racute;': 'Ŕ',
    'racute;': 'ŕ',
    'rangle;': '⟩',
    'rarrap;': '⥵',
    'rarrfs;': '⤞',
    'rarrhk;': '↪',
    'rarrlp;': '↬',
    'rarrpl;': '⥅',
    'Rarrtl;': '⤖',
    'rarrtl;': '↣',
    'rAtail;': '⤜',
    'ratail;': '⤚',
    'rbrace;': '}',
    'rbrack;': ']',
    'Rcaron;': 'Ř',
    'rcaron;': 'ř',
    'Rcedil;': 'Ŗ',
    'rcedil;': 'ŗ',
    'rdquor;': '”',
    'rfisht;': '⥽',
    'rfloor;': '⌋',
    'rharul;': '⥬',
    'rmoust;': '⎱',
    'roplus;': '⨮',
    'rpargt;': '⦔',
    'rsaquo;': '›',
    'rsquor;': '’',
    'rthree;': '⋌',
    'rtimes;': '⋊',
    'Sacute;': 'Ś',
    'sacute;': 'ś',
    'Scaron;': 'Š',
    'scaron;': 'š',
    'Scedil;': 'Ş',
    'scedil;': 'ş',
    'scnsim;': '⋩',
    'searhk;': '⤥',
    'seswar;': '⤩',
    'sfrown;': '⌢',
    'SHCHcy;': 'Щ',
    'shchcy;': 'щ',
    'sigmaf;': 'ς',
    'sigmav;': 'ς',
    'simdot;': '⩪',
    'smashp;': '⨳',
    'SOFTcy;': 'Ь',
    'softcy;': 'ь',
    'solbar;': '⌿',
    'spades;': '♠',
    'sqcaps;': '⊓︀',
    'sqcups;': '⊔︀',
    'sqsube;': '⊑',
    'sqsupe;': '⊒',
    'Square;': '□',
    'square;': '□',
    'squarf;': '▪',
    'ssetmn;': '∖',
    'ssmile;': '⌣',
    'sstarf;': '⋆',
    'subdot;': '⪽',
    'Subset;': '⋐',
    'subset;': '⊂',
    'subsim;': '⫇',
    'subsub;': '⫕',
    'subsup;': '⫓',
    'succeq;': '⪰',
    'supdot;': '⪾',
    'Supset;': '⋑',
    'supset;': '⊃',
    'supsim;': '⫈',
    'supsub;': '⫔',
    'supsup;': '⫖',
    'swarhk;': '⤦',
    'swnwar;': '⤪',
    'target;': '⌖',
    'Tcaron;': 'Ť',
    'tcaron;': 'ť',
    'Tcedil;': 'Ţ',
    'tcedil;': 'ţ',
    'telrec;': '⌕',
    'there4;': '∴',
    'thetav;': 'ϑ',
    'thinsp;': ' ',
    'thksim;': '∼',
    'timesb;': '⊠',
    'timesd;': '⨰',
    'topbot;': '⌶',
    'topcir;': '⫱',
    'tprime;': '‴',
    'tridot;': '◬',
    'Tstrok;': 'Ŧ',
    'tstrok;': 'ŧ',
    'Uacute;': 'Ú',
    'uacute;': 'ú',
    'Ubreve;': 'Ŭ',
    'ubreve;': 'ŭ',
    'Udblac;': 'Ű',
    'udblac;': 'ű',
    'ufisht;': '⥾',
    'Ugrave;': 'Ù',
    'ugrave;': 'ù',
    'ulcorn;': '⌜',
    'ulcrop;': '⌏',
    'urcorn;': '⌝',
    'urcrop;': '⌎',
    'Utilde;': 'Ũ',
    'utilde;': 'ũ',
    'vangrt;': '⦜',
    'varphi;': 'ϕ',
    'varrho;': 'ϱ',
    'Vdashl;': '⫦',
    'veebar;': '⊻',
    'vellip;': '⋮',
    'Verbar;': '‖',
    'verbar;': '|',
    'vsubnE;': '⫋︀',
    'vsubne;': '⊊︀',
    'vsupnE;': '⫌︀',
    'vsupne;': '⊋︀',
    'Vvdash;': '⊪',
    'wedbar;': '⩟',
    'wedgeq;': '≙',
    'weierp;': '℘',
    'wreath;': '≀',
    'xoplus;': '⨁',
    'xotime;': '⨂',
    'xsqcup;': '⨆',
    'xuplus;': '⨄',
    'xwedge;': '⋀',
    'Yacute;': 'Ý',
    'yacute;': 'ý',
    'Zacute;': 'Ź',
    'zacute;': 'ź',
    'Zcaron;': 'Ž',
    'zcaron;': 'ž',
    'zeetrf;': 'ℨ',
    'alefsym;': 'ℵ',
    'angrtvb;': '⊾',
    'angzarr;': '⍼',
    'asympeq;': '≍',
    'backsim;': '∽',
    'Because;': '∵',
    'because;': '∵',
    'bemptyv;': '⦰',
    'between;': '≬',
    'bigcirc;': '◯',
    'bigodot;': '⨀',
    'bigstar;': '★',
    'bnequiv;': '≡⃥',
    'boxplus;': '⊞',
    'Cayleys;': 'ℭ',
    'Cconint;': '∰',
    'ccupssm;': '⩐',
    'Cedilla;': '¸',
    'cemptyv;': '⦲',
    'cirscir;': '⧂',
    'coloneq;': '≔',
    'congdot;': '⩭',
    'cudarrl;': '⤸',
    'cudarrr;': '⤵',
    'cularrp;': '⤽',
    'curarrm;': '⤼',
    'dbkarow;': '⤏',
    'ddagger;': '‡',
    'ddotseq;': '⩷',
    'demptyv;': '⦱',
    'Diamond;': '⋄',
    'diamond;': '⋄',
    'digamma;': 'ϝ',
    'dotplus;': '∔',
    'DownTee;': '⊤',
    'dwangle;': '⦦',
    'Element;': '∈',
    'Epsilon;': 'Ε',
    'epsilon;': 'ε',
    'eqcolon;': '≕',
    'equivDD;': '⩸',
    'gesdoto;': '⪂',
    'gtquest;': '⩼',
    'gtrless;': '≷',
    'harrcir;': '⥈',
    'Implies;': '⇒',
    'intprod;': '⨼',
    'isindot;': '⋵',
    'larrbfs;': '⤟',
    'larrsim;': '⥳',
    'lbrksld;': '⦏',
    'lbrkslu;': '⦍',
    'ldrdhar;': '⥧',
    'LeftTee;': '⊣',
    'lesdoto;': '⪁',
    'lessdot;': '⋖',
    'lessgtr;': '≶',
    'lesssim;': '≲',
    'lotimes;': '⨴',
    'lozenge;': '◊',
    'ltquest;': '⩻',
    'luruhar;': '⥦',
    'maltese;': '✠',
    'minusdu;': '⨪',
    'napprox;': '≉',
    'natural;': '♮',
    'nearrow;': '↗',
    'NewLine;': '\n',
    'nexists;': '∄',
    'NoBreak;': '⁠',
    'notinva;': '∉',
    'notinvb;': '⋷',
    'notinvc;': '⋶',
    'NotLess;': '≮',
    'notniva;': '∌',
    'notnivb;': '⋾',
    'notnivc;': '⋽',
    'npolint;': '⨔',
    'npreceq;': '⪯̸',
    'nsqsube;': '⋢',
    'nsqsupe;': '⋣',
    'nsubset;': '⊂⃒',
    'nsucceq;': '⪰̸',
    'nsupset;': '⊃⃒',
    'nvinfin;': '⧞',
    'nvltrie;': '⊴⃒',
    'nvrtrie;': '⊵⃒',
    'nwarrow;': '↖',
    'olcross;': '⦻',
    'Omicron;': 'Ο',
    'omicron;': 'ο',
    'orderof;': 'ℴ',
    'orslope;': '⩗',
    'OverBar;': '‾',
    'pertenk;': '‱',
    'planckh;': 'ℎ',
    'pluscir;': '⨢',
    'plussim;': '⨦',
    'plustwo;': '⨧',
    'precsim;': '≾',
    'Product;': '∏',
    'quatint;': '⨖',
    'questeq;': '≟',
    'rarrbfs;': '⤠',
    'rarrsim;': '⥴',
    'rbrksld;': '⦎',
    'rbrkslu;': '⦐',
    'rdldhar;': '⥩',
    'realine;': 'ℛ',
    'rotimes;': '⨵',
    'ruluhar;': '⥨',
    'searrow;': '↘',
    'simplus;': '⨤',
    'simrarr;': '⥲',
    'subedot;': '⫃',
    'submult;': '⫁',
    'subplus;': '⪿',
    'subrarr;': '⥹',
    'succsim;': '≿',
    'supdsub;': '⫘',
    'supedot;': '⫄',
    'suphsol;': '⟉',
    'suphsub;': '⫗',
    'suplarr;': '⥻',
    'supmult;': '⫂',
    'supplus;': '⫀',
    'swarrow;': '↙',
    'topfork;': '⫚',
    'triplus;': '⨹',
    'tritime;': '⨻',
    'UpArrow;': '↑',
    'Uparrow;': '⇑',
    'uparrow;': '↑',
    'Upsilon;': 'Υ',
    'upsilon;': 'υ',
    'uwangle;': '⦧',
    'vzigzag;': '⦚',
    'zigrarr;': '⇝',
    'andslope;': '⩘',
    'angmsdaa;': '⦨',
    'angmsdab;': '⦩',
    'angmsdac;': '⦪',
    'angmsdad;': '⦫',
    'angmsdae;': '⦬',
    'angmsdaf;': '⦭',
    'angmsdag;': '⦮',
    'angmsdah;': '⦯',
    'angrtvbd;': '⦝',
    'approxeq;': '≊',
    'awconint;': '∳',
    'backcong;': '≌',
    'barwedge;': '⌅',
    'bbrktbrk;': '⎶',
    'bigoplus;': '⨁',
    'bigsqcup;': '⨆',
    'biguplus;': '⨄',
    'bigwedge;': '⋀',
    'boxminus;': '⊟',
    'boxtimes;': '⊠',
    'bsolhsub;': '⟈',
    'capbrcup;': '⩉',
    'circledR;': '®',
    'circledS;': 'Ⓢ',
    'cirfnint;': '⨐',
    'clubsuit;': '♣',
    'cupbrcap;': '⩈',
    'curlyvee;': '⋎',
    'cwconint;': '∲',
    'DDotrahd;': '⤑',
    'doteqdot;': '≑',
    'DotEqual;': '≐',
    'dotminus;': '∸',
    'drbkarow;': '⤐',
    'dzigrarr;': '⟿',
    'elinters;': '⏧',
    'emptyset;': '∅',
    'eqvparsl;': '⧥',
    'fpartint;': '⨍',
    'geqslant;': '⩾',
    'gesdotol;': '⪄',
    'gnapprox;': '⪊',
    'hksearow;': '⤥',
    'hkswarow;': '⤦',
    'imagline;': 'ℐ',
    'imagpart;': 'ℑ',
    'infintie;': '⧝',
    'integers;': 'ℤ',
    'Integral;': '∫',
    'intercal;': '⊺',
    'intlarhk;': '⨗',
    'laemptyv;': '⦴',
    'ldrushar;': '⥋',
    'leqslant;': '⩽',
    'lesdotor;': '⪃',
    'LessLess;': '⪡',
    'llcorner;': '⌞',
    'lnapprox;': '⪉',
    'lrcorner;': '⌟',
    'lurdshar;': '⥊',
    'mapstoup;': '↥',
    'multimap;': '⊸',
    'naturals;': 'ℕ',
    'ncongdot;': '⩭̸',
    'NotEqual;': '≠',
    'notindot;': '⋵̸',
    'NotTilde;': '≁',
    'otimesas;': '⨶',
    'parallel;': '∥',
    'PartialD;': '∂',
    'plusacir;': '⨣',
    'pointint;': '⨕',
    'Precedes;': '≺',
    'precneqq;': '⪵',
    'precnsim;': '⋨',
    'profalar;': '⌮',
    'profline;': '⌒',
    'profsurf;': '⌓',
    'raemptyv;': '⦳',
    'realpart;': 'ℜ',
    'RightTee;': '⊢',
    'rppolint;': '⨒',
    'rtriltri;': '⧎',
    'scpolint;': '⨓',
    'setminus;': '∖',
    'shortmid;': '∣',
    'smeparsl;': '⧤',
    'sqsubset;': '⊏',
    'sqsupset;': '⊐',
    'subseteq;': '⊆',
    'Succeeds;': '≻',
    'succneqq;': '⪶',
    'succnsim;': '⋩',
    'SuchThat;': '∋',
    'Superset;': '⊃',
    'supseteq;': '⊇',
    'thetasym;': 'ϑ',
    'thicksim;': '∼',
    'timesbar;': '⨱',
    'triangle;': '▵',
    'triminus;': '⨺',
    'trpezium;': '⏢',
    'Uarrocir;': '⥉',
    'ulcorner;': '⌜',
    'UnderBar;': '_',
    'urcorner;': '⌝',
    'varkappa;': 'ϰ',
    'varsigma;': 'ς',
    'vartheta;': 'ϑ',
    'backprime;': '‵',
    'backsimeq;': '⋍',
    'Backslash;': '∖',
    'bigotimes;': '⨂',
    'CenterDot;': '·',
    'centerdot;': '·',
    'checkmark;': '✓',
    'CircleDot;': '⊙',
    'complexes;': 'ℂ',
    'Congruent;': '≡',
    'Coproduct;': '∐',
    'dotsquare;': '⊡',
    'DoubleDot;': '¨',
    'DownArrow;': '↓',
    'Downarrow;': '⇓',
    'downarrow;': '↓',
    'DownBreve;': '̑',
    'gtrapprox;': '⪆',
    'gtreqless;': '⋛',
    'gvertneqq;': '≩︀',
    'heartsuit;': '♥',
    'HumpEqual;': '≏',
    'LeftArrow;': '←',
    'Leftarrow;': '⇐',
    'leftarrow;': '←',
    'LeftFloor;': '⌊',
    'lesseqgtr;': '⋚',
    'LessTilde;': '≲',
    'lvertneqq;': '≨︀',
    'Mellintrf;': 'ℳ',
    'MinusPlus;': '∓',
    'ngeqslant;': '⩾̸',
    'nleqslant;': '⩽̸',
    'NotCupCap;': '≭',
    'NotExists;': '∄',
    'NotSubset;': '⊂⃒',
    'nparallel;': '∦',
    'nshortmid;': '∤',
    'nsubseteq;': '⊈',
    'nsupseteq;': '⊉',
    'OverBrace;': '⏞',
    'pitchfork;': '⋔',
    'PlusMinus;': '±',
    'rationals;': 'ℚ',
    'spadesuit;': '♠',
    'subseteqq;': '⫅',
    'subsetneq;': '⊊',
    'supseteqq;': '⫆',
    'supsetneq;': '⊋',
    'Therefore;': '∴',
    'therefore;': '∴',
    'ThinSpace;': ' ',
    'triangleq;': '≜',
    'TripleDot;': '⃛',
    'UnionPlus;': '⊎',
    'varpropto;': '∝',
    'Bernoullis;': 'ℬ',
    'circledast;': '⊛',
    'CirclePlus;': '⊕',
    'complement;': '∁',
    'curlywedge;': '⋏',
    'eqslantgtr;': '⪖',
    'EqualTilde;': '≂',
    'Fouriertrf;': 'ℱ',
    'gtreqqless;': '⪌',
    'ImaginaryI;': 'ⅈ',
    'Laplacetrf;': 'ℒ',
    'LeftVector;': '↼',
    'lessapprox;': '⪅',
    'lesseqqgtr;': '⪋',
    'Lleftarrow;': '⇚',
    'lmoustache;': '⎰',
    'longmapsto;': '⟼',
    'mapstodown;': '↧',
    'mapstoleft;': '↤',
    'nLeftarrow;': '⇍',
    'nleftarrow;': '↚',
    'NotElement;': '∉',
    'NotGreater;': '≯',
    'nsubseteqq;': '⫅̸',
    'nsupseteqq;': '⫆̸',
    'precapprox;': '⪷',
    'Proportion;': '∷',
    'RightArrow;': '→',
    'Rightarrow;': '⇒',
    'rightarrow;': '→',
    'RightFloor;': '⌋',
    'rmoustache;': '⎱',
    'sqsubseteq;': '⊑',
    'sqsupseteq;': '⊒',
    'subsetneqq;': '⫋',
    'succapprox;': '⪸',
    'supsetneqq;': '⫌',
    'ThickSpace;': '  ',
    'TildeEqual;': '≃',
    'TildeTilde;': '≈',
    'UnderBrace;': '⏟',
    'UpArrowBar;': '⤒',
    'UpTeeArrow;': '↥',
    'upuparrows;': '⇈',
    'varepsilon;': 'ϵ',
    'varnothing;': '∅',
    'backepsilon;': '϶',
    'blacksquare;': '▪',
    'circledcirc;': '⊚',
    'circleddash;': '⊝',
    'CircleMinus;': '⊖',
    'CircleTimes;': '⊗',
    'curlyeqprec;': '⋞',
    'curlyeqsucc;': '⋟',
    'diamondsuit;': '♦',
    'eqslantless;': '⪕',
    'Equilibrium;': '⇌',
    'expectation;': 'ℰ',
    'GreaterLess;': '≷',
    'LeftCeiling;': '⌈',
    'LessGreater;': '≶',
    'MediumSpace;': ' ',
    'NotLessLess;': '≪̸',
    'NotPrecedes;': '⊀',
    'NotSucceeds;': '⊁',
    'NotSuperset;': '⊃⃒',
    'nRightarrow;': '⇏',
    'nrightarrow;': '↛',
    'OverBracket;': '⎴',
    'preccurlyeq;': '≼',
    'precnapprox;': '⪹',
    'quaternions;': 'ℍ',
    'RightVector;': '⇀',
    'Rrightarrow;': '⇛',
    'RuleDelayed;': '⧴',
    'SmallCircle;': '∘',
    'SquareUnion;': '⊔',
    'straightphi;': 'ϕ',
    'SubsetEqual;': '⊆',
    'succcurlyeq;': '≽',
    'succnapprox;': '⪺',
    'thickapprox;': '≈',
    'UpDownArrow;': '↕',
    'Updownarrow;': '⇕',
    'updownarrow;': '↕',
    'VerticalBar;': '∣',
    'blacklozenge;': '⧫',
    'DownArrowBar;': '⤓',
    'DownTeeArrow;': '↧',
    'ExponentialE;': 'ⅇ',
    'exponentiale;': 'ⅇ',
    'GreaterEqual;': '≥',
    'GreaterTilde;': '≳',
    'HilbertSpace;': 'ℋ',
    'HumpDownHump;': '≎',
    'Intersection;': '⋂',
    'LeftArrowBar;': '⇤',
    'LeftTeeArrow;': '↤',
    'LeftTriangle;': '⊲',
    'LeftUpVector;': '↿',
    'NotCongruent;': '≢',
    'NotHumpEqual;': '≏̸',
    'NotLessEqual;': '≰',
    'NotLessTilde;': '≴',
    'Proportional;': '∝',
    'RightCeiling;': '⌉',
    'risingdotseq;': '≓',
    'RoundImplies;': '⥰',
    'ShortUpArrow;': '↑',
    'SquareSubset;': '⊏',
    'triangledown;': '▿',
    'triangleleft;': '◃',
    'UnderBracket;': '⎵',
    'varsubsetneq;': '⊊︀',
    'varsupsetneq;': '⊋︀',
    'VerticalLine;': '|',
    'ApplyFunction;': '⁡',
    'bigtriangleup;': '△',
    'blacktriangle;': '▴',
    'DifferentialD;': 'ⅆ',
    'divideontimes;': '⋇',
    'DoubleLeftTee;': '⫤',
    'DoubleUpArrow;': '⇑',
    'fallingdotseq;': '≒',
    'hookleftarrow;': '↩',
    'leftarrowtail;': '↢',
    'leftharpoonup;': '↼',
    'LeftTeeVector;': '⥚',
    'LeftVectorBar;': '⥒',
    'LessFullEqual;': '≦',
    'LongLeftArrow;': '⟵',
    'Longleftarrow;': '⟸',
    'longleftarrow;': '⟵',
    'looparrowleft;': '↫',
    'measuredangle;': '∡',
    'NotEqualTilde;': '≂̸',
    'NotTildeEqual;': '≄',
    'NotTildeTilde;': '≉',
    'ntriangleleft;': '⋪',
    'Poincareplane;': 'ℌ',
    'PrecedesEqual;': '⪯',
    'PrecedesTilde;': '≾',
    'RightArrowBar;': '⇥',
    'RightTeeArrow;': '↦',
    'RightTriangle;': '⊳',
    'RightUpVector;': '↾',
    'shortparallel;': '∥',
    'smallsetminus;': '∖',
    'SucceedsEqual;': '⪰',
    'SucceedsTilde;': '≿',
    'SupersetEqual;': '⊇',
    'triangleright;': '▹',
    'UpEquilibrium;': '⥮',
    'upharpoonleft;': '↿',
    'varsubsetneqq;': '⫋︀',
    'varsupsetneqq;': '⫌︀',
    'VerticalTilde;': '≀',
    'VeryThinSpace;': ' ',
    'curvearrowleft;': '↶',
    'DiacriticalDot;': '˙',
    'doublebarwedge;': '⌆',
    'DoubleRightTee;': '⊨',
    'downdownarrows;': '⇊',
    'DownLeftVector;': '↽',
    'GreaterGreater;': '⪢',
    'hookrightarrow;': '↪',
    'HorizontalLine;': '─',
    'InvisibleComma;': '⁣',
    'InvisibleTimes;': '⁢',
    'LeftDownVector;': '⇃',
    'leftleftarrows;': '⇇',
    'LeftRightArrow;': '↔',
    'Leftrightarrow;': '⇔',
    'leftrightarrow;': '↔',
    'leftthreetimes;': '⋋',
    'LessSlantEqual;': '⩽',
    'LongRightArrow;': '⟶',
    'Longrightarrow;': '⟹',
    'longrightarrow;': '⟶',
    'looparrowright;': '↬',
    'LowerLeftArrow;': '↙',
    'NestedLessLess;': '≪',
    'NotGreaterLess;': '≹',
    'NotLessGreater;': '≸',
    'NotSubsetEqual;': '⊈',
    'NotVerticalBar;': '∤',
    'nshortparallel;': '∦',
    'ntriangleright;': '⋫',
    'OpenCurlyQuote;': '‘',
    'ReverseElement;': '∋',
    'rightarrowtail;': '↣',
    'rightharpoonup;': '⇀',
    'RightTeeVector;': '⥛',
    'RightVectorBar;': '⥓',
    'ShortDownArrow;': '↓',
    'ShortLeftArrow;': '←',
    'SquareSuperset;': '⊐',
    'TildeFullEqual;': '≅',
    'trianglelefteq;': '⊴',
    'upharpoonright;': '↾',
    'UpperLeftArrow;': '↖',
    'ZeroWidthSpace;': '​',
    'bigtriangledown;': '▽',
    'circlearrowleft;': '↺',
    'CloseCurlyQuote;': '’',
    'ContourIntegral;': '∮',
    'curvearrowright;': '↷',
    'DoubleDownArrow;': '⇓',
    'DoubleLeftArrow;': '⇐',
    'downharpoonleft;': '⇃',
    'DownRightVector;': '⇁',
    'leftharpoondown;': '↽',
    'leftrightarrows;': '⇆',
    'LeftRightVector;': '⥎',
    'LeftTriangleBar;': '⧏',
    'LeftUpTeeVector;': '⥠',
    'LeftUpVectorBar;': '⥘',
    'LowerRightArrow;': '↘',
    'nLeftrightarrow;': '⇎',
    'nleftrightarrow;': '↮',
    'NotGreaterEqual;': '≱',
    'NotGreaterTilde;': '≵',
    'NotHumpDownHump;': '≎̸',
    'NotLeftTriangle;': '⋪',
    'NotSquareSubset;': '⊏̸',
    'ntrianglelefteq;': '⋬',
    'OverParenthesis;': '⏜',
    'RightDownVector;': '⇂',
    'rightleftarrows;': '⇄',
    'rightsquigarrow;': '↝',
    'rightthreetimes;': '⋌',
    'ShortRightArrow;': '→',
    'straightepsilon;': 'ϵ',
    'trianglerighteq;': '⊵',
    'UpperRightArrow;': '↗',
    'vartriangleleft;': '⊲',
    'circlearrowright;': '↻',
    'DiacriticalAcute;': '´',
    'DiacriticalGrave;': '`',
    'DiacriticalTilde;': '˜',
    'DoubleRightArrow;': '⇒',
    'DownArrowUpArrow;': '⇵',
    'downharpoonright;': '⇂',
    'EmptySmallSquare;': '◻',
    'GreaterEqualLess;': '⋛',
    'GreaterFullEqual;': '≧',
    'LeftAngleBracket;': '⟨',
    'LeftUpDownVector;': '⥑',
    'LessEqualGreater;': '⋚',
    'NonBreakingSpace;': ' ',
    'NotPrecedesEqual;': '⪯̸',
    'NotRightTriangle;': '⋫',
    'NotSucceedsEqual;': '⪰̸',
    'NotSucceedsTilde;': '≿̸',
    'NotSupersetEqual;': '⊉',
    'ntrianglerighteq;': '⋭',
    'rightharpoondown;': '⇁',
    'rightrightarrows;': '⇉',
    'RightTriangleBar;': '⧐',
    'RightUpTeeVector;': '⥜',
    'RightUpVectorBar;': '⥔',
    'twoheadleftarrow;': '↞',
    'UnderParenthesis;': '⏝',
    'UpArrowDownArrow;': '⇅',
    'vartriangleright;': '⊳',
    'blacktriangledown;': '▾',
    'blacktriangleleft;': '◂',
    'DoubleUpDownArrow;': '⇕',
    'DoubleVerticalBar;': '∥',
    'DownLeftTeeVector;': '⥞',
    'DownLeftVectorBar;': '⥖',
    'FilledSmallSquare;': '◼',
    'GreaterSlantEqual;': '⩾',
    'LeftDoubleBracket;': '⟦',
    'LeftDownTeeVector;': '⥡',
    'LeftDownVectorBar;': '⥙',
    'leftrightharpoons;': '⇋',
    'LeftTriangleEqual;': '⊴',
    'NegativeThinSpace;': '​',
    'NotGreaterGreater;': '≫̸',
    'NotLessSlantEqual;': '⩽̸',
    'NotNestedLessLess;': '⪡̸',
    'NotReverseElement;': '∌',
    'NotSquareSuperset;': '⊐̸',
    'NotTildeFullEqual;': '≇',
    'RightAngleBracket;': '⟩',
    'rightleftharpoons;': '⇌',
    'RightUpDownVector;': '⥏',
    'SquareSubsetEqual;': '⊑',
    'twoheadrightarrow;': '↠',
    'VerticalSeparator;': '❘',
    'blacktriangleright;': '▸',
    'DownRightTeeVector;': '⥟',
    'DownRightVectorBar;': '⥗',
    'LongLeftRightArrow;': '⟷',
    'Longleftrightarrow;': '⟺',
    'longleftrightarrow;': '⟷',
    'NegativeThickSpace;': '​',
    'NotLeftTriangleBar;': '⧏̸',
    'PrecedesSlantEqual;': '≼',
    'ReverseEquilibrium;': '⇋',
    'RightDoubleBracket;': '⟧',
    'RightDownTeeVector;': '⥝',
    'RightDownVectorBar;': '⥕',
    'RightTriangleEqual;': '⊵',
    'SquareIntersection;': '⊓',
    'SucceedsSlantEqual;': '≽',
    'DoubleLongLeftArrow;': '⟸',
    'DownLeftRightVector;': '⥐',
    'LeftArrowRightArrow;': '⇆',
    'leftrightsquigarrow;': '↭',
    'NegativeMediumSpace;': '​',
    'NotGreaterFullEqual;': '≧̸',
    'NotRightTriangleBar;': '⧐̸',
    'RightArrowLeftArrow;': '⇄',
    'SquareSupersetEqual;': '⊒',
    'CapitalDifferentialD;': 'ⅅ',
    'DoubleLeftRightArrow;': '⇔',
    'DoubleLongRightArrow;': '⟹',
    'EmptyVerySmallSquare;': '▫',
    'NestedGreaterGreater;': '≫',
    'NotDoubleVerticalBar;': '∦',
    'NotGreaterSlantEqual;': '⩾̸',
    'NotLeftTriangleEqual;': '⋬',
    'NotSquareSubsetEqual;': '⋢',
    'OpenCurlyDoubleQuote;': '“',
    'ReverseUpEquilibrium;': '⥯',
    'CloseCurlyDoubleQuote;': '”',
    'DoubleContourIntegral;': '∯',
    'FilledVerySmallSquare;': '▪',
    'NegativeVeryThinSpace;': '​',
    'NotPrecedesSlantEqual;': '⋠',
    'NotRightTriangleEqual;': '⋭',
    'NotSucceedsSlantEqual;': '⋡',
    'DiacriticalDoubleAcute;': '˝',
    'NotSquareSupersetEqual;': '⋣',
    'NotNestedGreaterGreater;': '⪢̸',
    'ClockwiseContourIntegral;': '∲',
    'DoubleLongLeftRightArrow;': '⟺',
    'CounterClockwiseContourIntegral;': '∳',
};

const maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
const decodeHtml = (rawText, asAttr) => {
    let offset = 0;
    const end = rawText.length;
    let decodedText = '';
    function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
    }
    while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (head == null || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
        }
        // Advance to the "&".
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === '&') {
            // Named character reference.
            let name = '';
            let value;
            if (rawText[1] != null && /[0-9a-z]/i.test(rawText[1])) {
                for (let length = maxCRNameLength; value != null && length > 0; --length) {
                    name = rawText.substr(1, length);
                    value = namedCharacterReferences[name];
                }
                if (value != null) {
                    const semi = name.endsWith(';');
                    if (asAttr &&
                        !semi &&
                        /[=a-z0-9]/i.test(rawText[name.length + 1] ?? '')) {
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                    else {
                        decodedText += value;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&' + name;
                    advance(1 + name.length);
                }
            }
            else {
                decodedText += '&';
                advance(1);
            }
        }
        else {
            // Numeric character reference.
            const hex = head[0] === '&#x';
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (body == null) {
                if (head[0] != null) {
                    decodedText = `${decodedText}${head[0]}`;
                    advance(head[0].length);
                }
            }
            else if (body[1] != null) {
                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                let cp = Number.parseInt(body[1], hex ? 16 : 10);
                if (cp === 0) {
                    cp = 0xfffd;
                }
                else if (cp > 0x10ffff) {
                    cp = 0xfffd;
                }
                else if (cp >= 0xd800 && cp <= 0xdfff) {
                    cp = 0xfffd;
                }
                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                else if ((cp >= 0x01 && cp <= 0x08) ||
                    cp === 0x0b ||
                    (cp >= 0x0d && cp <= 0x1f) ||
                    (cp >= 0x7f && cp <= 0x9f)) {
                    cp = CCR_REPLACEMENTS[cp] ?? cp;
                }
                decodedText += String.fromCodePoint(cp);
                if (body[0] != null)
                    advance(body[0].length);
            }
        }
    }
    return decodedText;
};
// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178,
};

const parserOptions = {
    isVoidTag: shared.isVoidTag,
    isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
    isPreTag: (tag) => tag === 'pre',
    decodeEntities: decodeHtml,
    isBuiltInComponent: () => { },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent != null ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent != null && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some((a) => a.type === templateAstTypes.NodeTypes.ATTRIBUTE &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent != null && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1; /* TextModes.RCDATA */
            }
            if (shared.isRawTextContainer(tag)) {
                return 2; /* TextModes.RAWTEXT */
            }
        }
        return 0; /* TextModes.DATA */
    },
};

const preprocess = (node, context) => {
    if (templateAstTypes.isTextNode(node) && node.content.trim().startsWith('<')) {
        // Incomplete element tag
        context.replaceNode(createPlainElementNode(node.loc));
        return;
    }
    if (!templateAstTypes.isElementNode(node))
        return;
    if (/^[a-z]+$/.test(node.tag) &&
        node.tagType === 1 &&
        node.tag !== 'component') {
        // force element for lower case unknown tags as user might be typing these partial html/svg tags
        node.tagType = 0; /* ELEMENT */
    }
    node.props.forEach((prop, index) => {
        // remove empty modifiers
        if (templateAstTypes.isDirectiveNode(prop)) {
            const nameEndOffset = prop.loc.source.startsWith('v-')
                ? 2 + prop.name.length
                : 1;
            let offset = prop.arg != null
                ? prop.arg.loc.end.offset - prop.loc.start.offset
                : nameEndOffset;
            prop.nameLoc = sliceLoc(prop.loc, 0, nameEndOffset);
            if (prop.modifiers.length === 1 && shared.first(prop.modifiers) === '') {
                prop.modifiers = [];
            }
            prop.modifierLocs = prop.modifiers.map((modifier) => {
                try {
                    offset += 1;
                    return sliceLoc(prop.loc, offset, modifier.length);
                }
                finally {
                    offset += modifier.length;
                }
            });
            // remove braces from arg loc
            if (prop.arg?.loc.source.startsWith('[') === true) {
                prop.arg.loc = sliceLoc(prop.arg.loc, 1, -1);
            }
            // prop.modifierLocs =
        }
        else {
            // parse ^ shorthand for v-bind
            if (prop.name.startsWith('^')) {
                const isDynamic = prop.name.slice(1).startsWith('[');
                node.props[index] = {
                    type: 7 /* DIRECTIVE */,
                    name: 'bind',
                    nameLoc: createLoc(prop.loc, 0, 1),
                    arg: isDynamic
                        ? templateAstTypes.createSimpleExpression(prop.name.slice(2, -1), false, createLoc(prop.loc, 1, prop.name.length - 1))
                        : prop.name.length > 1
                            ? templateAstTypes.createSimpleExpression(prop.name.slice(1), true, createLoc(prop.loc, 1, prop.name.length - 1))
                            : undefined,
                    loc: prop.loc,
                    modifiers: [],
                    modifierLocs: [],
                    exp: prop.value == null
                        ? undefined
                        : templateAstTypes.createSimpleExpression(prop.value.content, false, sliceLoc(prop.value.loc, 1, -1)),
                    scope: undefined,
                };
            }
            else {
                prop.nameLoc = createLoc(prop.loc, 0, prop.name.length);
            }
        }
    });
    node.tagLoc = createLoc(node.loc, 1, node.tag.length);
    if (node.isSelfClosing) {
        node.startTagLoc = node.loc;
        node.endTagLoc = sliceLoc(node.loc, -2);
    }
    else {
        const startTagIndex = node.loc.source.indexOf('>', (node.props.length > 0
            ? shared.last(node.props).loc.end.offset
            : node.tagLoc.end.offset) - node.loc.start.offset);
        if (startTagIndex < 0) {
            node.startTagLoc = node.loc; // Incomplete open tag
        }
        else {
            node.startTagLoc = createLoc(node.loc, 0, startTagIndex + 1);
            const endOfStartTagOrLastChild = (node.children.length > 0
                ? shared.last(node.children).loc.end.offset
                : node.startTagLoc.end.offset) - node.loc.start.offset;
            const endTagIndex = Math.max(endOfStartTagOrLastChild, node.loc.source.indexOf('</', endOfStartTagOrLastChild));
            node.endTagLoc = createLoc(node.loc, endTagIndex, node.loc.source.length - endTagIndex);
        }
    }
};
function parse(template, options) {
    const ast = compilerCore.baseParse(template, {
        ...parserOptions,
        ...options,
    });
    compilerCore.transform(ast, { nodeTransforms: [preprocess] });
    return ast;
}
function createPlainElementNode(contentLoc) {
    const offset = contentLoc.source.indexOf('<');
    const loc = sliceLoc(contentLoc, offset);
    const tag = loc.source.slice(1).trim();
    return {
        type: 1 /* ELEMENT */,
        tag,
        tagType: 0 /* ELEMENT */,
        codegenNode: undefined,
        children: [],
        isSelfClosing: tag.length > 0,
        loc,
        ns: 0,
        props: [],
        tagLoc: sliceLoc(loc, 1),
        startTagLoc: loc,
        endTagLoc: undefined,
        scope: new Scope(),
    };
}

function compile$1(template, options) {
    const errors = [];
    const result = compileFromAST(parse(template, {
        ...options,
        onError: (error) => {
            errors.push(error);
            options.onError?.(error);
        },
    }), options);
    result.errors.unshift(...errors);
    return result;
}
function compileFromAST(source, options) {
    const root = withScope(clone(source));
    const ast = clone(source);
    ast.scope = root.scope;
    const context = {
        ...options,
        scope: new ScopeManager(),
        used: { components: new Set(), directives: new Set() },
    };
    const errors = [];
    compilerCore.transform(root, {
        ...options,
        prefixIdentifiers: false,
        hoistStatic: false,
        transformHoist: null,
        ssr: false,
        cacheHandlers: false,
        scopeId: null,
        nodeTransforms: [
            createResolveComponentTransform(context),
            createSlotHoistScopeTransform(context),
            createTransformFor(context),
            createTransformIf(),
            createComponentChildrenTransform(),
        ],
        onError(error) {
            errors.push(error);
        },
    });
    const result = generate(root, context);
    return { ...result, ast, errors };
}
function clone(obj) {
    try {
        // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error
        // @ts-ignore
        if (typeof structuredClone !== 'undefined')
            return structuredClone(obj);
    }
    catch { }
    return JSON.parse(JSON.stringify(obj));
}

function transformTemplate(template, options) {
    const slotsIdentifier = `${options.internalIdentifierPrefix}_slots`;
    const attrsIdentifier = `${options.internalIdentifierPrefix}_attrs`;
    if (template == null) {
        return {
            code: `function ${slotsIdentifier}() { return {} }; const ${attrsIdentifier} = {};`,
            map: {
                file: '',
                mappings: [],
                names: [],
                sources: [],
                sourcesContent: [],
            },
            slotsIdentifier,
            attrsIdentifier,
            errors: [],
        };
    }
    const result = compile$1(template?.content, options);
    const offset = template.loc.start.offset;
    const line = template.loc.start.line;
    return {
        ...result,
        slotsIdentifier,
        attrsIdentifier,
        errors: result.errors.map((error) => {
            if ('loc' in error && error.loc != null) {
                error.loc.start.offset += offset;
                error.loc.end.offset += offset;
                error.loc.start.line += line;
                error.loc.end.line += line;
            }
            error.message += ` (in <template>)`;
            return error;
        }),
    };
}

function compile(source, options) {
    const result = compileWithDecodedSourceMap(source, options);
    return {
        ...result,
        map: {
            version: 3,
            ...result.map,
            mappings: sourcemapCodec.encode(result.map.mappings),
        },
    };
}
function compileWithDecodedSourceMap(source, options) {
    // performance.mark('beforeTransform')
    const cache = options.cache ?? shared.createCache(100);
    const key = (name) => `${options.fileName}::block:${name}`;
    const previous = cache.get(key('descriptor'));
    const { descriptor, errors } = compilerSfc.parse(source);
    const lang = descriptor.script?.lang ?? descriptor.scriptSetup?.lang;
    const internalIdentifierPrefix = options.internalIdentifierPrefix ?? '__VueDX__';
    const contextIdentifier = `${internalIdentifierPrefix}ctx`;
    const typeIdentifier = `${internalIdentifierPrefix}TypeCheck`;
    const resolvedOptions = {
        ...options,
        runtimeModuleName: 'vue',
        typeCheckModuleName: 'vuedx~runtime',
        typeIdentifier,
        contextIdentifier,
        internalIdentifierPrefix,
        isTypeScript: options.isTypeScript ?? (lang === 'ts' || lang === 'tsx'),
        cache,
        descriptor,
        identifiers: new Map(),
    };
    const builder = new shared.SourceTransformer(options.fileName, source);
    const isScriptChanged = hasBlockChanged(previous?.script, descriptor.script);
    const script = runIfNeeded(key('script'), isScriptChanged, cache, () => transformScript(descriptor.script, resolvedOptions));
    const isScriptSetupChanged = hasBlockChanged(previous?.scriptSetup, descriptor.scriptSetup);
    const scriptSetup = runIfNeeded(key('scriptSetup'), isScriptSetupChanged, cache, () => transformScriptSetup(descriptor.scriptSetup, resolvedOptions));
    resolvedOptions.identifiers = new Map();
    script.identifiers.forEach((identifier) => {
        resolvedOptions.identifiers.set(identifier.name, identifier);
    });
    scriptSetup.identifiers.forEach((identifier) => {
        resolvedOptions.identifiers.set(identifier.name, identifier);
    });
    const template = runIfNeeded(key('template'), isScriptChanged ||
        isScriptSetupChanged ||
        hasBlockChanged(previous?.template, descriptor.template), cache, () => transformTemplate(descriptor.template, resolvedOptions));
    const name = script.name;
    function region(name, fn) {
        builder.nextLine();
        builder.append(`//#region ${name}`);
        builder.nextLine();
        fn();
        builder.nextLine();
        builder.append(`//#endregion`);
        builder.nextLine();
    }
    builder.append([
        `import * as ${resolvedOptions.typeIdentifier} from '${resolvedOptions.typeCheckModuleName}';`,
        `declare const ${resolvedOptions.internalIdentifierPrefix}defineComponent: typeof import(${JSON.stringify(resolvedOptions.runtimeModuleName)}).defineComponent;`,
        `type ${resolvedOptions.internalIdentifierPrefix}GlobalComponents = import(${JSON.stringify(resolvedOptions.runtimeModuleName)}).GlobalComponents;`,
    ].join('\n'));
    builder.nextLine();
    region('<script>', () => {
        builder.append(script.code, shared.rebaseSourceMap(script.map, descriptor.script?.loc.start));
    });
    const customBlocksResults = descriptor.customBlocks.map((block, index) => {
        const result = runIfNeeded(key(`customBlock${index}`), hasBlockChanged(previous?.customBlocks[index], block), cache, () => transformCustomBlock(block, resolvedOptions));
        region(`<${block.type}>`, () => {
            builder.append(result.code, shared.rebaseSourceMap(result.map, block.loc.start));
        });
        return result;
    });
    region('<script setup>', () => {
        builder.append(scriptSetup.code, shared.rebaseSourceMap(scriptSetup.map, descriptor.scriptSetup?.loc.start));
    });
    const defaultExportIdentifier = descriptor.scriptSetup != null
        ? scriptSetup.exportIdentifier
        : script.exportIdentifier;
    builder.append([
        `function ${internalIdentifierPrefix}RegisterSelf<T>(ctx: T) {`,
        `  return { ...ctx, [${JSON.stringify(name)}]: ${name} }`,
        `}`,
    ].join('\n'));
    builder.nextLine();
    builder.append(`const ${contextIdentifier} = ${customBlocksResults.reduce((code, result) => {
        if (result.decoratorIdentifier != null) {
            return `${result.decoratorIdentifier}(${code})`;
        }
        return code;
    }, `${internalIdentifierPrefix}RegisterSelf(new ${defaultExportIdentifier}())`)}`);
    builder.nextLine();
    region(`<template>`, () => {
        builder.append(template.code, shared.rebaseSourceMap(template.map, descriptor.template?.loc.start));
    });
    descriptor.styles.forEach((style, index) => {
        const result = runIfNeeded(key(`style${index}`), hasBlockChanged(previous?.styles[index], style), cache, () => transformStyle(style, resolvedOptions));
        builder.append('/* <style> */');
        region('<style>', () => {
            builder.append(result.code, shared.rebaseSourceMap(result.map, style.loc.start));
        });
    });
    const exported = [
        ...(descriptor.scriptSetup == null
            ? [template.attrsIdentifier, template.slotsIdentifier, contextIdentifier]
            : [scriptSetup.componentIdentifier]),
        ...Object.values(scriptSetup.exports),
    ].join(', ');
    builder.append(`return {${exported}};};`);
    builder.nextLine();
    builder.append(`const {${exported}} = ${scriptSetup.scopeIdentifier}();\n`);
    Object.entries(scriptSetup.exports).forEach(([name, identifier]) => {
        builder.append(`export type ${name} = typeof ${identifier};\n`);
    });
    region('public component definition', () => {
        if (descriptor.scriptSetup == null) {
            const props = `${resolvedOptions.contextIdentifier}.$props`;
            const inheritAttrs = descriptor.template?.content.includes('@vue-attrs-target') === true ||
                script.inheritAttrs;
            const propsType = `typeof ${props}`;
            const attrsType = `typeof ${template.attrsIdentifier}`;
            const slotsType = `${resolvedOptions.typeIdentifier}.internal.Slots<typeof ${template.slotsIdentifier}_value>`;
            builder.append([
                `const ${template.slotsIdentifier}_value = ${template.slotsIdentifier}();`,
                `export default class ${name} {`,
                defineProperty('$props', inheritAttrs
                    ? `${resolvedOptions.typeIdentifier}.internal.MergeAttrs<${propsType}, ${attrsType}> & {$slots: ${slotsType}}`
                    : `${propsType} & {$slots: ${slotsType}}`),
                `}`,
            ].join('\n'));
        }
        else {
            const generic = typeof descriptor.scriptSetup.attrs['generic'] === 'string'
                ? descriptor.scriptSetup.attrs['generic']
                : '';
            const typeArgs = parseGenericArgNames(generic);
            const component = typeArgs.length > 0
                ? `(new (${scriptSetup.scopeIdentifier}<${typeArgs.join(', ')}>().${scriptSetup.componentIdentifier}<${typeArgs.join(', ')}>))`
                : `(new (${scriptSetup.scopeIdentifier}().${scriptSetup.componentIdentifier}))`;
            const genericExp = typeArgs.length > 0 ? `<${generic}>` : '';
            builder.append(`export default class ${name}${genericExp} {\n`);
            builder.append(` $props = {...${component}.$props, $slots: ${component}.$slots };\n`);
            builder.append(`}`);
        }
        builder.nextLine();
    });
    const output = builder.end();
    // performance.mark('afterTransform')
    // performance.measure('transform', 'beforeTransform', 'afterTransform')
    return {
        code: output.code,
        map: {
            ...output.map,
            file: options.fileName.replace(/\.vue$/, resolvedOptions.isTypeScript ? '.tsx' : '.jsx'),
        },
        descriptor,
        errors: [...errors, ...template.errors],
        template: template.ast,
    };
    function defineProperty(name, type) {
        return resolvedOptions.isTypeScript
            ? `  ${name} = null as unknown as ${type};`
            : `  ${name} = /** @type {${type}} */ (/** @type {unknown} */ (null));`;
    }
    function parseGenericArgNames(code) {
        const ts = options.typescript;
        const program = transforms.createProgram(ts, `function _<${code}>() {}`);
        const sourceFile = program.getSourceFile('input.ts');
        shared.invariant(sourceFile != null, 'sourceFile should not be null');
        const decl = shared.first(sourceFile.statements);
        shared.invariant(ts.isFunctionDeclaration(decl));
        shared.invariant(decl.typeParameters != null);
        return decl.typeParameters.map((p) => p.name.getText());
    }
}
function runIfNeeded(key, forceEvict, cache, fn) {
    if (forceEvict)
        cache.delete(key);
    return cache.resolve(key, fn);
}
function hasBlockChanged(previous, current) {
    if (previous === undefined)
        return true;
    if (previous === current)
        return true;
    if (previous == null || current == null)
        return false;
    if (previous.type !== current.type)
        return false;
    if (previous.lang !== current.lang)
        return false;
    if (previous.content !== current.content)
        return false;
    if (!areObjectsEqual(previous.attrs, current.attrs))
        return false;
    return true;
}
function areObjectsEqual(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    for (const key of Object.keys(a)) {
        if (a[key] !== b[key])
            return false;
    }
    return true;
}

exports.annotations = annotations;
exports.compile = compile;
exports.compileWithDecodedSourceMap = compileWithDecodedSourceMap;
//# sourceMappingURL=index.cjs.map
