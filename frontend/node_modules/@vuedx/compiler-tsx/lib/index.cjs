'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const compilerCore = require('@vue/compiler-core/dist/compiler-core.cjs.js');
const shared = require('@vuedx/shared');
const templateAstTypes = require('@vuedx/template-ast-types');
const compilerSfc = require('@vuedx/compiler-sfc');
const transforms = require('@vuedx/transforms');
const sourcemapCodec = require('sourcemap-codec');
const parser = require('@babel/parser');
const types = require('@babel/types');

function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(Object.assign({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function createLoc(loc, offset, length) {
    if (loc == null)
        return;
    length = length ?? loc.source.length - offset;
    const source = loc.source.slice(offset, offset + length);
    const start = advancePositionWithClone(loc.start, loc.source.slice(0, offset));
    const end = advancePositionWithClone(start, source);
    return { source, start, end };
}
function sliceLoc(loc, start, end) {
    if (loc == null)
        return;
    if (end == null) {
        end = loc.source.length;
    }
    else if (end < 0) {
        end = loc.source.length + end;
    }
    if (start < 0) {
        start = loc.source.length + start;
    }
    return createLoc(loc, start, Math.max(0, end - start));
}

function getRuntimeFn(prefix, name) {
    return `${prefix}.internal.${name}`;
}

const annotations = {
    /**
     * Mark range to ignore diagnostics.
     */
    diagnosticsIgnore: {
        start: '/*<vuedx:diagnosticsIgnore>*/',
        end: '/*</vuedx:diagnosticsIgnore>*/',
    },
    /**
     * Used to define range for hoists or defining global variables.
     */
    templateGlobals: {
        start: '/*<vuedx:templateGlobals>*/',
        end: '/*</vuedx:templateGlobals>*/',
    },
    /**
     * Used to define range for return from setup() function, generated from <script setup>
     */
    setupGlobals: {
        start: '/*<vuedx:setupGlobals>*/',
        end: '/*</vuedx:setupGlobals>*/',
    },
    /**
     * Missing expression in v-if or v-else-if.
     */
    missingExpression: '/*<vuedx:missingExpression>*/',
    /**
     * Used in every JSX element to provide position for attribute completion.
     */
    tsxCompletions: '/*<vuedx:tsx-completions-target/>*/',
    /**
     * Used once in render function to get completions from context.
     */
    tsCompletions: '/*<vuedx:ts-completions-target/>*/',
};
let ctx;
function generate(root, options) {
    ctx = createGenerateContext(options);
    genRootNode(root);
    genSlotTypes(root);
    genAttrTypes(root);
    return ctx.getOutput();
}
function genNode(node) {
    switch (node.type) {
        case templateAstTypes.NodeTypes.ROOT:
            return genRootNode(node);
        case templateAstTypes.NodeTypes.ELEMENT: {
            const el = node;
            switch (el.tagType) {
                case templateAstTypes.ElementTypes.ELEMENT:
                    return genElementNode(node);
                case templateAstTypes.ElementTypes.COMPONENT:
                    return genComponentNode(node);
                case templateAstTypes.ElementTypes.SLOT:
                    return genSlotOutletNode(node);
                case templateAstTypes.ElementTypes.TEMPLATE:
                    return genTemplateNode(node);
                default:
                    throw new Error(`Unexpected element type: ${node.type}`);
            }
        }
        case templateAstTypes.NodeTypes.SIMPLE_EXPRESSION:
        case templateAstTypes.NodeTypes.COMPOUND_EXPRESSION:
            return genExpressionNode(node);
        case templateAstTypes.NodeTypes.TEXT:
            return genTextNode(node);
        case templateAstTypes.NodeTypes.INTERPOLATION:
            return genInterpolationNode(node);
        case templateAstTypes.NodeTypes.COMMENT:
            return genCommentNode(node);
        case templateAstTypes.NodeTypes.FOR:
            return genForNode(node);
        case templateAstTypes.NodeTypes.IF:
            return genIfNode(node);
        default:
            throw new Error(`Unsupported node type: ${node.type}`);
    }
}
function indent(fn) {
    ctx.indent();
    fn();
    ctx.deindent();
}
function writeLine(code) {
    ctx.write(code).newLine();
}
function genRootNode(node) {
    genKnownIdentifierGetters(node.scope.globals);
    writeLine(`function ${ctx.internalIdentifierPrefix}render() {`);
    indent(() => {
        node.scope.getBinding('$slots'); // forces to declare $slots
        genGlobalDeclarations(node);
        genNodeHoists({ hoists: ctx.scope.getRootScope() });
        writeLine('return (');
        indent(() => {
            writeLine('<>');
            indent(() => genChildren(node));
            writeLine('</>');
        });
        writeLine(')');
    });
    writeLine('}');
    writeLine(`${ctx.internalIdentifierPrefix}render();`);
}
function genKnownIdentifierGetters(ids) {
    ids = Array.from(new Set([...ids, ...ctx.used.components, ...ctx.used.directives]));
    if (!ids.some((id) => ctx.identifiers.has(id)))
        return;
    wrap(annotations.templateGlobals.start, annotations.templateGlobals.end, () => {
        ctx.newLine();
        ids.forEach((id) => {
            const knownId = ctx.identifiers.get(id);
            if (knownId == null)
                return;
            if (!['ref', 'maybeRef', 'externalMaybeRef', 'externalRef'].includes(knownId.kind))
                return;
            writeLine(`const ${ctx.internalIdentifierPrefix}_get_identifier_${id} = () => ${getRuntimeFn(ctx.typeIdentifier, 'unref')}(${id});`);
        });
    });
    ctx.newLine();
}
function genDirectiveChecks(el) {
    const directives = el.props.filter(templateAstTypes.isDirectiveNode).filter((directive) => {
        return !['on', 'bind', 'text', 'html', 'model'].includes(directive.name);
    });
    if (directives.length === 0)
        return;
    wrap('{(() => {', '})()}', () => indent(() => {
        ctx.newLine();
        directives.forEach((directive) => {
            ctx.write(`${getRuntimeFn(ctx.typeIdentifier, 'checkDirective')}(`);
            ctx.write(directive.resolvedName ?? asConst(JSON.stringify(directive.name)), createLoc(directive.loc, 0, 2 + directive.name.length), true);
            ctx.write(', ');
            if (templateAstTypes.isComponentNode(el)) {
                ctx.write(el.resolvedName ?? asConst(JSON.stringify(el.tag)), el.tagLoc);
            }
            else {
                ctx.write(asConst(JSON.stringify(el.tag)), el.tagLoc);
            }
            ctx.write(', ');
            if (directive.arg != null)
                genExpressionNode(directive.arg);
            else
                ctx.write('undefined');
            ctx.write(', ');
            if (directive.exp != null)
                genExpressionNode(directive.exp);
            else
                ctx.write('undefined');
            ctx.write(', ');
            wrap('{ ', ' }', () => {
                directive.modifiers.forEach((modifier, index) => {
                    if (modifier.trim() === '')
                        return;
                    ctx.write(`${JSON.stringify(modifier)}`, directive.modifierLocs[index], true);
                    ctx.write(': true, ');
                });
            });
            ctx.write(');');
            ctx.newLine();
        });
    }));
    ctx.newLine(); // rendered before element or component, so add a new line
}
function genGlobalDeclarations(node) {
    if (node.scope.globals.length === 0)
        return;
    writeLine(annotations.templateGlobals.start);
    node.scope.globals.forEach((id) => {
        const knownId = ctx.identifiers.get(id);
        if (knownId != null) {
            if (['ref', 'maybeRef', 'externalMaybeRef', 'externalRef'].includes(knownId.kind)) {
                writeLine(`let ${id} = ${ctx.internalIdentifierPrefix}_get_identifier_${id}();`);
            }
        }
        else {
            writeLine(`let ${id} = ${ctx.contextIdentifier}.${id}`);
        }
    });
    writeLine(annotations.templateGlobals.end);
}
function genNodeHoists(node) {
    if (node.hoists.length === 0)
        return;
    writeLine(annotations.templateGlobals.start);
    node.hoists.forEach((hoist) => {
        genExpressionNode(hoist);
        ctx.newLine();
    });
    writeLine(annotations.templateGlobals.end);
}
function genElementNode(node) {
    genDirectiveChecks(node);
    ctx.write('<', node.startTagLoc);
    if (node.tag !== '') {
        ctx.write(node.tag, node.tagLoc, true).newLine();
        indent(() => {
            genProps(node);
            ctx.write(`${annotations.tsxCompletions}`);
        });
        ctx.newLine();
    }
    else {
        return; // tag is empty, when only "<" is present
    }
    if (node.isSelfClosing) {
        ctx.write('/>', node.endTagLoc);
        return; // done
    }
    ctx.write('>').newLine();
    indent(() => genChildren(node));
    ctx.write('</', node.endTagLoc);
    ctx.write(node.tag);
    ctx.write('>');
}
function genComponentNode(node) {
    // if (node.tag.includes('-')) return genElementNode(node) // assume custom element
    if (node.resolvedName == null) {
        ctx.write('{(() => {').newLine();
        indent(() => {
            const name = `${ctx.internalIdentifierPrefix}component`;
            genTypeGuards();
            ctx.newLine();
            ctx.write(`const ${name} = ${getRuntimeFn(ctx.typeIdentifier, 'resolveComponent')}(${ctx.isTypeScript
                ? `{} as unknown as ${ctx.internalIdentifierPrefix}GlobalComponents`
                : `/** @type {${ctx.internalIdentifierPrefix}GlobalComponents} */ (/** @type {unknown} */ ({}))`}, ${ctx.isTypeScript
                ? `{} as unknown as JSX.IntrinsicElements`
                : `/** @type {JSX.IntrinsicElements} */ (/** @type {unknown} */ ({}))`}, ${ctx.contextIdentifier}, `);
            if (templateAstTypes.isAttributeNode(node.is)) {
                const name = node.is.value?.content ?? '';
                ctx.write(JSON.stringify(name), node.is.value?.loc, true);
                ctx.write(', ');
                ctx.write(JSON.stringify(name), node.is.value?.loc, true);
                ctx.write(', ');
                ctx.write(JSON.stringify(shared.pascalCase(name)), node.is.value?.loc, true);
            }
            else if (node.is != null && templateAstTypes.isExpressionNode(node.is.exp)) {
                genExpressionNode(node.is.exp);
                ctx.write(', ');
                genExpressionNode(node.is.exp);
                ctx.write(', ');
                genExpressionNode(node.is.exp);
            }
            else {
                ctx.write('undefined, undefined, undefined');
            }
            ctx.write(');').newLine();
            writeLine(`if (${name} == null) throw new Error`);
            ctx.write('return (').newLine();
            indent(() => {
                node.resolvedName = name;
                genComponentNode(node);
                node.resolvedName = undefined;
            });
            ctx.newLine().write(');').newLine();
        });
        ctx.write('})()}');
        return; // - done
    }
    genDirectiveChecks(node);
    ctx.write('<', node.loc);
    ctx.write(node.resolvedName ?? node.tag, node.tagLoc, true).newLine();
    indent(() => {
        genProps(node);
        ctx.write(`${annotations.tsxCompletions}`);
    });
    ctx.newLine();
    if (node.isSelfClosing) {
        ctx.write('$slots={{}}');
        ctx.write('/>', node.endTagLoc).newLine();
        return; // done
    }
    ctx.write('$slots=');
    indent(() => {
        wrap('{', '}', () => {
            ctx.write(`{`);
            ctx.newLine();
            indent(() => {
                node.slots.forEach((slotNode) => {
                    if (slotNode.name == null) {
                        ctx.write(`default`);
                    }
                    else if (isStaticExpression(slotNode.name)) {
                        ctx.write(JSON.stringify(slotNode.name.content), slotNode.name.loc);
                    }
                    else {
                        ctx.write('[');
                        genExpressionNode(slotNode.name);
                        ctx.write(']');
                    }
                    ctx.write(': (');
                    if (slotNode.args != null) {
                        genExpressionNode(slotNode.args);
                    }
                    ctx.write(') => {').newLine();
                    indent(() => {
                        genTypeGuards();
                        genNodeHoists(slotNode);
                        writeLine('return (');
                        indent(() => {
                            writeLine('<>');
                            indent(() => genChildren(slotNode));
                            writeLine('</>');
                        });
                        writeLine(')');
                    });
                    ctx.write('},').newLine();
                });
            });
            ctx.write('}');
        });
    });
    writeLine('>');
    ctx.newLine();
    ctx.write('</', node.endTagLoc);
    ctx.write(node.resolvedName ?? node.tag);
    ctx.write('>');
}
function genTypeGuards() {
    const value = ctx.setSourceMapMode(false);
    ctx.typeGuards.forEach((guard) => {
        if (guard == null)
            return;
        ctx.write(`if(!(`);
        genExpressionNode(guard);
        ctx.write(')) throw new Error;').newLine();
    });
    ctx.setSourceMapMode(value);
}
function genSlotOutletNode(node) {
    const name = compilerCore.findProp(node, 'name', false, true);
    const accessor = ['$slots'];
    if (templateAstTypes.isAttributeNode(name) && name.value != null) {
        if (templateAstTypes.isSimpleIdentifier(name.value.content)) {
            accessor.push('.', compilerCore.createSimpleExpression(name.value.content, false, name.value.loc));
        }
        else {
            accessor.push('[', name.value, ']');
        }
    }
    else if (templateAstTypes.isDirectiveNode(name) && name.arg != null) {
        if (templateAstTypes.isSimpleExpressionNode(name.arg) &&
            templateAstTypes.isSimpleIdentifier(name.arg.content)) {
            accessor.push('.', compilerCore.createSimpleExpression(name.arg.content, false, name.arg.loc));
        }
        else {
            accessor.push('[', name.arg, ']');
        }
    }
    else {
        accessor.push(`.default`);
    }
    const genSlotAccessor = () => {
        genExpressionNode(compilerCore.createCompoundExpression(accessor));
    };
    wrap('{', '}', () => {
        ctx.newLine();
        indent(() => {
            genSlotAccessor();
            ctx.write(' != null ? ');
            genSlotAccessor();
            ctx.write('({');
            const props = node.props.filter((node) => node !== name);
            if (props.length > 0) {
                indent(() => {
                    ctx.newLine();
                    props.forEach((prop) => {
                        genObjectProperty(prop);
                    });
                });
            }
            ctx.write('})');
        });
        ctx.write(' : ');
        if (node.children.length > 0) {
            ctx.typeGuards.push(compilerCore.createCompoundExpression([...accessor, ' == null']));
            indent(() => {
                wrap('(', ')', () => {
                    ctx.newLine();
                    indent(() => {
                        wrap('<>', '</>', () => {
                            ctx.newLine();
                            indent(() => genChildren(node));
                        });
                    });
                    ctx.newLine();
                });
                ctx.newLine();
            });
            ctx.typeGuards.pop();
        }
        else {
            ctx.write('null');
        }
        ctx.newLine();
    });
}
function genChildren(node) {
    node.children.forEach((node) => {
        if (templateAstTypes.isTextNode(node)) {
            ctx.write('{');
            genTextNode(node);
            ctx.write('}');
            ctx.newLine();
        }
        else {
            genNode(node);
            ctx.newLine();
        }
    });
}
function genProps(el) {
    if (el.props.length === 0)
        return;
    const rendered = new Set();
    const directives = el.props.filter(templateAstTypes.isDirectiveNode);
    el.props.forEach((prop) => {
        if (templateAstTypes.isAttributeNode(prop)) {
            genAttribute(prop, el);
            ctx.newLine();
        }
        else if (rendered.has(prop)) ;
        else if (prop.name === 'bind') {
            genVBindDirective(prop, el);
            ctx.newLine();
        }
        else if (prop.name === 'on') {
            if (prop.arg == null) {
                if (prop.exp == null) {
                    ctx.write('on', prop.loc, true);
                }
                else {
                    ctx.write('{...(');
                    genExpressionNode(prop.exp);
                    ctx.write(')}');
                }
            }
            else {
                shared.invariant(templateAstTypes.isSimpleExpressionNode(prop.arg));
                const id = prop.arg.content;
                const all = directives.filter((directive) => directive.name === 'on' &&
                    templateAstTypes.isSimpleExpressionNode(directive.arg) &&
                    directive.arg.content === id);
                const genHandler = () => {
                    if (templateAstTypes.isPlainElementNode(el)) {
                        ctx.typeGuards.push(compilerCore.createCompoundExpression([
                            `$event.currentTarget instanceof `,
                            shared.getClassNameForTagName(el.tag),
                        ]));
                    }
                    ctx.write(`${getRuntimeFn(ctx.typeIdentifier, 'first')}([`).newLine();
                    indent(() => {
                        all.forEach((directive) => {
                            rendered.add(directive);
                            if (directive.exp != null) {
                                genExpressionNodeAsFunction(directive.exp);
                            }
                            else {
                                ctx.write(annotations.missingExpression, directive.loc);
                            }
                            ctx.write(', ');
                            ctx.newLine();
                        });
                    });
                    ctx.write('])');
                    if (templateAstTypes.isPlainElementNode(el)) {
                        ctx.typeGuards.pop();
                    }
                };
                if (isStaticExpression(prop.arg)) {
                    ctx.write(`on${shared.capitalize(prop.arg.content)}`, prop.arg.loc, true);
                    ctx.write('=');
                    wrap('{', '}', genHandler);
                }
                else {
                    ctx.write('{...({');
                    ctx.write('[');
                    genExpressionNode(prop.arg); // TODO: Capitalize
                    ctx.write(']: ');
                    genHandler();
                    ctx.write('})}');
                }
            }
            ctx.newLine();
        }
        else if (prop.name === 'text' || prop.name === 'html') {
            ctx.write('innerHTML', createLoc(prop.loc, 2, 4), true).write('=');
            wrap('{', '}', () => {
                if (prop.exp != null) {
                    genExpressionNode(prop.exp);
                }
                else {
                    ctx.write(annotations.missingExpression);
                }
            });
            ctx.newLine();
        }
        else if (prop.name === 'model') {
            const genExp = () => {
                if (prop.exp != null) {
                    genExpressionNode(prop.exp);
                }
                else {
                    ctx.write(annotations.missingExpression, sliceLoc(prop.loc, -1));
                }
            };
            if (prop.arg == null) {
                // TODO: get attribute name at runtime
                let isCheckbox = false;
                if (['input', 'select', 'textarea'].includes(el.tag)) {
                    const type = compilerCore.findProp(el, 'type');
                    if (templateAstTypes.isAttributeNode(type) &&
                        (type.value?.content === 'checkbox' ||
                            type.value?.content === 'radio')) {
                        isCheckbox = true;
                        ctx.write('checked', prop.nameLoc, true);
                    }
                    else {
                        ctx.write('value', prop.nameLoc, true);
                    }
                }
                else {
                    ctx.write('modelValue', prop.nameLoc, true);
                }
                ctx.write('={');
                genExp();
                if (isCheckbox) {
                    const value = compilerCore.findProp(el, 'value');
                    if (templateAstTypes.isAttributeNode(value)) {
                        ctx.write(' === ');
                        if (value.value != null) {
                            genTextNode(value.value);
                        }
                        else {
                            ctx.write('undefined', value.loc);
                        }
                    }
                    else if (templateAstTypes.isDirectiveNode(value)) {
                        ctx.write(' === ');
                        if (value.exp != null) {
                            genExpressionNode(value.exp);
                        }
                        else {
                            ctx.write('undefined', value.loc);
                        }
                    }
                }
                ctx.write('}');
            }
            else if (isStaticExpression(prop.arg)) {
                ctx.write(prop.arg.content, prop.arg.loc);
                ctx.write('={');
                genExp();
                ctx.write('}');
            }
            else {
                ctx.write('{...({');
                genExpressionNode(prop.arg);
                ctx.write(': ');
                genExp();
                ctx.write('})}');
            }
            ctx.newLine();
        }
    });
}
function genAttribute(attribute, element) {
    if (attribute.name === 'class' || attribute.name === 'style')
        return; // TODO: handle class and style eventually
    const name = templateAstTypes.isPlainElementNode(element) ||
        attribute.name.startsWith('data-') ||
        attribute.name.startsWith('aria-')
        ? attribute.name
        : shared.camelize(attribute.name);
    ctx.write(name, attribute.nameLoc, true);
    if (attribute.value != null) {
        ctx.write('=');
        genTextNode(attribute.value);
    }
}
function genVBindDirective(prop, element) {
    if (isStaticExpression(prop.arg)) {
        const name = templateAstTypes.isPlainElementNode(element) ||
            prop.arg.content.startsWith('data-') ||
            prop.arg.content.startsWith('aria-')
            ? prop.arg.content
            : shared.camelize(prop.arg.content);
        ctx.write(name, prop.arg.loc, true);
        if (prop.exp != null) {
            ctx.write('=');
            ctx.write('{');
            genExpressionNode(prop.exp);
            ctx.write('}');
        }
    }
    else if (prop.arg != null) {
        ctx.write('{...({[');
        genExpressionNode(prop.arg);
        ctx.write(']');
        if (prop.exp != null) {
            ctx.write(': ');
            genExpressionNode(prop.exp);
        }
        else {
            ctx.write(': true');
        }
        ctx.write('})}');
    }
    else if (prop.exp == null) {
        ctx.write(' ', prop.loc);
    }
    else {
        ctx.write('{...(');
        if (prop.exp != null) {
            genExpressionNode(prop.exp);
        }
        else {
            ctx.write(' ', createLoc(prop.loc, prop.loc.source.length));
        }
        ctx.write(')}');
    }
}
function genTextNode(node) {
    ctx.write(JSON.stringify(node.content), node.loc, true);
}
function genInterpolationNode(node) {
    ctx.write(' {', node.loc);
    genExpressionNode(node.content);
    ctx.write('} ', sliceLoc(node.loc, -2));
}
function genExpressionNode(node) {
    if (templateAstTypes.isSimpleExpressionNode(node)) {
        if (isStaticExpression(node)) {
            ctx.write(JSON.stringify(node.content), node.loc, true);
        }
        else {
            genSimpleExpressionNode(node);
        }
    }
    else {
        genCompoundExpressionNode(node);
    }
}
function genExpressionNodeAsFunction(node) {
    shared.invariant(templateAstTypes.isSimpleExpressionNode(node), 'v-on directive expression must be simple.');
    if (
    // is identifier?
    templateAstTypes.isSimpleIdentifier(node.content) ||
        // is arrow function expression?
        /^(\([^)]*\)|[A-Za-z$_][A-Za-z0-9$_]*)\s*=>/i.test(node.content.trim()) ||
        // is function expression?
        /^function[\s(]/.test(node.content.trim())) {
        genSimpleExpressionNode(node);
    }
    else {
        node.content.includes('$event')
            ? ctx.write('($event) => {').newLine()
            : ctx.write('() => {').newLine();
        genTypeGuards();
        genSimpleExpressionNode(node);
        ctx.newLine().write('}');
    }
}
function genSimpleExpressionNode(node) {
    ctx.write(node.content, node.loc, true);
}
function genCompoundExpressionNode(node) {
    node.children.forEach((node) => {
        if (typeof node === 'string') {
            ctx.write(node);
        }
        else if (typeof node === 'symbol') {
            throw new Error('Unsupported symbol node');
        }
        else {
            genNode(node);
        }
    });
}
function createGenerateContext(options) {
    let indent = 0;
    let output = '';
    let line = 0;
    let column = 0;
    const names = [];
    const mappings = [[]];
    let shouldIndent = false;
    let shouldWriteMapping = true;
    const nl = '\n';
    function push(chunk, loc, addMappingType = false) {
        output += chunk;
        const lines = chunk.split(nl);
        if (loc != null && shouldWriteMapping) {
            let index = null;
            if (addMappingType) {
                const name = loc.source.startsWith(chunk)
                    ? `<<P>>${chunk.length}`
                    : loc.source.endsWith(chunk)
                        ? `<<S>>${loc.source.length}|${chunk.length}`
                        : `<<T>>${loc.source.length}|${chunk.length}`;
                index = names.indexOf(name);
                if (index === -1) {
                    index = names.push(name) - 1;
                }
            }
            mappings[line]?.push(index != null
                ? [column, 0, loc.start.line - 1, loc.start.column - 1, index]
                : [column, 0, loc.start.line - 1, loc.start.column - 1]);
        }
        else {
            mappings[line]?.push([column]);
        }
        if (lines.length > 1) {
            line += lines.length - 1;
            column = shared.last(lines).length;
        }
        else {
            column += chunk.length;
        }
        for (let i = mappings.length; i <= line; i++) {
            mappings.push([]);
        }
    }
    const context = {
        ...options,
        typeGuards: [],
        setSourceMapMode(enabled) {
            const current = shouldWriteMapping;
            shouldWriteMapping = enabled;
            return current;
        },
        write(code, loc, addMappingType) {
            if (shouldIndent) {
                shouldIndent = false;
                push(' '.repeat(indent));
            }
            push(code, loc, addMappingType);
            return context;
        },
        newLine() {
            push(nl);
            shouldIndent = true;
            return context;
        },
        indent() {
            indent = Math.max(0, indent) + 2;
            return context;
        },
        deindent() {
            indent = Math.max(0, indent - 2);
            return context;
        },
        getOutput() {
            return {
                code: output,
                map: {
                    file: options.fileName,
                    sources: [],
                    sourcesContent: [],
                    names,
                    mappings,
                },
            };
        },
    };
    return context;
}
function isStaticExpression(node) {
    return templateAstTypes.isSimpleExpressionNode(node) && node.isStatic;
}
function genSlotTypes(root) {
    const slots = [];
    const value = ctx.setSourceMapMode(false);
    templateAstTypes.traverse(root, (node, ancestors) => {
        if (templateAstTypes.isSlotNode(node)) {
            slots.push([node, ancestors.slice()]);
        }
    });
    writeLine(annotations.diagnosticsIgnore.start);
    ctx.write(`function ${ctx.internalIdentifierPrefix}_slots() {`).newLine();
    indent(() => {
        genGlobalDeclarations(root);
        ctx
            .write(`return ${getRuntimeFn(ctx.typeIdentifier, 'union')}(...${getRuntimeFn(ctx.typeIdentifier, 'flat')}([`)
            .newLine();
        indent(() => {
            for (const [slot, ancestors] of slots) {
                recurse(ancestors.slice().map((path) => path.node), {
                    enter(node, index, nodes) {
                        if (isForNode(node)) {
                            ctx.write(getRuntimeFn(ctx.typeIdentifier, 'flat'));
                            ctx.write('(');
                            ctx.newLine().indent();
                            ctx.write(getRuntimeFn(ctx.typeIdentifier, 'renderList'));
                            ctx.write('(');
                            genForNodeArgs(node);
                            ctx.write(' => (');
                            ctx.newLine().indent();
                        }
                        else if (templateAstTypes.isComponentNode(node)) {
                            ctx.write(getRuntimeFn(ctx.typeIdentifier, 'flat'));
                            const next = nodes[index + 1];
                            const currentSlot = next != null
                                ? node.slots.find((slot) => slot.template === next)
                                : null;
                            ctx.write('(((');
                            if (currentSlot?.args != null) {
                                genExpressionNode(currentSlot.args);
                            }
                            else {
                                ctx.write('_');
                            }
                            if (ctx.isTypeScript) {
                                ctx.write(`: ${ctx.typeIdentifier}.internal.GetSlotProps<`);
                                if (node.resolvedName != null) {
                                    ctx.write('typeof ');
                                    ctx.write(node.resolvedName);
                                }
                                else if (node.is != null) {
                                    if (templateAstTypes.isDirectiveNode(node.is) && node.is.exp != null) {
                                        ctx.write('typeof ');
                                        genExpressionNode(node.is.exp);
                                    }
                                    else {
                                        ctx.write('{}');
                                    }
                                }
                                else {
                                    ctx.write('{}');
                                }
                                ctx.write(', ');
                                if (currentSlot?.name != null) {
                                    if (!isStaticExpression(currentSlot.name)) {
                                        ctx.write('typeof ');
                                    }
                                    genExpressionNode(currentSlot.name);
                                }
                                else {
                                    ctx.write('"default"');
                                }
                                ctx.write('>');
                            }
                            ctx.write(') => {');
                            ctx.newLine().indent();
                            ctx.write('return [');
                            ctx.newLine().indent();
                        }
                    },
                    exit(node) {
                        if (templateAstTypes.isComponentNode(node)) {
                            ctx.deindent().newLine();
                            ctx.write(']');
                            ctx.deindent().newLine();
                            ctx.write(`})(${typeCastAs('null', 'any')}))`);
                        }
                        else if (isForNode(node)) {
                            ctx.deindent().newLine();
                            ctx.write('))');
                            ctx.deindent().newLine();
                            ctx.write(')');
                        }
                    },
                    fn() {
                        const name = compilerCore.findProp(slot, 'name', false, true);
                        ctx
                            .write(getRuntimeFn(ctx.typeIdentifier, 'record'))
                            .write('(')
                            .newLine();
                        indent(() => {
                            if (templateAstTypes.isAttributeNode(name)) {
                                if (name.value != null) {
                                    ctx.write(JSON.stringify(name.value.content));
                                }
                                else {
                                    ctx.write('undefined');
                                }
                            }
                            else if (templateAstTypes.isDirectiveNode(name)) {
                                if (name.exp != null) {
                                    genExpressionNode(name.exp);
                                }
                                else {
                                    ctx.write('undefined');
                                }
                            }
                            else {
                                ctx.write('"default" as const');
                            }
                            ctx.write(', ');
                            ctx.write('{');
                            indent(() => {
                                const props = slot.props.filter((prop) => prop !== name);
                                if (props.length === 0)
                                    return;
                                ctx.newLine();
                                slot.props.forEach((prop) => {
                                    if (prop === name)
                                        return;
                                    genObjectProperty(prop);
                                });
                            });
                            ctx.write('},').newLine();
                        });
                        ctx.write(')');
                    },
                });
                ctx.write(',').newLine();
            }
        });
        ctx.write(']))').newLine();
    });
    ctx.write('}').newLine();
    writeLine(annotations.diagnosticsIgnore.end);
    ctx.setSourceMapMode(value);
}
function genObjectProperty(prop, newLine = true) {
    if (templateAstTypes.isAttributeNode(prop)) {
        breakMapping(prop.loc);
        ctx.write(prop.name, prop.nameLoc, true).write(': ');
        if (prop.value != null) {
            genTextNode(prop.value);
        }
        else {
            ctx.write('true');
        }
        ctx.write(',');
        if (newLine)
            ctx.newLine();
    }
    else if (prop.name !== 'bind') ;
    else if (prop.arg != null) {
        breakMapping(prop.loc);
        if (isStaticExpression(prop.arg)) {
            if (/^[a-zA-Z_$0-9]+$/.test(prop.arg.content)) {
                ctx.write(prop.arg.content, prop.arg.loc, true);
            }
            else {
                ctx.write(JSON.stringify(prop.arg.content), prop.arg.loc, true);
            }
        }
        else {
            ctx.write('[', prop.loc);
            genExpressionNode(prop.arg);
            ctx.write(']');
        }
        ctx.write(': ');
        if (prop.exp != null) {
            genExpressionNode(prop.exp);
        }
        else {
            ctx.write('true');
        }
        ctx.write(',');
        if (newLine)
            ctx.newLine();
    }
    else if (prop.exp != null) {
        ctx.write('...(', prop.loc);
        genExpressionNode(prop.exp);
        ctx.write(')');
        ctx.write(',');
        if (newLine)
            ctx.newLine();
    }
}
function recurse(items, options) {
    if (options.enter != null) {
        for (let i = 0; i < items.length; i++) {
            options.enter(items[i], i, items);
        }
    }
    options.fn();
    if (options.exit != null) {
        for (let i = items.length - 1; i >= 0; i--) {
            options.exit(items[i], i, items);
        }
    }
}
// function isIfNode(node: Node): node is IfNode {
//   return node.type === NodeTypes.IF
// }
function isForNode(node) {
    return node.type === templateAstTypes.NodeTypes.FOR;
}
function genForNodeArgs(node) {
    const context = ctx;
    const forExps = node.parseResult;
    // Source
    if (templateAstTypes.isSimpleExpressionNode(forExps.source)) {
        const quote = !templateAstTypes.isSimpleIdentifier(forExps.source.content);
        if (quote)
            context.write('(');
        context.write(forExps.source.content, forExps.source.loc, true);
        if (quote)
            context.write(')');
    }
    else {
        context.write('undefined');
    }
    context.write(', ');
    // Handler Args
    context.write('(');
    const args = ['_', '__'];
    if (templateAstTypes.isSimpleExpressionNode(forExps.value)) {
        context.write(forExps.value.content, forExps.value.loc, true);
    }
    else if (forExps.key != null || forExps.index != null) {
        context.write(args.pop() ?? '_');
    }
    if (templateAstTypes.isSimpleExpressionNode(forExps.key)) {
        context.write(', ');
        context.write(forExps.key.content, forExps.key.loc, true);
    }
    else if (forExps.index != null) {
        context.write(', ');
        context.write(args.pop() ?? '_');
    }
    if (templateAstTypes.isSimpleExpressionNode(forExps.index)) {
        context.write(', ');
        context.write(forExps.index.content, forExps.index.loc, true);
    }
    context.write(')');
}
function genCommentNode(node) {
    ctx.write('{/*').write(node.content, node.loc).write('*/}');
}
function genForNode(forNode) {
    wrap('{', '}', () => {
        ctx.newLine();
        indent(() => {
            genFn(getRuntimeFn(ctx.typeIdentifier, 'renderList'), () => {
                genForNodeArgs(forNode);
                ctx.write(' => {').newLine();
                indent(() => {
                    genNodeHoists(forNode);
                    wrap('return (', ')', () => {
                        if (forNode.children.length === 1) {
                            ctx.newLine();
                            indent(() => genChildren(forNode));
                        }
                        else {
                            wrap('<>', '</>', () => {
                                ctx.newLine();
                                indent(() => genChildren(forNode));
                            });
                        }
                    });
                });
                ctx.newLine().write('}');
            });
        });
        ctx.newLine();
    });
}
function genFn(name, fn) {
    wrap(`${name}(`, ')', fn);
}
function wrap(open, close, fn) {
    ctx.write(open);
    fn();
    ctx.write(close);
}
function genIfNode(node) {
    wrap('{', '}', () => {
        let i = 0;
        let hasElse = false;
        const n = node.branches.length - 1;
        recurse(node.branches, {
            enter(branch) {
                ctx.typeGuards.push(branch.condition);
                if (i > 0)
                    indent(() => ctx.write(': '));
                if (branch.condition != null) {
                    genExpressionNode(branch.condition);
                    ctx.newLine();
                    indent(() => ctx.write('? '));
                }
                else if (i < n) {
                    ctx.write(annotations.missingExpression, node.loc).newLine();
                    ctx.newLine();
                    indent(() => ctx.write('? '));
                }
                else {
                    hasElse = true;
                }
                ++i;
                indent(() => {
                    indent(() => {
                        wrap('<>', '</>', () => {
                            ctx.newLine();
                            indent(() => genChildren(branch));
                        });
                    });
                });
                ctx.newLine();
            },
            exit() {
                ctx.typeGuards.pop();
            },
            fn() {
                if (!hasElse) {
                    ctx.write('  : null').newLine();
                }
            },
        });
    });
}
function genTemplateNode(node) {
    wrap('<>', '</>', () => {
        ctx.newLine();
        indent(() => genChildren(node));
    });
}
function breakMapping(loc) {
    // Break mapping
    ctx.deindent();
    ctx.write('  ', loc);
    ctx.indent();
}
function asConst(value) {
    return typeCastAs(value, 'const');
}
function typeCastAs(value, type) {
    return ctx.isTypeScript
        ? `${value} as ${type}`
        : `/** @type {${type}} */ (${value})`;
}
function genAttrTypes(root) {
    const value = ctx.setSourceMapMode(false);
    // TODO: Support components.
    const nodes = [];
    if (root.loc.source.includes('@vue-attrs-target')) {
        templateAstTypes.traverse(root, {
            enter(node, ancestors) {
                if (templateAstTypes.isCommentNode(node)) {
                    if (node.content.includes('@vue-attrs-target')) {
                        const { node: parent, key, index } = shared.last(ancestors);
                        if (index != null) {
                            const el = parent[key]?.[index + 1];
                            if (templateAstTypes.isPlainElementNode(el)) {
                                nodes.push(el);
                            }
                        }
                    }
                }
            },
        });
    }
    else {
        templateAstTypes.traverseEvery(root, (node, ancestors) => {
            if (templateAstTypes.isPlainElementNode(node)) {
                const { node: parent } = shared.last(ancestors);
                if (templateAstTypes.isRootNode(parent)) {
                    if (parent.children.filter(templateAstTypes.isPlainElementNode).length === 1) {
                        nodes.push(node);
                    }
                }
                else {
                    nodes.push(node);
                }
            }
            else if (templateAstTypes.isTemplateNode(node) || templateAstTypes.isRootNode(node)) {
                return true;
            }
            else if (node.type === templateAstTypes.NodeTypes.IF ||
                node.type === templateAstTypes.NodeTypes.IF_BRANCH ||
                node.type === templateAstTypes.NodeTypes.FOR) {
                return true;
            }
            return false;
        });
    }
    ctx.write(`const ${ctx.internalIdentifierPrefix}_attrs = (() => {`).newLine();
    indent(() => {
        const value = typeCastAs('{}', 'unknown');
        ctx.write('return ');
        ctx.write(getRuntimeFn(ctx.typeIdentifier, 'first'));
        ctx.write('(');
        ctx.write(getRuntimeFn(ctx.typeIdentifier, 'flat'));
        ctx.write('([');
        if (nodes.length > 0) {
            indent(() => {
                ctx.newLine();
                for (const node of nodes) {
                    const type = JSON.stringify(node.tag);
                    ctx.write(typeCastAs(value, `${ctx.typeIdentifier}.internal.PropsOf<JSX.IntrinsicElements, ${type}>`));
                    ctx.write(',');
                    ctx.newLine();
                }
            });
        }
        else {
            ctx.write('{}');
        }
        ctx.write(']))');
        ctx.newLine();
    });
    ctx.write('})();').newLine();
    ctx.setSourceMapMode(value);
}

function transformCustomBlock(_block, options) {
    return {
        code: '',
        map: {
            file: options.fileName,
            sources: [],
            names: [],
            mappings: [],
            sourcesContent: [],
        },
    };
}

function transformScript(script, options) {
    const content = script?.content ?? '';
    const result = transforms.transformScript(content, {
        internalIdentifierPrefix: options.internalIdentifierPrefix,
        runtimeModuleName: options.runtimeModuleName,
        typeIdentifier: options.typeIdentifier,
        lang: (script?.lang ?? 'ts'),
        fileName: options.fileName,
        lib: options.typescript,
        cache: options.cache,
    });
    shared.invariant(result.map != null);
    return {
        code: result.code,
        map: result.map,
        identifiers: result.identifiers,
        exportIdentifier: result.componentIdentifier,
        name: result.name,
        inheritAttrs: result.inheritAttrs,
    };
}

function transformScriptSetup(script, options) {
    const content = script?.content ?? '';
    const generic = script?.attrs?.['generic'];
    const result = transforms.transformScriptSetup(content, {
        internalIdentifierPrefix: options.internalIdentifierPrefix,
        runtimeModuleName: options.runtimeModuleName,
        typeIdentifier: options.typeIdentifier,
        lang: (script?.lang ?? 'ts'),
        fileName: options.fileName,
        lib: options.typescript,
        cache: options.cache,
        attrsIdentifier: `${options.internalIdentifierPrefix}_attrs`,
        slotsIdentifier: `${options.internalIdentifierPrefix}_slots`,
        generic: typeof generic === 'string' ? generic : undefined,
    });
    shared.invariant(result.map != null);
    return {
        code: result.code,
        map: result.map,
        identifiers: result.identifiers,
        exportIdentifier: result.privateComponentIdentifier,
        componentIdentifier: result.publicComponentIdentifier,
        scopeIdentifier: result.scopeIdentifier,
        exports: result.exports,
    };
}

function transformStyle(_style, options) {
    return {
        code: '',
        map: {
            file: options.fileName,
            sources: [],
            names: [],
            mappings: [],
            sourcesContent: [],
        },
    };
}

const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
function createTransformFor(customContext) {
    return compilerCore.createStructuralDirectiveTransform(/^for$/, (node, dir, context) => {
        return compilerCore.processFor(node, dir, context, (forNode) => {
            customContext.scope.createNewHoistScope();
            return () => {
                forNode.hoists = customContext.scope.popHoistScope();
            };
        });
    });
}

class Scope {
    constructor(parent = null) {
        this.parent = parent;
        this.bindings = {};
    }
    get identifiers() {
        return Array.from(Object.keys(this.bindings));
    }
    get globals() {
        return this.identifiers.filter((identifier) => this.getBinding(identifier) === null);
    }
    getBinding(identifier) {
        if (identifier in this.bindings)
            return this.bindings[identifier] ?? null;
        if (this.parent != null) {
            return (this.bindings[identifier] = this.parent.getBinding(identifier));
        }
        else {
            this.bindings[identifier] = null;
        }
        return null;
    }
    setBinding(identifier, node) {
        this.bindings[identifier] = node;
    }
}
function withScope(ast) {
    ast.scope = new Scope(null);
    templateAstTypes.traverse(ast, (node, ancestors) => {
        const parent = (ancestors[ancestors.length - 1]?.node ?? ast);
        const scope = (node.scope = node.scope ?? new Scope(parent.scope));
        if (templateAstTypes.isSimpleExpressionNode(node) && !node.isStatic) {
            if (parent != null ||
                !(templateAstTypes.isDirectiveNode(parent) &&
                    ['slot', 'for'].includes(parent.name) &&
                    parent.exp === node)) {
                const isOnDirective = templateAstTypes.isDirectiveNode(parent) && parent.name === 'on';
                getIdentifiers(node.content).forEach((identifier) => {
                    if (isOnDirective && identifier === '$event')
                        return;
                    scope.getBinding(identifier);
                });
            }
        }
        else if (templateAstTypes.isElementNode(node)) {
            node.props.forEach((prop) => {
                if (templateAstTypes.isDirectiveNode(prop)) {
                    const directiveScope = (prop.scope = prop.scope ?? new Scope(scope));
                    if (prop.name === 'slot') {
                        if (templateAstTypes.isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const content = prop.exp.content.trim();
                            getIdentifiers(`(${content}) => {}`, false).forEach((identifier) => {
                                scope.setBinding(identifier, node);
                                localScope.getBinding(identifier);
                            });
                        }
                    }
                    else if (prop.name === 'for') {
                        if (templateAstTypes.isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const match = forAliasRE.exec(prop.exp.content);
                            if (match != null) {
                                const [, LHS, RHS] = match;
                                shared.invariant(LHS != null && RHS != null);
                                getIdentifiers(RHS).forEach((identifier) => {
                                    localScope.getBinding(identifier);
                                });
                                getIdentifiers(`${LHS ?? '()'} => {}`, false).forEach((identifier) => {
                                    scope.setBinding(identifier, node);
                                    localScope.getBinding(identifier);
                                });
                            }
                        }
                    }
                }
            });
        }
    });
    return ast;
}
function getIdentifiers(source, ignoreFunctionParameters = true) {
    source = source
        .trim()
        // Common errors when user is typing.
        .replace(/(\.|\[\]?)\s*$/, '');
    const identifiers = new Set();
    const add = (id) => {
        if (isValidIdentifier(id))
            identifiers.add(id);
    };
    if (compilerCore.isSimpleIdentifier(source.trim())) {
        add(source);
    }
    else {
        try {
            const ast = parseUsingBabel(source, true);
            let definedInScope = new Set();
            const scopes = [];
            const pushScope = (scope) => {
                if (!ignoreFunctionParameters)
                    return;
                scopes.push(scope);
                definedInScope = new Set([...definedInScope, ...scope]);
            };
            const popScope = () => {
                if (!ignoreFunctionParameters)
                    return;
                scopes.pop();
                definedInScope = new Set(scopes.flatMap((scope) => Array.from(scope)));
            };
            types.traverse(ast, {
                enter: (node, ancestors) => {
                    if (types.isFunctionDeclaration(node) || types.isArrowFunctionExpression(node)) {
                        const scope = new Set();
                        node.params.forEach((param) => {
                            types.traverse(param, (node) => {
                                if (types.isIdentifier(node))
                                    scope.add(node.name);
                            });
                        });
                        pushScope(scope);
                    }
                    if (types.isIdentifier(node) && !definedInScope.has(node.name)) {
                        if (shouldTrack(node, ancestors.slice())) {
                            add(node.name);
                        }
                    }
                },
                exit: (node) => {
                    if (types.isFunctionDeclaration(node) || types.isArrowFunctionExpression(node)) {
                        popScope();
                    }
                },
            });
        }
        catch {
            const RE = /\b[a-z$_][a-z0-9$_]+\b/gi;
            let match;
            while ((match = RE.exec(source)) != null) {
                add(match[0] ?? '');
            }
        }
    }
    return identifiers;
}
function isValidIdentifier(id) {
    return (id.trim().length > 0 &&
        !/^(of|in|for|while|function|class|const|let|var|true|false)$/.test(id));
}
function parseUsingBabel(source, withTS = false) {
    try {
        return parser.parse(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
    catch {
        return parser.parseExpression(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
}
// TODO: This misses destructured arguments
function shouldTrack(identifier, ancestors) {
    const ancestor = ancestors.pop();
    if (ancestor == null)
        return true;
    const parent = ancestor.node;
    if (
    // not id of a FunctionDeclaration
    !(types.isFunction(parent) && parent.id === identifier) &&
        // not a key of Property
        !isStaticPropertyKey(identifier, parent) &&
        // not a property of a MemberExpression
        !((types.isMemberExpression(parent) || types.isOptionalMemberExpression(parent)) &&
            parent.property === identifier &&
            !parent.computed) &&
        // skip allowed globals
        !isKnownIdentifier(identifier.name) &&
        // special case for webpack compilation
        identifier.name !== `require` &&
        // is a special keyword but parsed as identifier
        identifier.name !== `arguments`) {
        return true;
    }
    return false;
}
const KNOWN_IDENTIFIERS = new Set(('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt').split(','));
function isKnownIdentifier(value) {
    return KNOWN_IDENTIFIERS.has(value) || /^(true|false|null|this)$/.test(value);
}
function isStaticProperty(node) {
    return types.isObjectMember(node) && !node.computed;
}
function isStaticPropertyKey(node, parent) {
    return isStaticProperty(parent) && parent.key === node;
}

class ScopeManager {
    constructor() {
        this.hoists = [];
        this.identifiers = {};
        this.rootScope = [];
        this.currentScope = this.rootScope;
    }
    getRootScope() {
        return this.rootScope;
    }
    addIdentifier(value) {
        this.identifiers[value] = 1 + (this.identifiers[value] ?? 0);
    }
    hasIdentifier(value) {
        return (this.identifiers[value] ?? 0) > 0;
    }
    removeIdentifier(value) {
        this.identifiers[value] = Math.max(0, this.identifiers[value] ?? 0 - 1);
    }
    scopeHoist(expression) {
        if (typeof expression === 'string') {
            this.currentScope.push(compilerCore.createCompoundExpression([expression]));
        }
        else {
            this.currentScope.push(expression);
        }
    }
    hoist(expression) {
        if (typeof expression === 'string') {
            this.rootScope.push(compilerCore.createCompoundExpression([expression]));
        }
        else {
            this.rootScope.push(expression);
        }
    }
    createNewHoistScope() {
        this.hoists.push(this.currentScope);
        this.currentScope = [];
        return this.currentScope;
    }
    popHoistScope() {
        const scope = this.currentScope;
        this.currentScope = this.hoists.pop() ?? [];
        return scope;
    }
}

function createComponentChildrenTransform(_customContext) {
    return (node) => {
        if (!templateAstTypes.isComponentNode(node))
            return;
        const dir = compilerCore.findDir(node, 'slot', true);
        let hasSlotsAsChildren = false;
        if (dir == null &&
            node.children.some((node) => templateAstTypes.isTemplateNode(node) && compilerCore.findDir(node, 'slot', true) != null)) {
            hasSlotsAsChildren = true;
        }
        return () => {
            if (dir != null) {
                node.props = node.props.filter((prop) => prop !== dir);
                node.slots = [
                    {
                        name: dir.arg,
                        args: dir.exp,
                        hoists: node.hoists ?? [],
                        children: node.children,
                    },
                ];
            }
            else if (hasSlotsAsChildren) {
                node.slots = [];
                const slots = node.slots;
                node.unassignedSlots = node.children.filter((node) => {
                    if (templateAstTypes.isTemplateNode(node)) {
                        const dir = compilerCore.findDir(node, 'slot', true);
                        if (dir != null) {
                            const _if = compilerCore.findDir(node, 'if', true);
                            slots.push({
                                name: dir.arg,
                                args: dir.exp,
                                hoists: node.hoists ?? [],
                                children: _if == null ? node.children : [createIfNode(node, _if)],
                                template: node,
                            });
                            return false;
                        }
                    }
                    return true;
                });
            }
            else {
                node.slots = [
                    {
                        hoists: node.hoists ?? [],
                        children: node.children,
                    },
                ];
            }
        };
    };
}
function createIfNode(node, dir) {
    return {
        type: templateAstTypes.NodeTypes.IF,
        branches: [createIfBranchNode(node, dir)],
        loc: node.loc,
        scope: node.scope,
    };
}
function createIfBranchNode(node, dir) {
    return {
        type: templateAstTypes.NodeTypes.IF_BRANCH,
        children: node.children,
        condition: dir.exp,
        loc: node.loc,
        scope: node.scope,
    };
}

function createTransformIf(_customContext) {
    return compilerCore.createStructuralDirectiveTransform(/^(if|else-if|else)$/, (node, dir, context) => {
        const condition = dir.exp;
        dir.exp = (condition != null
            ? { ...condition }
            : templateAstTypes.createSimpleExpression('undefined', false)); // Prevent condition normalization
        return compilerCore.processIf(node, dir, context, (_ifNode, branch) => () => {
            branch.condition = condition;
        });
    });
}

const directives = new Set('text,html,show,if,else,else-if,for,on,bind,model,slot,pre,cloak,once,is,memo'.split(','));

const s = (text) => JSON.stringify(text) + ' as const';
function createResolveComponentTransform(ctx) {
    const h = getRuntimeFn.bind(null, ctx.typeIdentifier);
    const resolveComponentArgs = `${ctx.isTypeScript
        ? `{} as unknown as ${ctx.internalIdentifierPrefix}GlobalComponents`
        : `/** @type {${ctx.internalIdentifierPrefix}GlobalComponents} */ (/** @type {unknown} */ ({}))`}, ${ctx.isTypeScript
        ? `{} as unknown as JSX.IntrinsicElements`
        : `/** @type JSX.IntrinsicElements} */ (/** @type {unknown} */ ({}))`}, ${ctx.contextIdentifier}, `;
    return (node) => {
        if (!templateAstTypes.isElementNode(node))
            return;
        if (templateAstTypes.isElementNode(node)) {
            node.props.forEach((node) => {
                if (templateAstTypes.isDirectiveNode(node) && !directives.has(node.name)) {
                    ctx.used.directives.add(node.name);
                    const id = `v${shared.pascalCase(node.name)}`;
                    node.resolvedName = id;
                    if (!ctx.scope.hasIdentifier(id)) {
                        const knownId = ctx.identifiers.get(id);
                        if (knownId == null) {
                            ctx.scope.addIdentifier(id);
                            ctx.scope.hoist(compilerCore.createCompoundExpression([
                                'const ',
                                id,
                                ` = ${h('resolveDirective')}(${ctx.contextIdentifier}, `,
                                s(node.name),
                                ', ',
                                s(shared.camelCase(node.name)),
                                ');',
                            ]));
                        }
                        else if (mayBeRef(knownId)) {
                            ctx.scope.addIdentifier(id);
                            ctx.scope.hoist(compilerCore.createCompoundExpression([
                                `const ${id} = ${ctx.internalIdentifierPrefix}_get_identifier_${id}();`,
                            ]));
                        }
                    }
                }
            });
        }
        let isProp = compilerCore.findDir(node, 'is');
        if (isProp != null) {
            node.tagType = 1;
            node.tag = 'component';
        }
        if (!templateAstTypes.isComponentNode(node))
            return;
        if (node.tag !== 'component') {
            if (/[A-Z.-]/.test(node.tag)) {
                ctx.used.components.add(node.tag);
                const name = node.tag.split('.')[0] ?? node.tag;
                const id = `${shared.pascalCase(name)}`;
                node.resolvedName = node.tag.includes('.')
                    ? id + node.tag.slice(name.length)
                    : id;
                if (!ctx.scope.hasIdentifier(id)) {
                    const knownId = ctx.identifiers.get(id);
                    if (knownId == null || !templateAstTypes.isSimpleIdentifier(id)) {
                        ctx.used.components.add(id);
                        ctx.scope.addIdentifier(id);
                        ctx.scope.hoist(compilerCore.createCompoundExpression([
                            'const ',
                            id,
                            ` = ${h('resolveComponent')}(${resolveComponentArgs}`,
                            templateAstTypes.isSimpleIdentifier(id)
                                ? `${ctx.internalIdentifierPrefix}_get_identifier_${id}()`
                                : 'null',
                            ', ',
                            s(name),
                            ', ',
                            s(shared.pascalCase(name)),
                            ');',
                        ]));
                    }
                    else if (mayBeRef(knownId)) {
                        ctx.used.components.add(id);
                        ctx.scope.addIdentifier(id);
                        ctx.scope.hoist(compilerCore.createCompoundExpression([
                            `const ${id} = ${ctx.internalIdentifierPrefix}_get_identifier_${id}();`,
                        ]));
                    }
                }
            }
            return undefined;
        }
        else {
            isProp = isProp ?? compilerCore.findProp(node, 'is');
            if (isProp != null)
                node.is = isProp;
            node.props = node.props.filter((prop) => prop !== isProp);
        }
        return undefined;
    };
}
function mayBeRef(id) {
    return (id.kind === 'ref' ||
        id.kind === 'maybeRef' ||
        id.kind === 'externalRef' ||
        id.kind === 'externalMaybeRef');
}

function createSlotHoistScopeTransform(context) {
    return (node) => {
        if (!templateAstTypes.isElementNode(node))
            return;
        const dir = compilerCore.findDir(node, 'slot', true);
        if (dir == null)
            return;
        node.hoists = context.scope.createNewHoistScope();
        return () => {
            node.hoists = context.scope.popHoistScope();
        };
    };
}

const namedCharacterReferences = {
    GT: '>',
    gt: '>',
    LT: '<',
    lt: '<',
    'ac;': '',
    'af;': '',
    AMP: '&',
    amp: '&',
    'ap;': '',
    'DD;': '',
    'dd;': '',
    deg: '',
    'ee;': '',
    'eg;': '',
    'el;': '',
    ETH: '',
    eth: '',
    'gE;': '',
    'ge;': '',
    'Gg;': '',
    'gg;': '',
    'gl;': '',
    'GT;': '>',
    'Gt;': '',
    'gt;': '>',
    'ic;': '',
    'ii;': '',
    'Im;': '',
    'in;': '',
    'it;': '',
    'lE;': '',
    'le;': '',
    'lg;': '',
    'Ll;': '',
    'll;': '',
    'LT;': '<',
    'Lt;': '',
    'lt;': '<',
    'mp;': '',
    'Mu;': '',
    'mu;': '',
    'ne;': '',
    'ni;': '',
    not: '',
    'Nu;': '',
    'nu;': '',
    'Or;': '',
    'or;': '',
    'oS;': '',
    'Pi;': '',
    'pi;': '',
    'pm;': '',
    'Pr;': '',
    'pr;': '',
    'Re;': '',
    REG: '',
    reg: '',
    'rx;': '',
    'Sc;': '',
    'sc;': '',
    shy: '',
    uml: '',
    'wp;': '',
    'wr;': '',
    'Xi;': '',
    'xi;': '',
    yen: '',
    'acd;': '',
    'acE;': '',
    'Acy;': '',
    'acy;': '',
    'Afr;': '',
    'afr;': '',
    'AMP;': '&',
    'amp;': '&',
    'And;': '',
    'and;': '',
    'ang;': '',
    'apE;': '',
    'ape;': '',
    'ast;': '*',
    Auml: '',
    auml: '',
    'Bcy;': '',
    'bcy;': '',
    'Bfr;': '',
    'bfr;': '',
    'bne;': '=',
    'bot;': '',
    'Cap;': '',
    'cap;': '',
    cent: '',
    'Cfr;': '',
    'cfr;': '',
    'Chi;': '',
    'chi;': '',
    'cir;': '',
    COPY: '',
    copy: '',
    'Cup;': '',
    'cup;': '',
    'Dcy;': '',
    'dcy;': '',
    'deg;': '',
    'Del;': '',
    'Dfr;': '',
    'dfr;': '',
    'die;': '',
    'div;': '',
    'Dot;': '',
    'dot;': '',
    'Ecy;': '',
    'ecy;': '',
    'Efr;': '',
    'efr;': '',
    'egs;': '',
    'ell;': '',
    'els;': '',
    'ENG;': '',
    'eng;': '',
    'Eta;': '',
    'eta;': '',
    'ETH;': '',
    'eth;': '',
    Euml: '',
    euml: '',
    'Fcy;': '',
    'fcy;': '',
    'Ffr;': '',
    'ffr;': '',
    'gap;': '',
    'Gcy;': '',
    'gcy;': '',
    'gEl;': '',
    'gel;': '',
    'geq;': '',
    'ges;': '',
    'Gfr;': '',
    'gfr;': '',
    'ggg;': '',
    'gla;': '',
    'glE;': '',
    'glj;': '',
    'gnE;': '',
    'gne;': '',
    'Hat;': '^',
    'Hfr;': '',
    'hfr;': '',
    'Icy;': '',
    'icy;': '',
    'iff;': '',
    'Ifr;': '',
    'ifr;': '',
    'Int;': '',
    'int;': '',
    Iuml: '',
    iuml: '',
    'Jcy;': '',
    'jcy;': '',
    'Jfr;': '',
    'jfr;': '',
    'Kcy;': '',
    'kcy;': '',
    'Kfr;': '',
    'kfr;': '',
    'lap;': '',
    'lat;': '',
    'Lcy;': '',
    'lcy;': '',
    'lEg;': '',
    'leg;': '',
    'leq;': '',
    'les;': '',
    'Lfr;': '',
    'lfr;': '',
    'lgE;': '',
    'lnE;': '',
    'lne;': '',
    'loz;': '',
    'lrm;': '',
    'Lsh;': '',
    'lsh;': '',
    macr: '',
    'Map;': '',
    'map;': '',
    'Mcy;': '',
    'mcy;': '',
    'Mfr;': '',
    'mfr;': '',
    'mho;': '',
    'mid;': '',
    'nap;': '',
    nbsp: ' ',
    'Ncy;': '',
    'ncy;': '',
    'Nfr;': '',
    'nfr;': '',
    'ngE;': '',
    'nge;': '',
    'nGg;': '',
    'nGt;': '',
    'ngt;': '',
    'nis;': '',
    'niv;': '',
    'nlE;': '',
    'nle;': '',
    'nLl;': '',
    'nLt;': '',
    'nlt;': '',
    'Not;': '',
    'not;': '',
    'npr;': '',
    'nsc;': '',
    'num;': '#',
    'Ocy;': '',
    'ocy;': '',
    'Ofr;': '',
    'ofr;': '',
    'ogt;': '',
    'ohm;': '',
    'olt;': '',
    'ord;': '',
    ordf: '',
    ordm: '',
    'orv;': '',
    Ouml: '',
    ouml: '',
    'par;': '',
    para: '',
    'Pcy;': '',
    'pcy;': '',
    'Pfr;': '',
    'pfr;': '',
    'Phi;': '',
    'phi;': '',
    'piv;': '',
    'prE;': '',
    'pre;': '',
    'Psi;': '',
    'psi;': '',
    'Qfr;': '',
    'qfr;': '',
    QUOT: '"',
    quot: '"',
    'Rcy;': '',
    'rcy;': '',
    'REG;': '',
    'reg;': '',
    'Rfr;': '',
    'rfr;': '',
    'Rho;': '',
    'rho;': '',
    'rlm;': '',
    'Rsh;': '',
    'rsh;': '',
    'scE;': '',
    'sce;': '',
    'Scy;': '',
    'scy;': '',
    sect: '',
    'Sfr;': '',
    'sfr;': '',
    'shy;': '',
    'sim;': '',
    'smt;': '',
    'sol;': '/',
    'squ;': '',
    'Sub;': '',
    'sub;': '',
    'Sum;': '',
    'sum;': '',
    'Sup;': '',
    'sup;': '',
    sup1: '',
    sup2: '',
    sup3: '',
    'Tab;': '\t',
    'Tau;': '',
    'tau;': '',
    'Tcy;': '',
    'tcy;': '',
    'Tfr;': '',
    'tfr;': '',
    'top;': '',
    'Ucy;': '',
    'ucy;': '',
    'Ufr;': '',
    'ufr;': '',
    'uml;': '',
    Uuml: '',
    uuml: '',
    'Vcy;': '',
    'vcy;': '',
    'Vee;': '',
    'vee;': '',
    'Vfr;': '',
    'vfr;': '',
    'Wfr;': '',
    'wfr;': '',
    'Xfr;': '',
    'xfr;': '',
    'Ycy;': '',
    'ycy;': '',
    'yen;': '',
    'Yfr;': '',
    'yfr;': '',
    yuml: '',
    'Zcy;': '',
    'zcy;': '',
    'Zfr;': '',
    'zfr;': '',
    'zwj;': '',
    Acirc: '',
    acirc: '',
    acute: '',
    AElig: '',
    aelig: '',
    'andd;': '',
    'andv;': '',
    'ange;': '',
    'Aopf;': '',
    'aopf;': '',
    'apid;': '',
    'apos;': "'",
    Aring: '',
    aring: '',
    'Ascr;': '',
    'ascr;': '',
    'Auml;': '',
    'auml;': '',
    'Barv;': '',
    'bbrk;': '',
    'Beta;': '',
    'beta;': '',
    'beth;': '',
    'bNot;': '',
    'bnot;': '',
    'Bopf;': '',
    'bopf;': '',
    'boxH;': '',
    'boxh;': '',
    'boxV;': '',
    'boxv;': '',
    'Bscr;': '',
    'bscr;': '',
    'bsim;': '',
    'bsol;': '\\',
    'bull;': '',
    'bump;': '',
    'caps;': '',
    'Cdot;': '',
    'cdot;': '',
    cedil: '',
    'cent;': '',
    'CHcy;': '',
    'chcy;': '',
    'circ;': '',
    'cirE;': '',
    'cire;': '',
    'comp;': '',
    'cong;': '',
    'Copf;': '',
    'copf;': '',
    'COPY;': '',
    'copy;': '',
    'Cscr;': '',
    'cscr;': '',
    'csub;': '',
    'csup;': '',
    'cups;': '',
    'Darr;': '',
    'dArr;': '',
    'darr;': '',
    'dash;': '',
    'dHar;': '',
    'diam;': '',
    'DJcy;': '',
    'djcy;': '',
    'Dopf;': '',
    'dopf;': '',
    'Dscr;': '',
    'dscr;': '',
    'DScy;': '',
    'dscy;': '',
    'dsol;': '',
    'dtri;': '',
    'DZcy;': '',
    'dzcy;': '',
    'ecir;': '',
    Ecirc: '',
    ecirc: '',
    'Edot;': '',
    'eDot;': '',
    'edot;': '',
    'emsp;': '',
    'ensp;': '',
    'Eopf;': '',
    'eopf;': '',
    'epar;': '',
    'epsi;': '',
    'Escr;': '',
    'escr;': '',
    'Esim;': '',
    'esim;': '',
    'Euml;': '',
    'euml;': '',
    'euro;': '',
    'excl;': '!',
    'flat;': '',
    'fnof;': '',
    'Fopf;': '',
    'fopf;': '',
    'fork;': '',
    'Fscr;': '',
    'fscr;': '',
    'Gdot;': '',
    'gdot;': '',
    'geqq;': '',
    'gesl;': '',
    'GJcy;': '',
    'gjcy;': '',
    'gnap;': '',
    'gneq;': '',
    'Gopf;': '',
    'gopf;': '',
    'Gscr;': '',
    'gscr;': '',
    'gsim;': '',
    'gtcc;': '',
    'gvnE;': '',
    'half;': '',
    'hArr;': '',
    'harr;': '',
    'hbar;': '',
    'Hopf;': '',
    'hopf;': '',
    'Hscr;': '',
    'hscr;': '',
    Icirc: '',
    icirc: '',
    'Idot;': '',
    'IEcy;': '',
    'iecy;': '',
    iexcl: '',
    'imof;': '',
    'IOcy;': '',
    'iocy;': '',
    'Iopf;': '',
    'iopf;': '',
    'Iota;': '',
    'iota;': '',
    'Iscr;': '',
    'iscr;': '',
    'isin;': '',
    'Iuml;': '',
    'iuml;': '',
    'Jopf;': '',
    'jopf;': '',
    'Jscr;': '',
    'jscr;': '',
    'KHcy;': '',
    'khcy;': '',
    'KJcy;': '',
    'kjcy;': '',
    'Kopf;': '',
    'kopf;': '',
    'Kscr;': '',
    'kscr;': '',
    'Lang;': '',
    'lang;': '',
    laquo: '',
    'Larr;': '',
    'lArr;': '',
    'larr;': '',
    'late;': '',
    'lcub;': '{',
    'ldca;': '',
    'ldsh;': '',
    'leqq;': '',
    'lesg;': '',
    'lHar;': '',
    'LJcy;': '',
    'ljcy;': '',
    'lnap;': '',
    'lneq;': '',
    'Lopf;': '',
    'lopf;': '',
    'lozf;': '',
    'lpar;': '(',
    'Lscr;': '',
    'lscr;': '',
    'lsim;': '',
    'lsqb;': '[',
    'ltcc;': '',
    'ltri;': '',
    'lvnE;': '',
    'macr;': '',
    'male;': '',
    'malt;': '',
    micro: '',
    'mlcp;': '',
    'mldr;': '',
    'Mopf;': '',
    'mopf;': '',
    'Mscr;': '',
    'mscr;': '',
    'nang;': '',
    'napE;': '',
    'nbsp;': ' ',
    'ncap;': '',
    'ncup;': '',
    'ngeq;': '',
    'nges;': '',
    'ngtr;': '',
    'nGtv;': '',
    'nisd;': '',
    'NJcy;': '',
    'njcy;': '',
    'nldr;': '',
    'nleq;': '',
    'nles;': '',
    'nLtv;': '',
    'nmid;': '',
    'Nopf;': '',
    'nopf;': '',
    'npar;': '',
    'npre;': '',
    'nsce;': '',
    'Nscr;': '',
    'nscr;': '',
    'nsim;': '',
    'nsub;': '',
    'nsup;': '',
    'ntgl;': '',
    'ntlg;': '',
    'nvap;': '',
    'nvge;': '',
    'nvgt;': '>',
    'nvle;': '',
    'nvlt;': '<',
    'oast;': '',
    'ocir;': '',
    Ocirc: '',
    ocirc: '',
    'odiv;': '',
    'odot;': '',
    'ogon;': '',
    'oint;': '',
    'omid;': '',
    'Oopf;': '',
    'oopf;': '',
    'opar;': '',
    'ordf;': '',
    'ordm;': '',
    'oror;': '',
    'Oscr;': '',
    'oscr;': '',
    'osol;': '',
    'Ouml;': '',
    'ouml;': '',
    'para;': '',
    'part;': '',
    'perp;': '',
    'phiv;': '',
    'plus;': '+',
    'Popf;': '',
    'popf;': '',
    pound: '',
    'prap;': '',
    'prec;': '',
    'prnE;': '',
    'prod;': '',
    'prop;': '',
    'Pscr;': '',
    'pscr;': '',
    'qint;': '',
    'Qopf;': '',
    'qopf;': '',
    'Qscr;': '',
    'qscr;': '',
    'QUOT;': '"',
    'quot;': '"',
    'race;': '',
    'Rang;': '',
    'rang;': '',
    raquo: '',
    'Rarr;': '',
    'rArr;': '',
    'rarr;': '',
    'rcub;': '}',
    'rdca;': '',
    'rdsh;': '',
    'real;': '',
    'rect;': '',
    'rHar;': '',
    'rhov;': '',
    'ring;': '',
    'Ropf;': '',
    'ropf;': '',
    'rpar;': ')',
    'Rscr;': '',
    'rscr;': '',
    'rsqb;': ']',
    'rtri;': '',
    'scap;': '',
    'scnE;': '',
    'sdot;': '',
    'sect;': '',
    'semi;': ';',
    'sext;': '',
    'SHcy;': '',
    'shcy;': '',
    'sime;': '',
    'simg;': '',
    'siml;': '',
    'smid;': '',
    'smte;': '',
    'solb;': '',
    'Sopf;': '',
    'sopf;': '',
    'spar;': '',
    'Sqrt;': '',
    'squf;': '',
    'Sscr;': '',
    'sscr;': '',
    'Star;': '',
    'star;': '',
    'subE;': '',
    'sube;': '',
    'succ;': '',
    'sung;': '',
    'sup1;': '',
    'sup2;': '',
    'sup3;': '',
    'supE;': '',
    'supe;': '',
    szlig: '',
    'tbrk;': '',
    'tdot;': '',
    THORN: '',
    thorn: '',
    times: '',
    'tint;': '',
    'toea;': '',
    'Topf;': '',
    'topf;': '',
    'tosa;': '',
    'trie;': '',
    'Tscr;': '',
    'tscr;': '',
    'TScy;': '',
    'tscy;': '',
    'Uarr;': '',
    'uArr;': '',
    'uarr;': '',
    Ucirc: '',
    ucirc: '',
    'uHar;': '',
    'Uopf;': '',
    'uopf;': '',
    'Upsi;': '',
    'upsi;': '',
    'Uscr;': '',
    'uscr;': '',
    'utri;': '',
    'Uuml;': '',
    'uuml;': '',
    'vArr;': '',
    'varr;': '',
    'Vbar;': '',
    'vBar;': '',
    'Vert;': '',
    'vert;': '|',
    'Vopf;': '',
    'vopf;': '',
    'Vscr;': '',
    'vscr;': '',
    'Wopf;': '',
    'wopf;': '',
    'Wscr;': '',
    'wscr;': '',
    'xcap;': '',
    'xcup;': '',
    'xmap;': '',
    'xnis;': '',
    'Xopf;': '',
    'xopf;': '',
    'Xscr;': '',
    'xscr;': '',
    'xvee;': '',
    'YAcy;': '',
    'yacy;': '',
    'YIcy;': '',
    'yicy;': '',
    'Yopf;': '',
    'yopf;': '',
    'Yscr;': '',
    'yscr;': '',
    'YUcy;': '',
    'yucy;': '',
    'Yuml;': '',
    'yuml;': '',
    'Zdot;': '',
    'zdot;': '',
    'Zeta;': '',
    'zeta;': '',
    'ZHcy;': '',
    'zhcy;': '',
    'Zopf;': '',
    'zopf;': '',
    'Zscr;': '',
    'zscr;': '',
    'zwnj;': '',
    Aacute: '',
    aacute: '',
    'Acirc;': '',
    'acirc;': '',
    'acute;': '',
    'AElig;': '',
    'aelig;': '',
    Agrave: '',
    agrave: '',
    'aleph;': '',
    'Alpha;': '',
    'alpha;': '',
    'Amacr;': '',
    'amacr;': '',
    'amalg;': '',
    'angle;': '',
    'angrt;': '',
    'angst;': '',
    'Aogon;': '',
    'aogon;': '',
    'Aring;': '',
    'aring;': '',
    'asymp;': '',
    Atilde: '',
    atilde: '',
    'awint;': '',
    'bcong;': '',
    'bdquo;': '',
    'bepsi;': '',
    'blank;': '',
    'blk12;': '',
    'blk14;': '',
    'blk34;': '',
    'block;': '',
    'boxDL;': '',
    'boxDl;': '',
    'boxdL;': '',
    'boxdl;': '',
    'boxDR;': '',
    'boxDr;': '',
    'boxdR;': '',
    'boxdr;': '',
    'boxHD;': '',
    'boxHd;': '',
    'boxhD;': '',
    'boxhd;': '',
    'boxHU;': '',
    'boxHu;': '',
    'boxhU;': '',
    'boxhu;': '',
    'boxUL;': '',
    'boxUl;': '',
    'boxuL;': '',
    'boxul;': '',
    'boxUR;': '',
    'boxUr;': '',
    'boxuR;': '',
    'boxur;': '',
    'boxVH;': '',
    'boxVh;': '',
    'boxvH;': '',
    'boxvh;': '',
    'boxVL;': '',
    'boxVl;': '',
    'boxvL;': '',
    'boxvl;': '',
    'boxVR;': '',
    'boxVr;': '',
    'boxvR;': '',
    'boxvr;': '',
    'Breve;': '',
    'breve;': '',
    brvbar: '',
    'bsemi;': '',
    'bsime;': '',
    'bsolb;': '',
    'bumpE;': '',
    'bumpe;': '',
    'caret;': '',
    'caron;': '',
    'ccaps;': '',
    Ccedil: '',
    ccedil: '',
    'Ccirc;': '',
    'ccirc;': '',
    'ccups;': '',
    'cedil;': '',
    'check;': '',
    'clubs;': '',
    'Colon;': '',
    'colon;': ':',
    'comma;': ',',
    'crarr;': '',
    'Cross;': '',
    'cross;': '',
    'csube;': '',
    'csupe;': '',
    'ctdot;': '',
    'cuepr;': '',
    'cuesc;': '',
    'cupor;': '',
    curren: '',
    'cuvee;': '',
    'cuwed;': '',
    'cwint;': '',
    'Dashv;': '',
    'dashv;': '',
    'dblac;': '',
    'ddarr;': '',
    'Delta;': '',
    'delta;': '',
    'dharl;': '',
    'dharr;': '',
    'diams;': '',
    'disin;': '',
    divide: '',
    'doteq;': '',
    'dtdot;': '',
    'dtrif;': '',
    'duarr;': '',
    'duhar;': '',
    Eacute: '',
    eacute: '',
    'Ecirc;': '',
    'ecirc;': '',
    'eDDot;': '',
    'efDot;': '',
    Egrave: '',
    egrave: '',
    'Emacr;': '',
    'emacr;': '',
    'empty;': '',
    'Eogon;': '',
    'eogon;': '',
    'eplus;': '',
    'epsiv;': '',
    'eqsim;': '',
    'Equal;': '',
    'equiv;': '',
    'erarr;': '',
    'erDot;': '',
    'esdot;': '',
    'exist;': '',
    'fflig;': '',
    'filig;': '',
    'fjlig;': 'fj',
    'fllig;': '',
    'fltns;': '',
    'forkv;': '',
    frac12: '',
    frac14: '',
    frac34: '',
    'frasl;': '',
    'frown;': '',
    'Gamma;': '',
    'gamma;': '',
    'Gcirc;': '',
    'gcirc;': '',
    'gescc;': '',
    'gimel;': '',
    'gneqq;': '',
    'gnsim;': '',
    'grave;': '`',
    'gsime;': '',
    'gsiml;': '',
    'gtcir;': '',
    'gtdot;': '',
    'Hacek;': '',
    'harrw;': '',
    'Hcirc;': '',
    'hcirc;': '',
    'hoarr;': '',
    Iacute: '',
    iacute: '',
    'Icirc;': '',
    'icirc;': '',
    'iexcl;': '',
    Igrave: '',
    igrave: '',
    'iiint;': '',
    'iiota;': '',
    'IJlig;': '',
    'ijlig;': '',
    'Imacr;': '',
    'imacr;': '',
    'image;': '',
    'imath;': '',
    'imped;': '',
    'infin;': '',
    'Iogon;': '',
    'iogon;': '',
    'iprod;': '',
    iquest: '',
    'isinE;': '',
    'isins;': '',
    'isinv;': '',
    'Iukcy;': '',
    'iukcy;': '',
    'Jcirc;': '',
    'jcirc;': '',
    'jmath;': '',
    'Jukcy;': '',
    'jukcy;': '',
    'Kappa;': '',
    'kappa;': '',
    'lAarr;': '',
    'langd;': '',
    'laquo;': '',
    'larrb;': '',
    'lates;': '',
    'lBarr;': '',
    'lbarr;': '',
    'lbbrk;': '',
    'lbrke;': '',
    'lceil;': '',
    'ldquo;': '',
    'lescc;': '',
    'lhard;': '',
    'lharu;': '',
    'lhblk;': '',
    'llarr;': '',
    'lltri;': '',
    'lneqq;': '',
    'lnsim;': '',
    'loang;': '',
    'loarr;': '',
    'lobrk;': '',
    'lopar;': '',
    'lrarr;': '',
    'lrhar;': '',
    'lrtri;': '',
    'lsime;': '',
    'lsimg;': '',
    'lsquo;': '',
    'ltcir;': '',
    'ltdot;': '',
    'ltrie;': '',
    'ltrif;': '',
    'mdash;': '',
    'mDDot;': '',
    'micro;': '',
    middot: '',
    'minus;': '',
    'mumap;': '',
    'nabla;': '',
    'napid;': '',
    'napos;': '',
    'natur;': '',
    'nbump;': '',
    'ncong;': '',
    'ndash;': '',
    'neArr;': '',
    'nearr;': '',
    'nedot;': '',
    'nesim;': '',
    'ngeqq;': '',
    'ngsim;': '',
    'nhArr;': '',
    'nharr;': '',
    'nhpar;': '',
    'nlArr;': '',
    'nlarr;': '',
    'nleqq;': '',
    'nless;': '',
    'nlsim;': '',
    'nltri;': '',
    'notin;': '',
    'notni;': '',
    'npart;': '',
    'nprec;': '',
    'nrArr;': '',
    'nrarr;': '',
    'nrtri;': '',
    'nsime;': '',
    'nsmid;': '',
    'nspar;': '',
    'nsubE;': '',
    'nsube;': '',
    'nsucc;': '',
    'nsupE;': '',
    'nsupe;': '',
    Ntilde: '',
    ntilde: '',
    'numsp;': '',
    'nvsim;': '',
    'nwArr;': '',
    'nwarr;': '',
    Oacute: '',
    oacute: '',
    'Ocirc;': '',
    'ocirc;': '',
    'odash;': '',
    'OElig;': '',
    'oelig;': '',
    'ofcir;': '',
    Ograve: '',
    ograve: '',
    'ohbar;': '',
    'olarr;': '',
    'olcir;': '',
    'oline;': '',
    'Omacr;': '',
    'omacr;': '',
    'Omega;': '',
    'omega;': '',
    'operp;': '',
    'oplus;': '',
    'orarr;': '',
    'order;': '',
    Oslash: '',
    oslash: '',
    Otilde: '',
    otilde: '',
    'ovbar;': '',
    'parsl;': '',
    'phone;': '',
    'plusb;': '',
    'pluse;': '',
    plusmn: '',
    'pound;': '',
    'prcue;': '',
    'Prime;': '',
    'prime;': '',
    'prnap;': '',
    'prsim;': '',
    'quest;': '?',
    'rAarr;': '',
    'radic;': '',
    'rangd;': '',
    'range;': '',
    'raquo;': '',
    'rarrb;': '',
    'rarrc;': '',
    'rarrw;': '',
    'ratio;': '',
    'RBarr;': '',
    'rBarr;': '',
    'rbarr;': '',
    'rbbrk;': '',
    'rbrke;': '',
    'rceil;': '',
    'rdquo;': '',
    'reals;': '',
    'rhard;': '',
    'rharu;': '',
    'rlarr;': '',
    'rlhar;': '',
    'rnmid;': '',
    'roang;': '',
    'roarr;': '',
    'robrk;': '',
    'ropar;': '',
    'rrarr;': '',
    'rsquo;': '',
    'rtrie;': '',
    'rtrif;': '',
    'sbquo;': '',
    'sccue;': '',
    'Scirc;': '',
    'scirc;': '',
    'scnap;': '',
    'scsim;': '',
    'sdotb;': '',
    'sdote;': '',
    'seArr;': '',
    'searr;': '',
    'setmn;': '',
    'sharp;': '',
    'Sigma;': '',
    'sigma;': '',
    'simeq;': '',
    'simgE;': '',
    'simlE;': '',
    'simne;': '',
    'slarr;': '',
    'smile;': '',
    'smtes;': '',
    'sqcap;': '',
    'sqcup;': '',
    'sqsub;': '',
    'sqsup;': '',
    'srarr;': '',
    'starf;': '',
    'strns;': '',
    'subnE;': '',
    'subne;': '',
    'supnE;': '',
    'supne;': '',
    'swArr;': '',
    'swarr;': '',
    'szlig;': '',
    'Theta;': '',
    'theta;': '',
    'thkap;': '',
    'THORN;': '',
    'thorn;': '',
    'Tilde;': '',
    'tilde;': '',
    'times;': '',
    'TRADE;': '',
    'trade;': '',
    'trisb;': '',
    'TSHcy;': '',
    'tshcy;': '',
    'twixt;': '',
    Uacute: '',
    uacute: '',
    'Ubrcy;': '',
    'ubrcy;': '',
    'Ucirc;': '',
    'ucirc;': '',
    'udarr;': '',
    'udhar;': '',
    Ugrave: '',
    ugrave: '',
    'uharl;': '',
    'uharr;': '',
    'uhblk;': '',
    'ultri;': '',
    'Umacr;': '',
    'umacr;': '',
    'Union;': '',
    'Uogon;': '',
    'uogon;': '',
    'uplus;': '',
    'upsih;': '',
    'UpTee;': '',
    'Uring;': '',
    'uring;': '',
    'urtri;': '',
    'utdot;': '',
    'utrif;': '',
    'uuarr;': '',
    'varpi;': '',
    'vBarv;': '',
    'VDash;': '',
    'Vdash;': '',
    'vDash;': '',
    'vdash;': '',
    'veeeq;': '',
    'vltri;': '',
    'vnsub;': '',
    'vnsup;': '',
    'vprop;': '',
    'vrtri;': '',
    'Wcirc;': '',
    'wcirc;': '',
    'Wedge;': '',
    'wedge;': '',
    'xcirc;': '',
    'xdtri;': '',
    'xhArr;': '',
    'xharr;': '',
    'xlArr;': '',
    'xlarr;': '',
    'xodot;': '',
    'xrArr;': '',
    'xrarr;': '',
    'xutri;': '',
    Yacute: '',
    yacute: '',
    'Ycirc;': '',
    'ycirc;': '',
    'Aacute;': '',
    'aacute;': '',
    'Abreve;': '',
    'abreve;': '',
    'Agrave;': '',
    'agrave;': '',
    'andand;': '',
    'angmsd;': '',
    'angsph;': '',
    'apacir;': '',
    'approx;': '',
    'Assign;': '',
    'Atilde;': '',
    'atilde;': '',
    'barvee;': '',
    'Barwed;': '',
    'barwed;': '',
    'becaus;': '',
    'bernou;': '',
    'bigcap;': '',
    'bigcup;': '',
    'bigvee;': '',
    'bkarow;': '',
    'bottom;': '',
    'bowtie;': '',
    'boxbox;': '',
    'bprime;': '',
    'brvbar;': '',
    'bullet;': '',
    'Bumpeq;': '',
    'bumpeq;': '',
    'Cacute;': '',
    'cacute;': '',
    'capand;': '',
    'capcap;': '',
    'capcup;': '',
    'capdot;': '',
    'Ccaron;': '',
    'ccaron;': '',
    'Ccedil;': '',
    'ccedil;': '',
    'circeq;': '',
    'cirmid;': '',
    'Colone;': '',
    'colone;': '',
    'commat;': '@',
    'compfn;': '',
    'Conint;': '',
    'conint;': '',
    'coprod;': '',
    'copysr;': '',
    'cularr;': '',
    'CupCap;': '',
    'cupcap;': '',
    'cupcup;': '',
    'cupdot;': '',
    'curarr;': '',
    'curren;': '',
    'cylcty;': '',
    'Dagger;': '',
    'dagger;': '',
    'daleth;': '',
    'Dcaron;': '',
    'dcaron;': '',
    'dfisht;': '',
    'divide;': '',
    'divonx;': '',
    'dlcorn;': '',
    'dlcrop;': '',
    'dollar;': '$',
    'DotDot;': '',
    'drcorn;': '',
    'drcrop;': '',
    'Dstrok;': '',
    'dstrok;': '',
    'Eacute;': '',
    'eacute;': '',
    'easter;': '',
    'Ecaron;': '',
    'ecaron;': '',
    'ecolon;': '',
    'Egrave;': '',
    'egrave;': '',
    'egsdot;': '',
    'elsdot;': '',
    'emptyv;': '',
    'emsp13;': '',
    'emsp14;': '',
    'eparsl;': '',
    'eqcirc;': '',
    'equals;': '=',
    'equest;': '',
    'Exists;': '',
    'female;': '',
    'ffilig;': '',
    'ffllig;': '',
    'ForAll;': '',
    'forall;': '',
    'frac12;': '',
    'frac13;': '',
    'frac14;': '',
    'frac15;': '',
    'frac16;': '',
    'frac18;': '',
    'frac23;': '',
    'frac25;': '',
    'frac34;': '',
    'frac35;': '',
    'frac38;': '',
    'frac45;': '',
    'frac56;': '',
    'frac58;': '',
    'frac78;': '',
    'gacute;': '',
    'Gammad;': '',
    'gammad;': '',
    'Gbreve;': '',
    'gbreve;': '',
    'Gcedil;': '',
    'gesdot;': '',
    'gesles;': '',
    'gtlPar;': '',
    'gtrarr;': '',
    'gtrdot;': '',
    'gtrsim;': '',
    'hairsp;': '',
    'hamilt;': '',
    'HARDcy;': '',
    'hardcy;': '',
    'hearts;': '',
    'hellip;': '',
    'hercon;': '',
    'homtht;': '',
    'horbar;': '',
    'hslash;': '',
    'Hstrok;': '',
    'hstrok;': '',
    'hybull;': '',
    'hyphen;': '',
    'Iacute;': '',
    'iacute;': '',
    'Igrave;': '',
    'igrave;': '',
    'iiiint;': '',
    'iinfin;': '',
    'incare;': '',
    'inodot;': '',
    'intcal;': '',
    'iquest;': '',
    'isinsv;': '',
    'Itilde;': '',
    'itilde;': '',
    'Jsercy;': '',
    'jsercy;': '',
    'kappav;': '',
    'Kcedil;': '',
    'kcedil;': '',
    'kgreen;': '',
    'Lacute;': '',
    'lacute;': '',
    'lagran;': '',
    'Lambda;': '',
    'lambda;': '',
    'langle;': '',
    'larrfs;': '',
    'larrhk;': '',
    'larrlp;': '',
    'larrpl;': '',
    'larrtl;': '',
    'lAtail;': '',
    'latail;': '',
    'lbrace;': '{',
    'lbrack;': '[',
    'Lcaron;': '',
    'lcaron;': '',
    'Lcedil;': '',
    'lcedil;': '',
    'ldquor;': '',
    'lesdot;': '',
    'lesges;': '',
    'lfisht;': '',
    'lfloor;': '',
    'lharul;': '',
    'llhard;': '',
    'Lmidot;': '',
    'lmidot;': '',
    'lmoust;': '',
    'loplus;': '',
    'lowast;': '',
    'lowbar;': '_',
    'lparlt;': '',
    'lrhard;': '',
    'lsaquo;': '',
    'lsquor;': '',
    'Lstrok;': '',
    'lstrok;': '',
    'lthree;': '',
    'ltimes;': '',
    'ltlarr;': '',
    'ltrPar;': '',
    'mapsto;': '',
    'marker;': '',
    'mcomma;': '',
    'midast;': '*',
    'midcir;': '',
    'middot;': '',
    'minusb;': '',
    'minusd;': '',
    'mnplus;': '',
    'models;': '',
    'mstpos;': '',
    'Nacute;': '',
    'nacute;': '',
    'nbumpe;': '',
    'Ncaron;': '',
    'ncaron;': '',
    'Ncedil;': '',
    'ncedil;': '',
    'nearhk;': '',
    'nequiv;': '',
    'nesear;': '',
    'nexist;': '',
    'nltrie;': '',
    'notinE;': '',
    'nparsl;': '',
    'nprcue;': '',
    'nrarrc;': '',
    'nrarrw;': '',
    'nrtrie;': '',
    'nsccue;': '',
    'nsimeq;': '',
    'Ntilde;': '',
    'ntilde;': '',
    'numero;': '',
    'nVDash;': '',
    'nVdash;': '',
    'nvDash;': '',
    'nvdash;': '',
    'nvHarr;': '',
    'nvlArr;': '',
    'nvrArr;': '',
    'nwarhk;': '',
    'nwnear;': '',
    'Oacute;': '',
    'oacute;': '',
    'Odblac;': '',
    'odblac;': '',
    'odsold;': '',
    'Ograve;': '',
    'ograve;': '',
    'ominus;': '',
    'origof;': '',
    'Oslash;': '',
    'oslash;': '',
    'Otilde;': '',
    'otilde;': '',
    'Otimes;': '',
    'otimes;': '',
    'parsim;': '',
    'percnt;': '%',
    'period;': '.',
    'permil;': '',
    'phmmat;': '',
    'planck;': '',
    'plankv;': '',
    'plusdo;': '',
    'plusdu;': '',
    'plusmn;': '',
    'preceq;': '',
    'primes;': '',
    'prnsim;': '',
    'propto;': '',
    'prurel;': '',
    'puncsp;': '',
    'qprime;': '',
    'Racute;': '',
    'racute;': '',
    'rangle;': '',
    'rarrap;': '',
    'rarrfs;': '',
    'rarrhk;': '',
    'rarrlp;': '',
    'rarrpl;': '',
    'Rarrtl;': '',
    'rarrtl;': '',
    'rAtail;': '',
    'ratail;': '',
    'rbrace;': '}',
    'rbrack;': ']',
    'Rcaron;': '',
    'rcaron;': '',
    'Rcedil;': '',
    'rcedil;': '',
    'rdquor;': '',
    'rfisht;': '',
    'rfloor;': '',
    'rharul;': '',
    'rmoust;': '',
    'roplus;': '',
    'rpargt;': '',
    'rsaquo;': '',
    'rsquor;': '',
    'rthree;': '',
    'rtimes;': '',
    'Sacute;': '',
    'sacute;': '',
    'Scaron;': '',
    'scaron;': '',
    'Scedil;': '',
    'scedil;': '',
    'scnsim;': '',
    'searhk;': '',
    'seswar;': '',
    'sfrown;': '',
    'SHCHcy;': '',
    'shchcy;': '',
    'sigmaf;': '',
    'sigmav;': '',
    'simdot;': '',
    'smashp;': '',
    'SOFTcy;': '',
    'softcy;': '',
    'solbar;': '',
    'spades;': '',
    'sqcaps;': '',
    'sqcups;': '',
    'sqsube;': '',
    'sqsupe;': '',
    'Square;': '',
    'square;': '',
    'squarf;': '',
    'ssetmn;': '',
    'ssmile;': '',
    'sstarf;': '',
    'subdot;': '',
    'Subset;': '',
    'subset;': '',
    'subsim;': '',
    'subsub;': '',
    'subsup;': '',
    'succeq;': '',
    'supdot;': '',
    'Supset;': '',
    'supset;': '',
    'supsim;': '',
    'supsub;': '',
    'supsup;': '',
    'swarhk;': '',
    'swnwar;': '',
    'target;': '',
    'Tcaron;': '',
    'tcaron;': '',
    'Tcedil;': '',
    'tcedil;': '',
    'telrec;': '',
    'there4;': '',
    'thetav;': '',
    'thinsp;': '',
    'thksim;': '',
    'timesb;': '',
    'timesd;': '',
    'topbot;': '',
    'topcir;': '',
    'tprime;': '',
    'tridot;': '',
    'Tstrok;': '',
    'tstrok;': '',
    'Uacute;': '',
    'uacute;': '',
    'Ubreve;': '',
    'ubreve;': '',
    'Udblac;': '',
    'udblac;': '',
    'ufisht;': '',
    'Ugrave;': '',
    'ugrave;': '',
    'ulcorn;': '',
    'ulcrop;': '',
    'urcorn;': '',
    'urcrop;': '',
    'Utilde;': '',
    'utilde;': '',
    'vangrt;': '',
    'varphi;': '',
    'varrho;': '',
    'Vdashl;': '',
    'veebar;': '',
    'vellip;': '',
    'Verbar;': '',
    'verbar;': '|',
    'vsubnE;': '',
    'vsubne;': '',
    'vsupnE;': '',
    'vsupne;': '',
    'Vvdash;': '',
    'wedbar;': '',
    'wedgeq;': '',
    'weierp;': '',
    'wreath;': '',
    'xoplus;': '',
    'xotime;': '',
    'xsqcup;': '',
    'xuplus;': '',
    'xwedge;': '',
    'Yacute;': '',
    'yacute;': '',
    'Zacute;': '',
    'zacute;': '',
    'Zcaron;': '',
    'zcaron;': '',
    'zeetrf;': '',
    'alefsym;': '',
    'angrtvb;': '',
    'angzarr;': '',
    'asympeq;': '',
    'backsim;': '',
    'Because;': '',
    'because;': '',
    'bemptyv;': '',
    'between;': '',
    'bigcirc;': '',
    'bigodot;': '',
    'bigstar;': '',
    'bnequiv;': '',
    'boxplus;': '',
    'Cayleys;': '',
    'Cconint;': '',
    'ccupssm;': '',
    'Cedilla;': '',
    'cemptyv;': '',
    'cirscir;': '',
    'coloneq;': '',
    'congdot;': '',
    'cudarrl;': '',
    'cudarrr;': '',
    'cularrp;': '',
    'curarrm;': '',
    'dbkarow;': '',
    'ddagger;': '',
    'ddotseq;': '',
    'demptyv;': '',
    'Diamond;': '',
    'diamond;': '',
    'digamma;': '',
    'dotplus;': '',
    'DownTee;': '',
    'dwangle;': '',
    'Element;': '',
    'Epsilon;': '',
    'epsilon;': '',
    'eqcolon;': '',
    'equivDD;': '',
    'gesdoto;': '',
    'gtquest;': '',
    'gtrless;': '',
    'harrcir;': '',
    'Implies;': '',
    'intprod;': '',
    'isindot;': '',
    'larrbfs;': '',
    'larrsim;': '',
    'lbrksld;': '',
    'lbrkslu;': '',
    'ldrdhar;': '',
    'LeftTee;': '',
    'lesdoto;': '',
    'lessdot;': '',
    'lessgtr;': '',
    'lesssim;': '',
    'lotimes;': '',
    'lozenge;': '',
    'ltquest;': '',
    'luruhar;': '',
    'maltese;': '',
    'minusdu;': '',
    'napprox;': '',
    'natural;': '',
    'nearrow;': '',
    'NewLine;': '\n',
    'nexists;': '',
    'NoBreak;': '',
    'notinva;': '',
    'notinvb;': '',
    'notinvc;': '',
    'NotLess;': '',
    'notniva;': '',
    'notnivb;': '',
    'notnivc;': '',
    'npolint;': '',
    'npreceq;': '',
    'nsqsube;': '',
    'nsqsupe;': '',
    'nsubset;': '',
    'nsucceq;': '',
    'nsupset;': '',
    'nvinfin;': '',
    'nvltrie;': '',
    'nvrtrie;': '',
    'nwarrow;': '',
    'olcross;': '',
    'Omicron;': '',
    'omicron;': '',
    'orderof;': '',
    'orslope;': '',
    'OverBar;': '',
    'pertenk;': '',
    'planckh;': '',
    'pluscir;': '',
    'plussim;': '',
    'plustwo;': '',
    'precsim;': '',
    'Product;': '',
    'quatint;': '',
    'questeq;': '',
    'rarrbfs;': '',
    'rarrsim;': '',
    'rbrksld;': '',
    'rbrkslu;': '',
    'rdldhar;': '',
    'realine;': '',
    'rotimes;': '',
    'ruluhar;': '',
    'searrow;': '',
    'simplus;': '',
    'simrarr;': '',
    'subedot;': '',
    'submult;': '',
    'subplus;': '',
    'subrarr;': '',
    'succsim;': '',
    'supdsub;': '',
    'supedot;': '',
    'suphsol;': '',
    'suphsub;': '',
    'suplarr;': '',
    'supmult;': '',
    'supplus;': '',
    'swarrow;': '',
    'topfork;': '',
    'triplus;': '',
    'tritime;': '',
    'UpArrow;': '',
    'Uparrow;': '',
    'uparrow;': '',
    'Upsilon;': '',
    'upsilon;': '',
    'uwangle;': '',
    'vzigzag;': '',
    'zigrarr;': '',
    'andslope;': '',
    'angmsdaa;': '',
    'angmsdab;': '',
    'angmsdac;': '',
    'angmsdad;': '',
    'angmsdae;': '',
    'angmsdaf;': '',
    'angmsdag;': '',
    'angmsdah;': '',
    'angrtvbd;': '',
    'approxeq;': '',
    'awconint;': '',
    'backcong;': '',
    'barwedge;': '',
    'bbrktbrk;': '',
    'bigoplus;': '',
    'bigsqcup;': '',
    'biguplus;': '',
    'bigwedge;': '',
    'boxminus;': '',
    'boxtimes;': '',
    'bsolhsub;': '',
    'capbrcup;': '',
    'circledR;': '',
    'circledS;': '',
    'cirfnint;': '',
    'clubsuit;': '',
    'cupbrcap;': '',
    'curlyvee;': '',
    'cwconint;': '',
    'DDotrahd;': '',
    'doteqdot;': '',
    'DotEqual;': '',
    'dotminus;': '',
    'drbkarow;': '',
    'dzigrarr;': '',
    'elinters;': '',
    'emptyset;': '',
    'eqvparsl;': '',
    'fpartint;': '',
    'geqslant;': '',
    'gesdotol;': '',
    'gnapprox;': '',
    'hksearow;': '',
    'hkswarow;': '',
    'imagline;': '',
    'imagpart;': '',
    'infintie;': '',
    'integers;': '',
    'Integral;': '',
    'intercal;': '',
    'intlarhk;': '',
    'laemptyv;': '',
    'ldrushar;': '',
    'leqslant;': '',
    'lesdotor;': '',
    'LessLess;': '',
    'llcorner;': '',
    'lnapprox;': '',
    'lrcorner;': '',
    'lurdshar;': '',
    'mapstoup;': '',
    'multimap;': '',
    'naturals;': '',
    'ncongdot;': '',
    'NotEqual;': '',
    'notindot;': '',
    'NotTilde;': '',
    'otimesas;': '',
    'parallel;': '',
    'PartialD;': '',
    'plusacir;': '',
    'pointint;': '',
    'Precedes;': '',
    'precneqq;': '',
    'precnsim;': '',
    'profalar;': '',
    'profline;': '',
    'profsurf;': '',
    'raemptyv;': '',
    'realpart;': '',
    'RightTee;': '',
    'rppolint;': '',
    'rtriltri;': '',
    'scpolint;': '',
    'setminus;': '',
    'shortmid;': '',
    'smeparsl;': '',
    'sqsubset;': '',
    'sqsupset;': '',
    'subseteq;': '',
    'Succeeds;': '',
    'succneqq;': '',
    'succnsim;': '',
    'SuchThat;': '',
    'Superset;': '',
    'supseteq;': '',
    'thetasym;': '',
    'thicksim;': '',
    'timesbar;': '',
    'triangle;': '',
    'triminus;': '',
    'trpezium;': '',
    'Uarrocir;': '',
    'ulcorner;': '',
    'UnderBar;': '_',
    'urcorner;': '',
    'varkappa;': '',
    'varsigma;': '',
    'vartheta;': '',
    'backprime;': '',
    'backsimeq;': '',
    'Backslash;': '',
    'bigotimes;': '',
    'CenterDot;': '',
    'centerdot;': '',
    'checkmark;': '',
    'CircleDot;': '',
    'complexes;': '',
    'Congruent;': '',
    'Coproduct;': '',
    'dotsquare;': '',
    'DoubleDot;': '',
    'DownArrow;': '',
    'Downarrow;': '',
    'downarrow;': '',
    'DownBreve;': '',
    'gtrapprox;': '',
    'gtreqless;': '',
    'gvertneqq;': '',
    'heartsuit;': '',
    'HumpEqual;': '',
    'LeftArrow;': '',
    'Leftarrow;': '',
    'leftarrow;': '',
    'LeftFloor;': '',
    'lesseqgtr;': '',
    'LessTilde;': '',
    'lvertneqq;': '',
    'Mellintrf;': '',
    'MinusPlus;': '',
    'ngeqslant;': '',
    'nleqslant;': '',
    'NotCupCap;': '',
    'NotExists;': '',
    'NotSubset;': '',
    'nparallel;': '',
    'nshortmid;': '',
    'nsubseteq;': '',
    'nsupseteq;': '',
    'OverBrace;': '',
    'pitchfork;': '',
    'PlusMinus;': '',
    'rationals;': '',
    'spadesuit;': '',
    'subseteqq;': '',
    'subsetneq;': '',
    'supseteqq;': '',
    'supsetneq;': '',
    'Therefore;': '',
    'therefore;': '',
    'ThinSpace;': '',
    'triangleq;': '',
    'TripleDot;': '',
    'UnionPlus;': '',
    'varpropto;': '',
    'Bernoullis;': '',
    'circledast;': '',
    'CirclePlus;': '',
    'complement;': '',
    'curlywedge;': '',
    'eqslantgtr;': '',
    'EqualTilde;': '',
    'Fouriertrf;': '',
    'gtreqqless;': '',
    'ImaginaryI;': '',
    'Laplacetrf;': '',
    'LeftVector;': '',
    'lessapprox;': '',
    'lesseqqgtr;': '',
    'Lleftarrow;': '',
    'lmoustache;': '',
    'longmapsto;': '',
    'mapstodown;': '',
    'mapstoleft;': '',
    'nLeftarrow;': '',
    'nleftarrow;': '',
    'NotElement;': '',
    'NotGreater;': '',
    'nsubseteqq;': '',
    'nsupseteqq;': '',
    'precapprox;': '',
    'Proportion;': '',
    'RightArrow;': '',
    'Rightarrow;': '',
    'rightarrow;': '',
    'RightFloor;': '',
    'rmoustache;': '',
    'sqsubseteq;': '',
    'sqsupseteq;': '',
    'subsetneqq;': '',
    'succapprox;': '',
    'supsetneqq;': '',
    'ThickSpace;': '',
    'TildeEqual;': '',
    'TildeTilde;': '',
    'UnderBrace;': '',
    'UpArrowBar;': '',
    'UpTeeArrow;': '',
    'upuparrows;': '',
    'varepsilon;': '',
    'varnothing;': '',
    'backepsilon;': '',
    'blacksquare;': '',
    'circledcirc;': '',
    'circleddash;': '',
    'CircleMinus;': '',
    'CircleTimes;': '',
    'curlyeqprec;': '',
    'curlyeqsucc;': '',
    'diamondsuit;': '',
    'eqslantless;': '',
    'Equilibrium;': '',
    'expectation;': '',
    'GreaterLess;': '',
    'LeftCeiling;': '',
    'LessGreater;': '',
    'MediumSpace;': '',
    'NotLessLess;': '',
    'NotPrecedes;': '',
    'NotSucceeds;': '',
    'NotSuperset;': '',
    'nRightarrow;': '',
    'nrightarrow;': '',
    'OverBracket;': '',
    'preccurlyeq;': '',
    'precnapprox;': '',
    'quaternions;': '',
    'RightVector;': '',
    'Rrightarrow;': '',
    'RuleDelayed;': '',
    'SmallCircle;': '',
    'SquareUnion;': '',
    'straightphi;': '',
    'SubsetEqual;': '',
    'succcurlyeq;': '',
    'succnapprox;': '',
    'thickapprox;': '',
    'UpDownArrow;': '',
    'Updownarrow;': '',
    'updownarrow;': '',
    'VerticalBar;': '',
    'blacklozenge;': '',
    'DownArrowBar;': '',
    'DownTeeArrow;': '',
    'ExponentialE;': '',
    'exponentiale;': '',
    'GreaterEqual;': '',
    'GreaterTilde;': '',
    'HilbertSpace;': '',
    'HumpDownHump;': '',
    'Intersection;': '',
    'LeftArrowBar;': '',
    'LeftTeeArrow;': '',
    'LeftTriangle;': '',
    'LeftUpVector;': '',
    'NotCongruent;': '',
    'NotHumpEqual;': '',
    'NotLessEqual;': '',
    'NotLessTilde;': '',
    'Proportional;': '',
    'RightCeiling;': '',
    'risingdotseq;': '',
    'RoundImplies;': '',
    'ShortUpArrow;': '',
    'SquareSubset;': '',
    'triangledown;': '',
    'triangleleft;': '',
    'UnderBracket;': '',
    'varsubsetneq;': '',
    'varsupsetneq;': '',
    'VerticalLine;': '|',
    'ApplyFunction;': '',
    'bigtriangleup;': '',
    'blacktriangle;': '',
    'DifferentialD;': '',
    'divideontimes;': '',
    'DoubleLeftTee;': '',
    'DoubleUpArrow;': '',
    'fallingdotseq;': '',
    'hookleftarrow;': '',
    'leftarrowtail;': '',
    'leftharpoonup;': '',
    'LeftTeeVector;': '',
    'LeftVectorBar;': '',
    'LessFullEqual;': '',
    'LongLeftArrow;': '',
    'Longleftarrow;': '',
    'longleftarrow;': '',
    'looparrowleft;': '',
    'measuredangle;': '',
    'NotEqualTilde;': '',
    'NotTildeEqual;': '',
    'NotTildeTilde;': '',
    'ntriangleleft;': '',
    'Poincareplane;': '',
    'PrecedesEqual;': '',
    'PrecedesTilde;': '',
    'RightArrowBar;': '',
    'RightTeeArrow;': '',
    'RightTriangle;': '',
    'RightUpVector;': '',
    'shortparallel;': '',
    'smallsetminus;': '',
    'SucceedsEqual;': '',
    'SucceedsTilde;': '',
    'SupersetEqual;': '',
    'triangleright;': '',
    'UpEquilibrium;': '',
    'upharpoonleft;': '',
    'varsubsetneqq;': '',
    'varsupsetneqq;': '',
    'VerticalTilde;': '',
    'VeryThinSpace;': '',
    'curvearrowleft;': '',
    'DiacriticalDot;': '',
    'doublebarwedge;': '',
    'DoubleRightTee;': '',
    'downdownarrows;': '',
    'DownLeftVector;': '',
    'GreaterGreater;': '',
    'hookrightarrow;': '',
    'HorizontalLine;': '',
    'InvisibleComma;': '',
    'InvisibleTimes;': '',
    'LeftDownVector;': '',
    'leftleftarrows;': '',
    'LeftRightArrow;': '',
    'Leftrightarrow;': '',
    'leftrightarrow;': '',
    'leftthreetimes;': '',
    'LessSlantEqual;': '',
    'LongRightArrow;': '',
    'Longrightarrow;': '',
    'longrightarrow;': '',
    'looparrowright;': '',
    'LowerLeftArrow;': '',
    'NestedLessLess;': '',
    'NotGreaterLess;': '',
    'NotLessGreater;': '',
    'NotSubsetEqual;': '',
    'NotVerticalBar;': '',
    'nshortparallel;': '',
    'ntriangleright;': '',
    'OpenCurlyQuote;': '',
    'ReverseElement;': '',
    'rightarrowtail;': '',
    'rightharpoonup;': '',
    'RightTeeVector;': '',
    'RightVectorBar;': '',
    'ShortDownArrow;': '',
    'ShortLeftArrow;': '',
    'SquareSuperset;': '',
    'TildeFullEqual;': '',
    'trianglelefteq;': '',
    'upharpoonright;': '',
    'UpperLeftArrow;': '',
    'ZeroWidthSpace;': '',
    'bigtriangledown;': '',
    'circlearrowleft;': '',
    'CloseCurlyQuote;': '',
    'ContourIntegral;': '',
    'curvearrowright;': '',
    'DoubleDownArrow;': '',
    'DoubleLeftArrow;': '',
    'downharpoonleft;': '',
    'DownRightVector;': '',
    'leftharpoondown;': '',
    'leftrightarrows;': '',
    'LeftRightVector;': '',
    'LeftTriangleBar;': '',
    'LeftUpTeeVector;': '',
    'LeftUpVectorBar;': '',
    'LowerRightArrow;': '',
    'nLeftrightarrow;': '',
    'nleftrightarrow;': '',
    'NotGreaterEqual;': '',
    'NotGreaterTilde;': '',
    'NotHumpDownHump;': '',
    'NotLeftTriangle;': '',
    'NotSquareSubset;': '',
    'ntrianglelefteq;': '',
    'OverParenthesis;': '',
    'RightDownVector;': '',
    'rightleftarrows;': '',
    'rightsquigarrow;': '',
    'rightthreetimes;': '',
    'ShortRightArrow;': '',
    'straightepsilon;': '',
    'trianglerighteq;': '',
    'UpperRightArrow;': '',
    'vartriangleleft;': '',
    'circlearrowright;': '',
    'DiacriticalAcute;': '',
    'DiacriticalGrave;': '`',
    'DiacriticalTilde;': '',
    'DoubleRightArrow;': '',
    'DownArrowUpArrow;': '',
    'downharpoonright;': '',
    'EmptySmallSquare;': '',
    'GreaterEqualLess;': '',
    'GreaterFullEqual;': '',
    'LeftAngleBracket;': '',
    'LeftUpDownVector;': '',
    'LessEqualGreater;': '',
    'NonBreakingSpace;': ' ',
    'NotPrecedesEqual;': '',
    'NotRightTriangle;': '',
    'NotSucceedsEqual;': '',
    'NotSucceedsTilde;': '',
    'NotSupersetEqual;': '',
    'ntrianglerighteq;': '',
    'rightharpoondown;': '',
    'rightrightarrows;': '',
    'RightTriangleBar;': '',
    'RightUpTeeVector;': '',
    'RightUpVectorBar;': '',
    'twoheadleftarrow;': '',
    'UnderParenthesis;': '',
    'UpArrowDownArrow;': '',
    'vartriangleright;': '',
    'blacktriangledown;': '',
    'blacktriangleleft;': '',
    'DoubleUpDownArrow;': '',
    'DoubleVerticalBar;': '',
    'DownLeftTeeVector;': '',
    'DownLeftVectorBar;': '',
    'FilledSmallSquare;': '',
    'GreaterSlantEqual;': '',
    'LeftDoubleBracket;': '',
    'LeftDownTeeVector;': '',
    'LeftDownVectorBar;': '',
    'leftrightharpoons;': '',
    'LeftTriangleEqual;': '',
    'NegativeThinSpace;': '',
    'NotGreaterGreater;': '',
    'NotLessSlantEqual;': '',
    'NotNestedLessLess;': '',
    'NotReverseElement;': '',
    'NotSquareSuperset;': '',
    'NotTildeFullEqual;': '',
    'RightAngleBracket;': '',
    'rightleftharpoons;': '',
    'RightUpDownVector;': '',
    'SquareSubsetEqual;': '',
    'twoheadrightarrow;': '',
    'VerticalSeparator;': '',
    'blacktriangleright;': '',
    'DownRightTeeVector;': '',
    'DownRightVectorBar;': '',
    'LongLeftRightArrow;': '',
    'Longleftrightarrow;': '',
    'longleftrightarrow;': '',
    'NegativeThickSpace;': '',
    'NotLeftTriangleBar;': '',
    'PrecedesSlantEqual;': '',
    'ReverseEquilibrium;': '',
    'RightDoubleBracket;': '',
    'RightDownTeeVector;': '',
    'RightDownVectorBar;': '',
    'RightTriangleEqual;': '',
    'SquareIntersection;': '',
    'SucceedsSlantEqual;': '',
    'DoubleLongLeftArrow;': '',
    'DownLeftRightVector;': '',
    'LeftArrowRightArrow;': '',
    'leftrightsquigarrow;': '',
    'NegativeMediumSpace;': '',
    'NotGreaterFullEqual;': '',
    'NotRightTriangleBar;': '',
    'RightArrowLeftArrow;': '',
    'SquareSupersetEqual;': '',
    'CapitalDifferentialD;': '',
    'DoubleLeftRightArrow;': '',
    'DoubleLongRightArrow;': '',
    'EmptyVerySmallSquare;': '',
    'NestedGreaterGreater;': '',
    'NotDoubleVerticalBar;': '',
    'NotGreaterSlantEqual;': '',
    'NotLeftTriangleEqual;': '',
    'NotSquareSubsetEqual;': '',
    'OpenCurlyDoubleQuote;': '',
    'ReverseUpEquilibrium;': '',
    'CloseCurlyDoubleQuote;': '',
    'DoubleContourIntegral;': '',
    'FilledVerySmallSquare;': '',
    'NegativeVeryThinSpace;': '',
    'NotPrecedesSlantEqual;': '',
    'NotRightTriangleEqual;': '',
    'NotSucceedsSlantEqual;': '',
    'DiacriticalDoubleAcute;': '',
    'NotSquareSupersetEqual;': '',
    'NotNestedGreaterGreater;': '',
    'ClockwiseContourIntegral;': '',
    'DoubleLongLeftRightArrow;': '',
    'CounterClockwiseContourIntegral;': '',
};

const maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
const decodeHtml = (rawText, asAttr) => {
    let offset = 0;
    const end = rawText.length;
    let decodedText = '';
    function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
    }
    while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (head == null || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
        }
        // Advance to the "&".
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === '&') {
            // Named character reference.
            let name = '';
            let value;
            if (rawText[1] != null && /[0-9a-z]/i.test(rawText[1])) {
                for (let length = maxCRNameLength; value != null && length > 0; --length) {
                    name = rawText.substr(1, length);
                    value = namedCharacterReferences[name];
                }
                if (value != null) {
                    const semi = name.endsWith(';');
                    if (asAttr &&
                        !semi &&
                        /[=a-z0-9]/i.test(rawText[name.length + 1] ?? '')) {
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                    else {
                        decodedText += value;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&' + name;
                    advance(1 + name.length);
                }
            }
            else {
                decodedText += '&';
                advance(1);
            }
        }
        else {
            // Numeric character reference.
            const hex = head[0] === '&#x';
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (body == null) {
                if (head[0] != null) {
                    decodedText = `${decodedText}${head[0]}`;
                    advance(head[0].length);
                }
            }
            else if (body[1] != null) {
                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                let cp = Number.parseInt(body[1], hex ? 16 : 10);
                if (cp === 0) {
                    cp = 0xfffd;
                }
                else if (cp > 0x10ffff) {
                    cp = 0xfffd;
                }
                else if (cp >= 0xd800 && cp <= 0xdfff) {
                    cp = 0xfffd;
                }
                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                else if ((cp >= 0x01 && cp <= 0x08) ||
                    cp === 0x0b ||
                    (cp >= 0x0d && cp <= 0x1f) ||
                    (cp >= 0x7f && cp <= 0x9f)) {
                    cp = CCR_REPLACEMENTS[cp] ?? cp;
                }
                decodedText += String.fromCodePoint(cp);
                if (body[0] != null)
                    advance(body[0].length);
            }
        }
    }
    return decodedText;
};
// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178,
};

const parserOptions = {
    isVoidTag: shared.isVoidTag,
    isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
    isPreTag: (tag) => tag === 'pre',
    decodeEntities: decodeHtml,
    isBuiltInComponent: () => { },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent != null ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent != null && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some((a) => a.type === templateAstTypes.NodeTypes.ATTRIBUTE &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent != null && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1; /* TextModes.RCDATA */
            }
            if (shared.isRawTextContainer(tag)) {
                return 2; /* TextModes.RAWTEXT */
            }
        }
        return 0; /* TextModes.DATA */
    },
};

const preprocess = (node, context) => {
    if (templateAstTypes.isTextNode(node) && node.content.trim().startsWith('<')) {
        // Incomplete element tag
        context.replaceNode(createPlainElementNode(node.loc));
        return;
    }
    if (!templateAstTypes.isElementNode(node))
        return;
    if (/^[a-z]+$/.test(node.tag) &&
        node.tagType === 1 &&
        node.tag !== 'component') {
        // force element for lower case unknown tags as user might be typing these partial html/svg tags
        node.tagType = 0; /* ELEMENT */
    }
    node.props.forEach((prop, index) => {
        // remove empty modifiers
        if (templateAstTypes.isDirectiveNode(prop)) {
            const nameEndOffset = prop.loc.source.startsWith('v-')
                ? 2 + prop.name.length
                : 1;
            let offset = prop.arg != null
                ? prop.arg.loc.end.offset - prop.loc.start.offset
                : nameEndOffset;
            prop.nameLoc = sliceLoc(prop.loc, 0, nameEndOffset);
            if (prop.modifiers.length === 1 && shared.first(prop.modifiers) === '') {
                prop.modifiers = [];
            }
            prop.modifierLocs = prop.modifiers.map((modifier) => {
                try {
                    offset += 1;
                    return sliceLoc(prop.loc, offset, modifier.length);
                }
                finally {
                    offset += modifier.length;
                }
            });
            // remove braces from arg loc
            if (prop.arg?.loc.source.startsWith('[') === true) {
                prop.arg.loc = sliceLoc(prop.arg.loc, 1, -1);
            }
            // prop.modifierLocs =
        }
        else {
            // parse ^ shorthand for v-bind
            if (prop.name.startsWith('^')) {
                const isDynamic = prop.name.slice(1).startsWith('[');
                node.props[index] = {
                    type: 7 /* DIRECTIVE */,
                    name: 'bind',
                    nameLoc: createLoc(prop.loc, 0, 1),
                    arg: isDynamic
                        ? templateAstTypes.createSimpleExpression(prop.name.slice(2, -1), false, createLoc(prop.loc, 1, prop.name.length - 1))
                        : prop.name.length > 1
                            ? templateAstTypes.createSimpleExpression(prop.name.slice(1), true, createLoc(prop.loc, 1, prop.name.length - 1))
                            : undefined,
                    loc: prop.loc,
                    modifiers: [],
                    modifierLocs: [],
                    exp: prop.value == null
                        ? undefined
                        : templateAstTypes.createSimpleExpression(prop.value.content, false, sliceLoc(prop.value.loc, 1, -1)),
                    scope: undefined,
                };
            }
            else {
                prop.nameLoc = createLoc(prop.loc, 0, prop.name.length);
            }
        }
    });
    node.tagLoc = createLoc(node.loc, 1, node.tag.length);
    if (node.isSelfClosing) {
        node.startTagLoc = node.loc;
        node.endTagLoc = sliceLoc(node.loc, -2);
    }
    else {
        const startTagIndex = node.loc.source.indexOf('>', (node.props.length > 0
            ? shared.last(node.props).loc.end.offset
            : node.tagLoc.end.offset) - node.loc.start.offset);
        if (startTagIndex < 0) {
            node.startTagLoc = node.loc; // Incomplete open tag
        }
        else {
            node.startTagLoc = createLoc(node.loc, 0, startTagIndex + 1);
            const endOfStartTagOrLastChild = (node.children.length > 0
                ? shared.last(node.children).loc.end.offset
                : node.startTagLoc.end.offset) - node.loc.start.offset;
            const endTagIndex = Math.max(endOfStartTagOrLastChild, node.loc.source.indexOf('</', endOfStartTagOrLastChild));
            node.endTagLoc = createLoc(node.loc, endTagIndex, node.loc.source.length - endTagIndex);
        }
    }
};
function parse(template, options) {
    const ast = compilerCore.baseParse(template, {
        ...parserOptions,
        ...options,
    });
    compilerCore.transform(ast, { nodeTransforms: [preprocess] });
    return ast;
}
function createPlainElementNode(contentLoc) {
    const offset = contentLoc.source.indexOf('<');
    const loc = sliceLoc(contentLoc, offset);
    const tag = loc.source.slice(1).trim();
    return {
        type: 1 /* ELEMENT */,
        tag,
        tagType: 0 /* ELEMENT */,
        codegenNode: undefined,
        children: [],
        isSelfClosing: tag.length > 0,
        loc,
        ns: 0,
        props: [],
        tagLoc: sliceLoc(loc, 1),
        startTagLoc: loc,
        endTagLoc: undefined,
        scope: new Scope(),
    };
}

function compile$1(template, options) {
    const errors = [];
    const result = compileFromAST(parse(template, {
        ...options,
        onError: (error) => {
            errors.push(error);
            options.onError?.(error);
        },
    }), options);
    result.errors.unshift(...errors);
    return result;
}
function compileFromAST(source, options) {
    const root = withScope(clone(source));
    const ast = clone(source);
    ast.scope = root.scope;
    const context = {
        ...options,
        scope: new ScopeManager(),
        used: { components: new Set(), directives: new Set() },
    };
    const errors = [];
    compilerCore.transform(root, {
        ...options,
        prefixIdentifiers: false,
        hoistStatic: false,
        transformHoist: null,
        ssr: false,
        cacheHandlers: false,
        scopeId: null,
        nodeTransforms: [
            createResolveComponentTransform(context),
            createSlotHoistScopeTransform(context),
            createTransformFor(context),
            createTransformIf(),
            createComponentChildrenTransform(),
        ],
        onError(error) {
            errors.push(error);
        },
    });
    const result = generate(root, context);
    return { ...result, ast, errors };
}
function clone(obj) {
    try {
        // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error
        // @ts-ignore
        if (typeof structuredClone !== 'undefined')
            return structuredClone(obj);
    }
    catch { }
    return JSON.parse(JSON.stringify(obj));
}

function transformTemplate(template, options) {
    const slotsIdentifier = `${options.internalIdentifierPrefix}_slots`;
    const attrsIdentifier = `${options.internalIdentifierPrefix}_attrs`;
    if (template == null) {
        return {
            code: `function ${slotsIdentifier}() { return {} }; const ${attrsIdentifier} = {};`,
            map: {
                file: '',
                mappings: [],
                names: [],
                sources: [],
                sourcesContent: [],
            },
            slotsIdentifier,
            attrsIdentifier,
            errors: [],
        };
    }
    const result = compile$1(template?.content, options);
    const offset = template.loc.start.offset;
    const line = template.loc.start.line;
    return {
        ...result,
        slotsIdentifier,
        attrsIdentifier,
        errors: result.errors.map((error) => {
            if ('loc' in error && error.loc != null) {
                error.loc.start.offset += offset;
                error.loc.end.offset += offset;
                error.loc.start.line += line;
                error.loc.end.line += line;
            }
            error.message += ` (in <template>)`;
            return error;
        }),
    };
}

function compile(source, options) {
    const result = compileWithDecodedSourceMap(source, options);
    return {
        ...result,
        map: {
            version: 3,
            ...result.map,
            mappings: sourcemapCodec.encode(result.map.mappings),
        },
    };
}
function compileWithDecodedSourceMap(source, options) {
    // performance.mark('beforeTransform')
    const cache = options.cache ?? shared.createCache(100);
    const key = (name) => `${options.fileName}::block:${name}`;
    const previous = cache.get(key('descriptor'));
    const { descriptor, errors } = compilerSfc.parse(source);
    const lang = descriptor.script?.lang ?? descriptor.scriptSetup?.lang;
    const internalIdentifierPrefix = options.internalIdentifierPrefix ?? '__VueDX__';
    const contextIdentifier = `${internalIdentifierPrefix}ctx`;
    const typeIdentifier = `${internalIdentifierPrefix}TypeCheck`;
    const resolvedOptions = {
        ...options,
        runtimeModuleName: 'vue',
        typeCheckModuleName: 'vuedx~runtime',
        typeIdentifier,
        contextIdentifier,
        internalIdentifierPrefix,
        isTypeScript: options.isTypeScript ?? (lang === 'ts' || lang === 'tsx'),
        cache,
        descriptor,
        identifiers: new Map(),
    };
    const builder = new shared.SourceTransformer(options.fileName, source);
    const isScriptChanged = hasBlockChanged(previous?.script, descriptor.script);
    const script = runIfNeeded(key('script'), isScriptChanged, cache, () => transformScript(descriptor.script, resolvedOptions));
    const isScriptSetupChanged = hasBlockChanged(previous?.scriptSetup, descriptor.scriptSetup);
    const scriptSetup = runIfNeeded(key('scriptSetup'), isScriptSetupChanged, cache, () => transformScriptSetup(descriptor.scriptSetup, resolvedOptions));
    resolvedOptions.identifiers = new Map();
    script.identifiers.forEach((identifier) => {
        resolvedOptions.identifiers.set(identifier.name, identifier);
    });
    scriptSetup.identifiers.forEach((identifier) => {
        resolvedOptions.identifiers.set(identifier.name, identifier);
    });
    const template = runIfNeeded(key('template'), isScriptChanged ||
        isScriptSetupChanged ||
        hasBlockChanged(previous?.template, descriptor.template), cache, () => transformTemplate(descriptor.template, resolvedOptions));
    const name = script.name;
    function region(name, fn) {
        builder.nextLine();
        builder.append(`//#region ${name}`);
        builder.nextLine();
        fn();
        builder.nextLine();
        builder.append(`//#endregion`);
        builder.nextLine();
    }
    builder.append([
        `import * as ${resolvedOptions.typeIdentifier} from '${resolvedOptions.typeCheckModuleName}';`,
        `declare const ${resolvedOptions.internalIdentifierPrefix}defineComponent: typeof import(${JSON.stringify(resolvedOptions.runtimeModuleName)}).defineComponent;`,
        `type ${resolvedOptions.internalIdentifierPrefix}GlobalComponents = import(${JSON.stringify(resolvedOptions.runtimeModuleName)}).GlobalComponents;`,
    ].join('\n'));
    builder.nextLine();
    region('<script>', () => {
        builder.append(script.code, shared.rebaseSourceMap(script.map, descriptor.script?.loc.start));
    });
    const customBlocksResults = descriptor.customBlocks.map((block, index) => {
        const result = runIfNeeded(key(`customBlock${index}`), hasBlockChanged(previous?.customBlocks[index], block), cache, () => transformCustomBlock(block, resolvedOptions));
        region(`<${block.type}>`, () => {
            builder.append(result.code, shared.rebaseSourceMap(result.map, block.loc.start));
        });
        return result;
    });
    region('<script setup>', () => {
        builder.append(scriptSetup.code, shared.rebaseSourceMap(scriptSetup.map, descriptor.scriptSetup?.loc.start));
    });
    const defaultExportIdentifier = descriptor.scriptSetup != null
        ? scriptSetup.exportIdentifier
        : script.exportIdentifier;
    builder.append([
        `function ${internalIdentifierPrefix}RegisterSelf<T>(ctx: T) {`,
        `  return { ...ctx, [${JSON.stringify(name)}]: ${name} }`,
        `}`,
    ].join('\n'));
    builder.nextLine();
    builder.append(`const ${contextIdentifier} = ${customBlocksResults.reduce((code, result) => {
        if (result.decoratorIdentifier != null) {
            return `${result.decoratorIdentifier}(${code})`;
        }
        return code;
    }, `${internalIdentifierPrefix}RegisterSelf(new ${defaultExportIdentifier}())`)}`);
    builder.nextLine();
    region(`<template>`, () => {
        builder.append(template.code, shared.rebaseSourceMap(template.map, descriptor.template?.loc.start));
    });
    descriptor.styles.forEach((style, index) => {
        const result = runIfNeeded(key(`style${index}`), hasBlockChanged(previous?.styles[index], style), cache, () => transformStyle(style, resolvedOptions));
        builder.append('/* <style> */');
        region('<style>', () => {
            builder.append(result.code, shared.rebaseSourceMap(result.map, style.loc.start));
        });
    });
    const exported = [
        ...(descriptor.scriptSetup == null
            ? [template.attrsIdentifier, template.slotsIdentifier, contextIdentifier]
            : [scriptSetup.componentIdentifier]),
        ...Object.values(scriptSetup.exports),
    ].join(', ');
    builder.append(`return {${exported}};};`);
    builder.nextLine();
    builder.append(`const {${exported}} = ${scriptSetup.scopeIdentifier}();\n`);
    Object.entries(scriptSetup.exports).forEach(([name, identifier]) => {
        builder.append(`export type ${name} = typeof ${identifier};\n`);
    });
    region('public component definition', () => {
        if (descriptor.scriptSetup == null) {
            const props = `${resolvedOptions.contextIdentifier}.$props`;
            const inheritAttrs = descriptor.template?.content.includes('@vue-attrs-target') === true ||
                script.inheritAttrs;
            const propsType = `typeof ${props}`;
            const attrsType = `typeof ${template.attrsIdentifier}`;
            const slotsType = `${resolvedOptions.typeIdentifier}.internal.Slots<typeof ${template.slotsIdentifier}_value>`;
            builder.append([
                `const ${template.slotsIdentifier}_value = ${template.slotsIdentifier}();`,
                `export default class ${name} {`,
                defineProperty('$props', inheritAttrs
                    ? `${resolvedOptions.typeIdentifier}.internal.MergeAttrs<${propsType}, ${attrsType}> & {$slots: ${slotsType}}`
                    : `${propsType} & {$slots: ${slotsType}}`),
                `}`,
            ].join('\n'));
        }
        else {
            const generic = typeof descriptor.scriptSetup.attrs['generic'] === 'string'
                ? descriptor.scriptSetup.attrs['generic']
                : '';
            const typeArgs = parseGenericArgNames(generic);
            const component = typeArgs.length > 0
                ? `(new (${scriptSetup.scopeIdentifier}<${typeArgs.join(', ')}>().${scriptSetup.componentIdentifier}<${typeArgs.join(', ')}>))`
                : `(new (${scriptSetup.scopeIdentifier}().${scriptSetup.componentIdentifier}))`;
            const genericExp = typeArgs.length > 0 ? `<${generic}>` : '';
            builder.append(`export default class ${name}${genericExp} {\n`);
            builder.append(` $props = {...${component}.$props, $slots: ${component}.$slots };\n`);
            builder.append(`}`);
        }
        builder.nextLine();
    });
    const output = builder.end();
    // performance.mark('afterTransform')
    // performance.measure('transform', 'beforeTransform', 'afterTransform')
    return {
        code: output.code,
        map: {
            ...output.map,
            file: options.fileName.replace(/\.vue$/, resolvedOptions.isTypeScript ? '.tsx' : '.jsx'),
        },
        descriptor,
        errors: [...errors, ...template.errors],
        template: template.ast,
    };
    function defineProperty(name, type) {
        return resolvedOptions.isTypeScript
            ? `  ${name} = null as unknown as ${type};`
            : `  ${name} = /** @type {${type}} */ (/** @type {unknown} */ (null));`;
    }
    function parseGenericArgNames(code) {
        const ts = options.typescript;
        const program = transforms.createProgram(ts, `function _<${code}>() {}`);
        const sourceFile = program.getSourceFile('input.ts');
        shared.invariant(sourceFile != null, 'sourceFile should not be null');
        const decl = shared.first(sourceFile.statements);
        shared.invariant(ts.isFunctionDeclaration(decl));
        shared.invariant(decl.typeParameters != null);
        return decl.typeParameters.map((p) => p.name.getText());
    }
}
function runIfNeeded(key, forceEvict, cache, fn) {
    if (forceEvict)
        cache.delete(key);
    return cache.resolve(key, fn);
}
function hasBlockChanged(previous, current) {
    if (previous === undefined)
        return true;
    if (previous === current)
        return true;
    if (previous == null || current == null)
        return false;
    if (previous.type !== current.type)
        return false;
    if (previous.lang !== current.lang)
        return false;
    if (previous.content !== current.content)
        return false;
    if (!areObjectsEqual(previous.attrs, current.attrs))
        return false;
    return true;
}
function areObjectsEqual(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    for (const key of Object.keys(a)) {
        if (a[key] !== b[key])
            return false;
    }
    return true;
}

exports.annotations = annotations;
exports.compile = compile;
exports.compileWithDecodedSourceMap = compileWithDecodedSourceMap;
//# sourceMappingURL=index.cjs.map
